/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  AvailabilityCheckRequest,
  AvailabilityCheckResponse,
  BookingCancel,
  BookingConfirmPayment,
  BookingCreate,
  BookingCreateResponse,
  BookingPaymentMethodUpdate,
  BookingPreviewResponse,
  BookingRescheduleRequest,
  BookingResponse,
  BookingStatsResponse,
  BookingUpdate,
  GetBookingPricingApiV1BookingsBookingIdPricingGetParams,
  GetBookingsApiV1BookingsGetParams,
  GetUpcomingBookingsApiV1BookingsUpcomingGetParams,
  HTTPValidationError,
  NoShowDisputeRequest,
  NoShowDisputeResponse,
  NoShowReportRequest,
  NoShowReportResponse,
  PaginatedResponseBookingResponse,
  PaginatedResponseUpcomingBookingResponse,
  PricingPreviewOut,
  RetryPaymentResponse,
  SendRemindersResponse,
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Get bookings for the current user with advanced filtering.

Parameters:
- status: Filter by specific booking status
- upcoming/upcoming_only: Only return future bookings (accepts both parameter names)
- exclude_future_confirmed: Exclude future confirmed bookings (for History tab)
- include_past_confirmed: Include past confirmed bookings (for BookAgain)
- page/per_page: Pagination parameters

Returns: Standardized PaginatedResponse with BookingResponse items
 * @summary Get Bookings
 */
export const getGetBookingsApiV1BookingsGetUrl = (params?: GetBookingsApiV1BookingsGetParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/bookings?${stringifiedParams}`
    : `/api/v1/bookings`;
};

export const getBookingsApiV1BookingsGet = async (
  params?: GetBookingsApiV1BookingsGetParams,
  options?: RequestInit
): Promise<PaginatedResponseBookingResponse> => {
  return customFetch<PaginatedResponseBookingResponse>(getGetBookingsApiV1BookingsGetUrl(params), {
    ...options,
    method: 'GET',
  });
};

export const getGetBookingsApiV1BookingsGetQueryKey = (
  params?: GetBookingsApiV1BookingsGetParams
) => {
  return [`/api/v1/bookings`, ...(params ? [params] : [])] as const;
};

export const getGetBookingsApiV1BookingsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBookingsApiV1BookingsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetBookingsApiV1BookingsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBookingsApiV1BookingsGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBookingsApiV1BookingsGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBookingsApiV1BookingsGet>>> = ({
    signal,
  }) => getBookingsApiV1BookingsGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBookingsApiV1BookingsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBookingsApiV1BookingsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBookingsApiV1BookingsGet>>
>;
export type GetBookingsApiV1BookingsGetQueryError = ErrorType<HTTPValidationError>;

export function useGetBookingsApiV1BookingsGet<
  TData = Awaited<ReturnType<typeof getBookingsApiV1BookingsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: undefined | GetBookingsApiV1BookingsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBookingsApiV1BookingsGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookingsApiV1BookingsGet>>,
          TError,
          Awaited<ReturnType<typeof getBookingsApiV1BookingsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookingsApiV1BookingsGet<
  TData = Awaited<ReturnType<typeof getBookingsApiV1BookingsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetBookingsApiV1BookingsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBookingsApiV1BookingsGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookingsApiV1BookingsGet>>,
          TError,
          Awaited<ReturnType<typeof getBookingsApiV1BookingsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookingsApiV1BookingsGet<
  TData = Awaited<ReturnType<typeof getBookingsApiV1BookingsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetBookingsApiV1BookingsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBookingsApiV1BookingsGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Bookings
 */

export function useGetBookingsApiV1BookingsGet<
  TData = Awaited<ReturnType<typeof getBookingsApiV1BookingsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetBookingsApiV1BookingsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getBookingsApiV1BookingsGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBookingsApiV1BookingsGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Create a booking with payment setup (Phase 2.1).

Two-step flow:
1. Creates booking with 'pending_payment' status
2. Returns SetupIntent client_secret for card collection
3. Frontend collects card details
4. Call /bookings/{id}/confirm-payment to complete

Rate limited per user to prevent booking spam.
 * @summary Create Booking
 */
export const getCreateBookingApiV1BookingsPostUrl = () => {
  return `/api/v1/bookings`;
};

export const createBookingApiV1BookingsPost = async (
  bookingCreate: BookingCreate,
  options?: RequestInit
): Promise<BookingCreateResponse> => {
  return customFetch<BookingCreateResponse>(getCreateBookingApiV1BookingsPostUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(bookingCreate),
  });
};

export const getCreateBookingApiV1BookingsPostMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createBookingApiV1BookingsPost>>,
    TError,
    { data: BookingCreate },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createBookingApiV1BookingsPost>>,
  TError,
  { data: BookingCreate },
  TContext
> => {
  const mutationKey = ['createBookingApiV1BookingsPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createBookingApiV1BookingsPost>>,
    { data: BookingCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createBookingApiV1BookingsPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateBookingApiV1BookingsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createBookingApiV1BookingsPost>>
>;
export type CreateBookingApiV1BookingsPostMutationBody = BookingCreate;
export type CreateBookingApiV1BookingsPostMutationError = ErrorType<void>;

/**
 * @summary Create Booking
 */
export const useCreateBookingApiV1BookingsPost = <TError = ErrorType<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createBookingApiV1BookingsPost>>,
      TError,
      { data: BookingCreate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createBookingApiV1BookingsPost>>,
  TError,
  { data: BookingCreate },
  TContext
> => {
  return useMutation(getCreateBookingApiV1BookingsPostMutationOptions(options), queryClient);
};
/**
 * Check if a time range is available for booking.

Rate limited to prevent abuse of expensive availability checks.
 * @summary Check Availability
 */
export const getCheckAvailabilityApiV1BookingsCheckAvailabilityPostUrl = () => {
  return `/api/v1/bookings/check-availability`;
};

export const checkAvailabilityApiV1BookingsCheckAvailabilityPost = async (
  availabilityCheckRequest: AvailabilityCheckRequest,
  options?: RequestInit
): Promise<AvailabilityCheckResponse> => {
  return customFetch<AvailabilityCheckResponse>(
    getCheckAvailabilityApiV1BookingsCheckAvailabilityPostUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(availabilityCheckRequest),
    }
  );
};

export const getCheckAvailabilityApiV1BookingsCheckAvailabilityPostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof checkAvailabilityApiV1BookingsCheckAvailabilityPost>>,
    TError,
    { data: AvailabilityCheckRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof checkAvailabilityApiV1BookingsCheckAvailabilityPost>>,
  TError,
  { data: AvailabilityCheckRequest },
  TContext
> => {
  const mutationKey = ['checkAvailabilityApiV1BookingsCheckAvailabilityPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof checkAvailabilityApiV1BookingsCheckAvailabilityPost>>,
    { data: AvailabilityCheckRequest }
  > = (props) => {
    const { data } = props ?? {};

    return checkAvailabilityApiV1BookingsCheckAvailabilityPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CheckAvailabilityApiV1BookingsCheckAvailabilityPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof checkAvailabilityApiV1BookingsCheckAvailabilityPost>>
>;
export type CheckAvailabilityApiV1BookingsCheckAvailabilityPostMutationBody =
  AvailabilityCheckRequest;
export type CheckAvailabilityApiV1BookingsCheckAvailabilityPostMutationError =
  ErrorType<HTTPValidationError>;

/**
 * @summary Check Availability
 */
export const useCheckAvailabilityApiV1BookingsCheckAvailabilityPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof checkAvailabilityApiV1BookingsCheckAvailabilityPost>>,
      TError,
      { data: AvailabilityCheckRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof checkAvailabilityApiV1BookingsCheckAvailabilityPost>>,
  TError,
  { data: AvailabilityCheckRequest },
  TContext
> => {
  return useMutation(
    getCheckAvailabilityApiV1BookingsCheckAvailabilityPostMutationOptions(options),
    queryClient
  );
};
/**
 * Send 24-hour reminder emails for tomorrow's bookings.

Should be called by scheduled job/cron.
Rate limited to prevent email spam.

Requires: MANAGE_ALL_BOOKINGS permission (admin only)
 * @summary Send Reminder Emails
 */
export const getSendReminderEmailsApiV1BookingsSendRemindersPostUrl = () => {
  return `/api/v1/bookings/send-reminders`;
};

export const sendReminderEmailsApiV1BookingsSendRemindersPost = async (
  options?: RequestInit
): Promise<SendRemindersResponse> => {
  return customFetch<SendRemindersResponse>(
    getSendReminderEmailsApiV1BookingsSendRemindersPostUrl(),
    {
      ...options,
      method: 'POST',
    }
  );
};

export const getSendReminderEmailsApiV1BookingsSendRemindersPostMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendReminderEmailsApiV1BookingsSendRemindersPost>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendReminderEmailsApiV1BookingsSendRemindersPost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['sendReminderEmailsApiV1BookingsSendRemindersPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendReminderEmailsApiV1BookingsSendRemindersPost>>,
    void
  > = () => {
    return sendReminderEmailsApiV1BookingsSendRemindersPost(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SendReminderEmailsApiV1BookingsSendRemindersPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof sendReminderEmailsApiV1BookingsSendRemindersPost>>
>;

export type SendReminderEmailsApiV1BookingsSendRemindersPostMutationError = ErrorType<unknown>;

/**
 * @summary Send Reminder Emails
 */
export const useSendReminderEmailsApiV1BookingsSendRemindersPost = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sendReminderEmailsApiV1BookingsSendRemindersPost>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof sendReminderEmailsApiV1BookingsSendRemindersPost>>,
  TError,
  void,
  TContext
> => {
  return useMutation(
    getSendReminderEmailsApiV1BookingsSendRemindersPostMutationOptions(options),
    queryClient
  );
};
/**
 * Get booking statistics (requires instructor role).
 * @summary Get Booking Stats
 */
export const getGetBookingStatsApiV1BookingsStatsGetUrl = () => {
  return `/api/v1/bookings/stats`;
};

export const getBookingStatsApiV1BookingsStatsGet = async (
  options?: RequestInit
): Promise<BookingStatsResponse> => {
  return customFetch<BookingStatsResponse>(getGetBookingStatsApiV1BookingsStatsGetUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getGetBookingStatsApiV1BookingsStatsGetQueryKey = () => {
  return [`/api/v1/bookings/stats`] as const;
};

export const getGetBookingStatsApiV1BookingsStatsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBookingStatsApiV1BookingsStatsGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getBookingStatsApiV1BookingsStatsGet>>, TError, TData>
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBookingStatsApiV1BookingsStatsGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getBookingStatsApiV1BookingsStatsGet>>
  > = ({ signal }) => getBookingStatsApiV1BookingsStatsGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBookingStatsApiV1BookingsStatsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBookingStatsApiV1BookingsStatsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBookingStatsApiV1BookingsStatsGet>>
>;
export type GetBookingStatsApiV1BookingsStatsGetQueryError = ErrorType<unknown>;

export function useGetBookingStatsApiV1BookingsStatsGet<
  TData = Awaited<ReturnType<typeof getBookingStatsApiV1BookingsStatsGet>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookingStatsApiV1BookingsStatsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookingStatsApiV1BookingsStatsGet>>,
          TError,
          Awaited<ReturnType<typeof getBookingStatsApiV1BookingsStatsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookingStatsApiV1BookingsStatsGet<
  TData = Awaited<ReturnType<typeof getBookingStatsApiV1BookingsStatsGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookingStatsApiV1BookingsStatsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookingStatsApiV1BookingsStatsGet>>,
          TError,
          Awaited<ReturnType<typeof getBookingStatsApiV1BookingsStatsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookingStatsApiV1BookingsStatsGet<
  TData = Awaited<ReturnType<typeof getBookingStatsApiV1BookingsStatsGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookingStatsApiV1BookingsStatsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Booking Stats
 */

export function useGetBookingStatsApiV1BookingsStatsGet<
  TData = Awaited<ReturnType<typeof getBookingStatsApiV1BookingsStatsGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookingStatsApiV1BookingsStatsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBookingStatsApiV1BookingsStatsGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get upcoming bookings for dashboard widget.
 * @summary Get Upcoming Bookings
 */
export const getGetUpcomingBookingsApiV1BookingsUpcomingGetUrl = (
  params?: GetUpcomingBookingsApiV1BookingsUpcomingGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/bookings/upcoming?${stringifiedParams}`
    : `/api/v1/bookings/upcoming`;
};

export const getUpcomingBookingsApiV1BookingsUpcomingGet = async (
  params?: GetUpcomingBookingsApiV1BookingsUpcomingGetParams,
  options?: RequestInit
): Promise<PaginatedResponseUpcomingBookingResponse> => {
  return customFetch<PaginatedResponseUpcomingBookingResponse>(
    getGetUpcomingBookingsApiV1BookingsUpcomingGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetUpcomingBookingsApiV1BookingsUpcomingGetQueryKey = (
  params?: GetUpcomingBookingsApiV1BookingsUpcomingGetParams
) => {
  return [`/api/v1/bookings/upcoming`, ...(params ? [params] : [])] as const;
};

export const getGetUpcomingBookingsApiV1BookingsUpcomingGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getUpcomingBookingsApiV1BookingsUpcomingGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetUpcomingBookingsApiV1BookingsUpcomingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUpcomingBookingsApiV1BookingsUpcomingGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUpcomingBookingsApiV1BookingsUpcomingGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUpcomingBookingsApiV1BookingsUpcomingGet>>
  > = ({ signal }) =>
    getUpcomingBookingsApiV1BookingsUpcomingGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUpcomingBookingsApiV1BookingsUpcomingGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUpcomingBookingsApiV1BookingsUpcomingGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUpcomingBookingsApiV1BookingsUpcomingGet>>
>;
export type GetUpcomingBookingsApiV1BookingsUpcomingGetQueryError = ErrorType<HTTPValidationError>;

export function useGetUpcomingBookingsApiV1BookingsUpcomingGet<
  TData = Awaited<ReturnType<typeof getUpcomingBookingsApiV1BookingsUpcomingGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: undefined | GetUpcomingBookingsApiV1BookingsUpcomingGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUpcomingBookingsApiV1BookingsUpcomingGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUpcomingBookingsApiV1BookingsUpcomingGet>>,
          TError,
          Awaited<ReturnType<typeof getUpcomingBookingsApiV1BookingsUpcomingGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUpcomingBookingsApiV1BookingsUpcomingGet<
  TData = Awaited<ReturnType<typeof getUpcomingBookingsApiV1BookingsUpcomingGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetUpcomingBookingsApiV1BookingsUpcomingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUpcomingBookingsApiV1BookingsUpcomingGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUpcomingBookingsApiV1BookingsUpcomingGet>>,
          TError,
          Awaited<ReturnType<typeof getUpcomingBookingsApiV1BookingsUpcomingGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUpcomingBookingsApiV1BookingsUpcomingGet<
  TData = Awaited<ReturnType<typeof getUpcomingBookingsApiV1BookingsUpcomingGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetUpcomingBookingsApiV1BookingsUpcomingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUpcomingBookingsApiV1BookingsUpcomingGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Upcoming Bookings
 */

export function useGetUpcomingBookingsApiV1BookingsUpcomingGet<
  TData = Awaited<ReturnType<typeof getUpcomingBookingsApiV1BookingsUpcomingGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetUpcomingBookingsApiV1BookingsUpcomingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUpcomingBookingsApiV1BookingsUpcomingGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUpcomingBookingsApiV1BookingsUpcomingGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get full booking details with privacy protection for students.
 * @summary Get Booking Details
 */
export const getGetBookingDetailsApiV1BookingsBookingIdGetUrl = (bookingId: string) => {
  return `/api/v1/bookings/${bookingId}`;
};

export const getBookingDetailsApiV1BookingsBookingIdGet = async (
  bookingId: string,
  options?: RequestInit
): Promise<BookingResponse> => {
  return customFetch<BookingResponse>(getGetBookingDetailsApiV1BookingsBookingIdGetUrl(bookingId), {
    ...options,
    method: 'GET',
  });
};

export const getGetBookingDetailsApiV1BookingsBookingIdGetQueryKey = (bookingId: string) => {
  return [`/api/v1/bookings/${bookingId}`] as const;
};

export const getGetBookingDetailsApiV1BookingsBookingIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBookingDetailsApiV1BookingsBookingIdGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  bookingId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookingDetailsApiV1BookingsBookingIdGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetBookingDetailsApiV1BookingsBookingIdGetQueryKey(bookingId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getBookingDetailsApiV1BookingsBookingIdGet>>
  > = ({ signal }) =>
    getBookingDetailsApiV1BookingsBookingIdGet(bookingId, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!bookingId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBookingDetailsApiV1BookingsBookingIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBookingDetailsApiV1BookingsBookingIdGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBookingDetailsApiV1BookingsBookingIdGet>>
>;
export type GetBookingDetailsApiV1BookingsBookingIdGetQueryError =
  ErrorType<void | HTTPValidationError>;

export function useGetBookingDetailsApiV1BookingsBookingIdGet<
  TData = Awaited<ReturnType<typeof getBookingDetailsApiV1BookingsBookingIdGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  bookingId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookingDetailsApiV1BookingsBookingIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookingDetailsApiV1BookingsBookingIdGet>>,
          TError,
          Awaited<ReturnType<typeof getBookingDetailsApiV1BookingsBookingIdGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookingDetailsApiV1BookingsBookingIdGet<
  TData = Awaited<ReturnType<typeof getBookingDetailsApiV1BookingsBookingIdGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  bookingId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookingDetailsApiV1BookingsBookingIdGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookingDetailsApiV1BookingsBookingIdGet>>,
          TError,
          Awaited<ReturnType<typeof getBookingDetailsApiV1BookingsBookingIdGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookingDetailsApiV1BookingsBookingIdGet<
  TData = Awaited<ReturnType<typeof getBookingDetailsApiV1BookingsBookingIdGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  bookingId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookingDetailsApiV1BookingsBookingIdGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Booking Details
 */

export function useGetBookingDetailsApiV1BookingsBookingIdGet<
  TData = Awaited<ReturnType<typeof getBookingDetailsApiV1BookingsBookingIdGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  bookingId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookingDetailsApiV1BookingsBookingIdGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBookingDetailsApiV1BookingsBookingIdGetQueryOptions(
    bookingId,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Update booking details (instructor only).
 * @summary Update Booking
 */
export const getUpdateBookingApiV1BookingsBookingIdPatchUrl = (bookingId: string) => {
  return `/api/v1/bookings/${bookingId}`;
};

export const updateBookingApiV1BookingsBookingIdPatch = async (
  bookingId: string,
  bookingUpdate: BookingUpdate,
  options?: RequestInit
): Promise<BookingResponse> => {
  return customFetch<BookingResponse>(getUpdateBookingApiV1BookingsBookingIdPatchUrl(bookingId), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(bookingUpdate),
  });
};

export const getUpdateBookingApiV1BookingsBookingIdPatchMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateBookingApiV1BookingsBookingIdPatch>>,
    TError,
    { bookingId: string; data: BookingUpdate },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateBookingApiV1BookingsBookingIdPatch>>,
  TError,
  { bookingId: string; data: BookingUpdate },
  TContext
> => {
  const mutationKey = ['updateBookingApiV1BookingsBookingIdPatch'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateBookingApiV1BookingsBookingIdPatch>>,
    { bookingId: string; data: BookingUpdate }
  > = (props) => {
    const { bookingId, data } = props ?? {};

    return updateBookingApiV1BookingsBookingIdPatch(bookingId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateBookingApiV1BookingsBookingIdPatchMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateBookingApiV1BookingsBookingIdPatch>>
>;
export type UpdateBookingApiV1BookingsBookingIdPatchMutationBody = BookingUpdate;
export type UpdateBookingApiV1BookingsBookingIdPatchMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Update Booking
 */
export const useUpdateBookingApiV1BookingsBookingIdPatch = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateBookingApiV1BookingsBookingIdPatch>>,
      TError,
      { bookingId: string; data: BookingUpdate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateBookingApiV1BookingsBookingIdPatch>>,
  TError,
  { bookingId: string; data: BookingUpdate },
  TContext
> => {
  return useMutation(
    getUpdateBookingApiV1BookingsBookingIdPatchMutationOptions(options),
    queryClient
  );
};
/**
 * Cancel a booking.
 * @summary Cancel Booking
 */
export const getCancelBookingApiV1BookingsBookingIdCancelPostUrl = (bookingId: string) => {
  return `/api/v1/bookings/${bookingId}/cancel`;
};

export const cancelBookingApiV1BookingsBookingIdCancelPost = async (
  bookingId: string,
  bookingCancel: BookingCancel,
  options?: RequestInit
): Promise<BookingResponse> => {
  return customFetch<BookingResponse>(
    getCancelBookingApiV1BookingsBookingIdCancelPostUrl(bookingId),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(bookingCancel),
    }
  );
};

export const getCancelBookingApiV1BookingsBookingIdCancelPostMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof cancelBookingApiV1BookingsBookingIdCancelPost>>,
    TError,
    { bookingId: string; data: BookingCancel },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof cancelBookingApiV1BookingsBookingIdCancelPost>>,
  TError,
  { bookingId: string; data: BookingCancel },
  TContext
> => {
  const mutationKey = ['cancelBookingApiV1BookingsBookingIdCancelPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof cancelBookingApiV1BookingsBookingIdCancelPost>>,
    { bookingId: string; data: BookingCancel }
  > = (props) => {
    const { bookingId, data } = props ?? {};

    return cancelBookingApiV1BookingsBookingIdCancelPost(bookingId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CancelBookingApiV1BookingsBookingIdCancelPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof cancelBookingApiV1BookingsBookingIdCancelPost>>
>;
export type CancelBookingApiV1BookingsBookingIdCancelPostMutationBody = BookingCancel;
export type CancelBookingApiV1BookingsBookingIdCancelPostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Cancel Booking
 */
export const useCancelBookingApiV1BookingsBookingIdCancelPost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof cancelBookingApiV1BookingsBookingIdCancelPost>>,
      TError,
      { bookingId: string; data: BookingCancel },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof cancelBookingApiV1BookingsBookingIdCancelPost>>,
  TError,
  { bookingId: string; data: BookingCancel },
  TContext
> => {
  return useMutation(
    getCancelBookingApiV1BookingsBookingIdCancelPostMutationOptions(options),
    queryClient
  );
};
/**
 * Mark a booking as completed.

Requires: COMPLETE_BOOKINGS permission (instructor only)
 * @summary Complete Booking
 */
export const getCompleteBookingApiV1BookingsBookingIdCompletePostUrl = (bookingId: string) => {
  return `/api/v1/bookings/${bookingId}/complete`;
};

export const completeBookingApiV1BookingsBookingIdCompletePost = async (
  bookingId: string,
  options?: RequestInit
): Promise<BookingResponse> => {
  return customFetch<BookingResponse>(
    getCompleteBookingApiV1BookingsBookingIdCompletePostUrl(bookingId),
    {
      ...options,
      method: 'POST',
    }
  );
};

export const getCompleteBookingApiV1BookingsBookingIdCompletePostMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof completeBookingApiV1BookingsBookingIdCompletePost>>,
    TError,
    { bookingId: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof completeBookingApiV1BookingsBookingIdCompletePost>>,
  TError,
  { bookingId: string },
  TContext
> => {
  const mutationKey = ['completeBookingApiV1BookingsBookingIdCompletePost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof completeBookingApiV1BookingsBookingIdCompletePost>>,
    { bookingId: string }
  > = (props) => {
    const { bookingId } = props ?? {};

    return completeBookingApiV1BookingsBookingIdCompletePost(bookingId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CompleteBookingApiV1BookingsBookingIdCompletePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof completeBookingApiV1BookingsBookingIdCompletePost>>
>;

export type CompleteBookingApiV1BookingsBookingIdCompletePostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Complete Booking
 */
export const useCompleteBookingApiV1BookingsBookingIdCompletePost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof completeBookingApiV1BookingsBookingIdCompletePost>>,
      TError,
      { bookingId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof completeBookingApiV1BookingsBookingIdCompletePost>>,
  TError,
  { bookingId: string },
  TContext
> => {
  return useMutation(
    getCompleteBookingApiV1BookingsBookingIdCompletePostMutationOptions(options),
    queryClient
  );
};
/**
 * Confirm payment method for a booking (Phase 2.1).

Deprecated: use /api/v1/payments/checkout instead.
 * @deprecated
 * @summary Confirm Booking Payment
 */
export const getConfirmBookingPaymentApiV1BookingsBookingIdConfirmPaymentPostUrl = (
  bookingId: string
) => {
  return `/api/v1/bookings/${bookingId}/confirm-payment`;
};

export const confirmBookingPaymentApiV1BookingsBookingIdConfirmPaymentPost = async (
  bookingId: string,
  bookingConfirmPayment: BookingConfirmPayment,
  options?: RequestInit
): Promise<BookingResponse> => {
  return customFetch<BookingResponse>(
    getConfirmBookingPaymentApiV1BookingsBookingIdConfirmPaymentPostUrl(bookingId),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(bookingConfirmPayment),
    }
  );
};

export const getConfirmBookingPaymentApiV1BookingsBookingIdConfirmPaymentPostMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof confirmBookingPaymentApiV1BookingsBookingIdConfirmPaymentPost>>,
    TError,
    { bookingId: string; data: BookingConfirmPayment },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof confirmBookingPaymentApiV1BookingsBookingIdConfirmPaymentPost>>,
  TError,
  { bookingId: string; data: BookingConfirmPayment },
  TContext
> => {
  const mutationKey = ['confirmBookingPaymentApiV1BookingsBookingIdConfirmPaymentPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof confirmBookingPaymentApiV1BookingsBookingIdConfirmPaymentPost>>,
    { bookingId: string; data: BookingConfirmPayment }
  > = (props) => {
    const { bookingId, data } = props ?? {};

    return confirmBookingPaymentApiV1BookingsBookingIdConfirmPaymentPost(
      bookingId,
      data,
      requestOptions
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type ConfirmBookingPaymentApiV1BookingsBookingIdConfirmPaymentPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof confirmBookingPaymentApiV1BookingsBookingIdConfirmPaymentPost>>
  >;
export type ConfirmBookingPaymentApiV1BookingsBookingIdConfirmPaymentPostMutationBody =
  BookingConfirmPayment;
export type ConfirmBookingPaymentApiV1BookingsBookingIdConfirmPaymentPostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @deprecated
 * @summary Confirm Booking Payment
 */
export const useConfirmBookingPaymentApiV1BookingsBookingIdConfirmPaymentPost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof confirmBookingPaymentApiV1BookingsBookingIdConfirmPaymentPost>>,
      TError,
      { bookingId: string; data: BookingConfirmPayment },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof confirmBookingPaymentApiV1BookingsBookingIdConfirmPaymentPost>>,
  TError,
  { bookingId: string; data: BookingConfirmPayment },
  TContext
> => {
  return useMutation(
    getConfirmBookingPaymentApiV1BookingsBookingIdConfirmPaymentPostMutationOptions(options),
    queryClient
  );
};
/**
 * Report a no-show for a booking.

- Student can report instructor no-show
- Admin can report either type
- Must be within reporting window
 * @summary Report No Show
 */
export const getReportNoShowApiV1BookingsBookingIdNoShowPostUrl = (bookingId: string) => {
  return `/api/v1/bookings/${bookingId}/no-show`;
};

export const reportNoShowApiV1BookingsBookingIdNoShowPost = async (
  bookingId: string,
  noShowReportRequest: NoShowReportRequest,
  options?: RequestInit
): Promise<NoShowReportResponse> => {
  return customFetch<NoShowReportResponse>(
    getReportNoShowApiV1BookingsBookingIdNoShowPostUrl(bookingId),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(noShowReportRequest),
    }
  );
};

export const getReportNoShowApiV1BookingsBookingIdNoShowPostMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof reportNoShowApiV1BookingsBookingIdNoShowPost>>,
    TError,
    { bookingId: string; data: NoShowReportRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof reportNoShowApiV1BookingsBookingIdNoShowPost>>,
  TError,
  { bookingId: string; data: NoShowReportRequest },
  TContext
> => {
  const mutationKey = ['reportNoShowApiV1BookingsBookingIdNoShowPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof reportNoShowApiV1BookingsBookingIdNoShowPost>>,
    { bookingId: string; data: NoShowReportRequest }
  > = (props) => {
    const { bookingId, data } = props ?? {};

    return reportNoShowApiV1BookingsBookingIdNoShowPost(bookingId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReportNoShowApiV1BookingsBookingIdNoShowPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof reportNoShowApiV1BookingsBookingIdNoShowPost>>
>;
export type ReportNoShowApiV1BookingsBookingIdNoShowPostMutationBody = NoShowReportRequest;
export type ReportNoShowApiV1BookingsBookingIdNoShowPostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Report No Show
 */
export const useReportNoShowApiV1BookingsBookingIdNoShowPost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof reportNoShowApiV1BookingsBookingIdNoShowPost>>,
      TError,
      { bookingId: string; data: NoShowReportRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof reportNoShowApiV1BookingsBookingIdNoShowPost>>,
  TError,
  { bookingId: string; data: NoShowReportRequest },
  TContext
> => {
  return useMutation(
    getReportNoShowApiV1BookingsBookingIdNoShowPostMutationOptions(options),
    queryClient
  );
};
/**
 * Dispute a no-show report.

Only the accused party can dispute within 24 hours of report.
 * @summary Dispute No Show
 */
export const getDisputeNoShowApiV1BookingsBookingIdNoShowDisputePostUrl = (bookingId: string) => {
  return `/api/v1/bookings/${bookingId}/no-show/dispute`;
};

export const disputeNoShowApiV1BookingsBookingIdNoShowDisputePost = async (
  bookingId: string,
  noShowDisputeRequest: NoShowDisputeRequest,
  options?: RequestInit
): Promise<NoShowDisputeResponse> => {
  return customFetch<NoShowDisputeResponse>(
    getDisputeNoShowApiV1BookingsBookingIdNoShowDisputePostUrl(bookingId),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(noShowDisputeRequest),
    }
  );
};

export const getDisputeNoShowApiV1BookingsBookingIdNoShowDisputePostMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof disputeNoShowApiV1BookingsBookingIdNoShowDisputePost>>,
    TError,
    { bookingId: string; data: NoShowDisputeRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof disputeNoShowApiV1BookingsBookingIdNoShowDisputePost>>,
  TError,
  { bookingId: string; data: NoShowDisputeRequest },
  TContext
> => {
  const mutationKey = ['disputeNoShowApiV1BookingsBookingIdNoShowDisputePost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof disputeNoShowApiV1BookingsBookingIdNoShowDisputePost>>,
    { bookingId: string; data: NoShowDisputeRequest }
  > = (props) => {
    const { bookingId, data } = props ?? {};

    return disputeNoShowApiV1BookingsBookingIdNoShowDisputePost(bookingId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DisputeNoShowApiV1BookingsBookingIdNoShowDisputePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof disputeNoShowApiV1BookingsBookingIdNoShowDisputePost>>
>;
export type DisputeNoShowApiV1BookingsBookingIdNoShowDisputePostMutationBody = NoShowDisputeRequest;
export type DisputeNoShowApiV1BookingsBookingIdNoShowDisputePostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Dispute No Show
 */
export const useDisputeNoShowApiV1BookingsBookingIdNoShowDisputePost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof disputeNoShowApiV1BookingsBookingIdNoShowDisputePost>>,
      TError,
      { bookingId: string; data: NoShowDisputeRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof disputeNoShowApiV1BookingsBookingIdNoShowDisputePost>>,
  TError,
  { bookingId: string; data: NoShowDisputeRequest },
  TContext
> => {
  return useMutation(
    getDisputeNoShowApiV1BookingsBookingIdNoShowDisputePostMutationOptions(options),
    queryClient
  );
};
/**
 * Update booking payment method and retry authorization immediately.

- Verifies ownership (student)
- Saves payment method (optional set_as_default)
- Retries authorization off-session (immediate if <24h)
 * @summary Update Booking Payment Method
 */
export const getUpdateBookingPaymentMethodApiV1BookingsBookingIdPaymentMethodPatchUrl = (
  bookingId: string
) => {
  return `/api/v1/bookings/${bookingId}/payment-method`;
};

export const updateBookingPaymentMethodApiV1BookingsBookingIdPaymentMethodPatch = async (
  bookingId: string,
  bookingPaymentMethodUpdate: BookingPaymentMethodUpdate,
  options?: RequestInit
): Promise<BookingResponse> => {
  return customFetch<BookingResponse>(
    getUpdateBookingPaymentMethodApiV1BookingsBookingIdPaymentMethodPatchUrl(bookingId),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(bookingPaymentMethodUpdate),
    }
  );
};

export const getUpdateBookingPaymentMethodApiV1BookingsBookingIdPaymentMethodPatchMutationOptions =
  <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof updateBookingPaymentMethodApiV1BookingsBookingIdPaymentMethodPatch>
      >,
      TError,
      { bookingId: string; data: BookingPaymentMethodUpdate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<ReturnType<typeof updateBookingPaymentMethodApiV1BookingsBookingIdPaymentMethodPatch>>,
    TError,
    { bookingId: string; data: BookingPaymentMethodUpdate },
    TContext
  > => {
    const mutationKey = ['updateBookingPaymentMethodApiV1BookingsBookingIdPaymentMethodPatch'];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof updateBookingPaymentMethodApiV1BookingsBookingIdPaymentMethodPatch>
      >,
      { bookingId: string; data: BookingPaymentMethodUpdate }
    > = (props) => {
      const { bookingId, data } = props ?? {};

      return updateBookingPaymentMethodApiV1BookingsBookingIdPaymentMethodPatch(
        bookingId,
        data,
        requestOptions
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type UpdateBookingPaymentMethodApiV1BookingsBookingIdPaymentMethodPatchMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof updateBookingPaymentMethodApiV1BookingsBookingIdPaymentMethodPatch>>
  >;
export type UpdateBookingPaymentMethodApiV1BookingsBookingIdPaymentMethodPatchMutationBody =
  BookingPaymentMethodUpdate;
export type UpdateBookingPaymentMethodApiV1BookingsBookingIdPaymentMethodPatchMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Update Booking Payment Method
 */
export const useUpdateBookingPaymentMethodApiV1BookingsBookingIdPaymentMethodPatch = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof updateBookingPaymentMethodApiV1BookingsBookingIdPaymentMethodPatch>
      >,
      TError,
      { bookingId: string; data: BookingPaymentMethodUpdate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateBookingPaymentMethodApiV1BookingsBookingIdPaymentMethodPatch>>,
  TError,
  { bookingId: string; data: BookingPaymentMethodUpdate },
  TContext
> => {
  return useMutation(
    getUpdateBookingPaymentMethodApiV1BookingsBookingIdPaymentMethodPatchMutationOptions(options),
    queryClient
  );
};
/**
 * Get preview information for a booking.
 * @summary Get Booking Preview
 */
export const getGetBookingPreviewApiV1BookingsBookingIdPreviewGetUrl = (bookingId: string) => {
  return `/api/v1/bookings/${bookingId}/preview`;
};

export const getBookingPreviewApiV1BookingsBookingIdPreviewGet = async (
  bookingId: string,
  options?: RequestInit
): Promise<BookingPreviewResponse> => {
  return customFetch<BookingPreviewResponse>(
    getGetBookingPreviewApiV1BookingsBookingIdPreviewGetUrl(bookingId),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetBookingPreviewApiV1BookingsBookingIdPreviewGetQueryKey = (bookingId: string) => {
  return [`/api/v1/bookings/${bookingId}/preview`] as const;
};

export const getGetBookingPreviewApiV1BookingsBookingIdPreviewGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBookingPreviewApiV1BookingsBookingIdPreviewGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  bookingId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookingPreviewApiV1BookingsBookingIdPreviewGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetBookingPreviewApiV1BookingsBookingIdPreviewGetQueryKey(bookingId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getBookingPreviewApiV1BookingsBookingIdPreviewGet>>
  > = ({ signal }) =>
    getBookingPreviewApiV1BookingsBookingIdPreviewGet(bookingId, { signal, ...requestOptions });

  return { queryKey, queryFn, enabled: !!bookingId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBookingPreviewApiV1BookingsBookingIdPreviewGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBookingPreviewApiV1BookingsBookingIdPreviewGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBookingPreviewApiV1BookingsBookingIdPreviewGet>>
>;
export type GetBookingPreviewApiV1BookingsBookingIdPreviewGetQueryError =
  ErrorType<void | HTTPValidationError>;

export function useGetBookingPreviewApiV1BookingsBookingIdPreviewGet<
  TData = Awaited<ReturnType<typeof getBookingPreviewApiV1BookingsBookingIdPreviewGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  bookingId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookingPreviewApiV1BookingsBookingIdPreviewGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookingPreviewApiV1BookingsBookingIdPreviewGet>>,
          TError,
          Awaited<ReturnType<typeof getBookingPreviewApiV1BookingsBookingIdPreviewGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookingPreviewApiV1BookingsBookingIdPreviewGet<
  TData = Awaited<ReturnType<typeof getBookingPreviewApiV1BookingsBookingIdPreviewGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  bookingId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookingPreviewApiV1BookingsBookingIdPreviewGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookingPreviewApiV1BookingsBookingIdPreviewGet>>,
          TError,
          Awaited<ReturnType<typeof getBookingPreviewApiV1BookingsBookingIdPreviewGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookingPreviewApiV1BookingsBookingIdPreviewGet<
  TData = Awaited<ReturnType<typeof getBookingPreviewApiV1BookingsBookingIdPreviewGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  bookingId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookingPreviewApiV1BookingsBookingIdPreviewGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Booking Preview
 */

export function useGetBookingPreviewApiV1BookingsBookingIdPreviewGet<
  TData = Awaited<ReturnType<typeof getBookingPreviewApiV1BookingsBookingIdPreviewGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  bookingId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookingPreviewApiV1BookingsBookingIdPreviewGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBookingPreviewApiV1BookingsBookingIdPreviewGetQueryOptions(
    bookingId,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Return a pricing preview for the requested booking.
 * @summary Get Booking Pricing
 */
export const getGetBookingPricingApiV1BookingsBookingIdPricingGetUrl = (
  bookingId: string,
  params?: GetBookingPricingApiV1BookingsBookingIdPricingGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/bookings/${bookingId}/pricing?${stringifiedParams}`
    : `/api/v1/bookings/${bookingId}/pricing`;
};

export const getBookingPricingApiV1BookingsBookingIdPricingGet = async (
  bookingId: string,
  params?: GetBookingPricingApiV1BookingsBookingIdPricingGetParams,
  options?: RequestInit
): Promise<PricingPreviewOut> => {
  return customFetch<PricingPreviewOut>(
    getGetBookingPricingApiV1BookingsBookingIdPricingGetUrl(bookingId, params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetBookingPricingApiV1BookingsBookingIdPricingGetQueryKey = (
  bookingId: string,
  params?: GetBookingPricingApiV1BookingsBookingIdPricingGetParams
) => {
  return [`/api/v1/bookings/${bookingId}/pricing`, ...(params ? [params] : [])] as const;
};

export const getGetBookingPricingApiV1BookingsBookingIdPricingGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBookingPricingApiV1BookingsBookingIdPricingGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  bookingId: string,
  params?: GetBookingPricingApiV1BookingsBookingIdPricingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookingPricingApiV1BookingsBookingIdPricingGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetBookingPricingApiV1BookingsBookingIdPricingGetQueryKey(bookingId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getBookingPricingApiV1BookingsBookingIdPricingGet>>
  > = ({ signal }) =>
    getBookingPricingApiV1BookingsBookingIdPricingGet(bookingId, params, {
      signal,
      ...requestOptions,
    });

  return { queryKey, queryFn, enabled: !!bookingId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBookingPricingApiV1BookingsBookingIdPricingGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBookingPricingApiV1BookingsBookingIdPricingGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBookingPricingApiV1BookingsBookingIdPricingGet>>
>;
export type GetBookingPricingApiV1BookingsBookingIdPricingGetQueryError =
  ErrorType<void | HTTPValidationError>;

export function useGetBookingPricingApiV1BookingsBookingIdPricingGet<
  TData = Awaited<ReturnType<typeof getBookingPricingApiV1BookingsBookingIdPricingGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  bookingId: string,
  params: undefined | GetBookingPricingApiV1BookingsBookingIdPricingGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookingPricingApiV1BookingsBookingIdPricingGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookingPricingApiV1BookingsBookingIdPricingGet>>,
          TError,
          Awaited<ReturnType<typeof getBookingPricingApiV1BookingsBookingIdPricingGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookingPricingApiV1BookingsBookingIdPricingGet<
  TData = Awaited<ReturnType<typeof getBookingPricingApiV1BookingsBookingIdPricingGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  bookingId: string,
  params?: GetBookingPricingApiV1BookingsBookingIdPricingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookingPricingApiV1BookingsBookingIdPricingGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookingPricingApiV1BookingsBookingIdPricingGet>>,
          TError,
          Awaited<ReturnType<typeof getBookingPricingApiV1BookingsBookingIdPricingGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBookingPricingApiV1BookingsBookingIdPricingGet<
  TData = Awaited<ReturnType<typeof getBookingPricingApiV1BookingsBookingIdPricingGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  bookingId: string,
  params?: GetBookingPricingApiV1BookingsBookingIdPricingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookingPricingApiV1BookingsBookingIdPricingGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Booking Pricing
 */

export function useGetBookingPricingApiV1BookingsBookingIdPricingGet<
  TData = Awaited<ReturnType<typeof getBookingPricingApiV1BookingsBookingIdPricingGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  bookingId: string,
  params?: GetBookingPricingApiV1BookingsBookingIdPricingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBookingPricingApiV1BookingsBookingIdPricingGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBookingPricingApiV1BookingsBookingIdPricingGetQueryOptions(
    bookingId,
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Reschedule flow (server-orchestrated):
- Validates access to the original booking
- Cancels the original booking according to policy
- Creates a new booking with the requested time
- Returns the new booking
 * @summary Reschedule Booking
 */
export const getRescheduleBookingApiV1BookingsBookingIdReschedulePostUrl = (bookingId: string) => {
  return `/api/v1/bookings/${bookingId}/reschedule`;
};

export const rescheduleBookingApiV1BookingsBookingIdReschedulePost = async (
  bookingId: string,
  bookingRescheduleRequest: BookingRescheduleRequest,
  options?: RequestInit
): Promise<BookingResponse> => {
  return customFetch<BookingResponse>(
    getRescheduleBookingApiV1BookingsBookingIdReschedulePostUrl(bookingId),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(bookingRescheduleRequest),
    }
  );
};

export const getRescheduleBookingApiV1BookingsBookingIdReschedulePostMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof rescheduleBookingApiV1BookingsBookingIdReschedulePost>>,
    TError,
    { bookingId: string; data: BookingRescheduleRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof rescheduleBookingApiV1BookingsBookingIdReschedulePost>>,
  TError,
  { bookingId: string; data: BookingRescheduleRequest },
  TContext
> => {
  const mutationKey = ['rescheduleBookingApiV1BookingsBookingIdReschedulePost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof rescheduleBookingApiV1BookingsBookingIdReschedulePost>>,
    { bookingId: string; data: BookingRescheduleRequest }
  > = (props) => {
    const { bookingId, data } = props ?? {};

    return rescheduleBookingApiV1BookingsBookingIdReschedulePost(bookingId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RescheduleBookingApiV1BookingsBookingIdReschedulePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof rescheduleBookingApiV1BookingsBookingIdReschedulePost>>
>;
export type RescheduleBookingApiV1BookingsBookingIdReschedulePostMutationBody =
  BookingRescheduleRequest;
export type RescheduleBookingApiV1BookingsBookingIdReschedulePostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Reschedule Booking
 */
export const useRescheduleBookingApiV1BookingsBookingIdReschedulePost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof rescheduleBookingApiV1BookingsBookingIdReschedulePost>>,
      TError,
      { bookingId: string; data: BookingRescheduleRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof rescheduleBookingApiV1BookingsBookingIdReschedulePost>>,
  TError,
  { bookingId: string; data: BookingRescheduleRequest },
  TContext
> => {
  return useMutation(
    getRescheduleBookingApiV1BookingsBookingIdReschedulePostMutationOptions(options),
    queryClient
  );
};
/**
 * Retry payment authorization after a failed attempt.
 * @summary Retry Payment Authorization
 */
export const getRetryPaymentAuthorizationApiV1BookingsBookingIdRetryPaymentPostUrl = (
  bookingId: string
) => {
  return `/api/v1/bookings/${bookingId}/retry-payment`;
};

export const retryPaymentAuthorizationApiV1BookingsBookingIdRetryPaymentPost = async (
  bookingId: string,
  options?: RequestInit
): Promise<RetryPaymentResponse> => {
  return customFetch<RetryPaymentResponse>(
    getRetryPaymentAuthorizationApiV1BookingsBookingIdRetryPaymentPostUrl(bookingId),
    {
      ...options,
      method: 'POST',
    }
  );
};

export const getRetryPaymentAuthorizationApiV1BookingsBookingIdRetryPaymentPostMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof retryPaymentAuthorizationApiV1BookingsBookingIdRetryPaymentPost>>,
    TError,
    { bookingId: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof retryPaymentAuthorizationApiV1BookingsBookingIdRetryPaymentPost>>,
  TError,
  { bookingId: string },
  TContext
> => {
  const mutationKey = ['retryPaymentAuthorizationApiV1BookingsBookingIdRetryPaymentPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof retryPaymentAuthorizationApiV1BookingsBookingIdRetryPaymentPost>>,
    { bookingId: string }
  > = (props) => {
    const { bookingId } = props ?? {};

    return retryPaymentAuthorizationApiV1BookingsBookingIdRetryPaymentPost(
      bookingId,
      requestOptions
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type RetryPaymentAuthorizationApiV1BookingsBookingIdRetryPaymentPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof retryPaymentAuthorizationApiV1BookingsBookingIdRetryPaymentPost>>
  >;

export type RetryPaymentAuthorizationApiV1BookingsBookingIdRetryPaymentPostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Retry Payment Authorization
 */
export const useRetryPaymentAuthorizationApiV1BookingsBookingIdRetryPaymentPost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof retryPaymentAuthorizationApiV1BookingsBookingIdRetryPaymentPost>>,
      TError,
      { bookingId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof retryPaymentAuthorizationApiV1BookingsBookingIdRetryPaymentPost>>,
  TError,
  { bookingId: string },
  TContext
> => {
  return useMutation(
    getRetryPaymentAuthorizationApiV1BookingsBookingIdRetryPaymentPostMutationOptions(options),
    queryClient
  );
};
