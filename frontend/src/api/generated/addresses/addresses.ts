/**
 * Generated by orval v7.16.1 ðŸº
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AddressCreate,
  AddressListResponse,
  AddressResponse,
  AddressUpdate,
  AppSchemasAddressResponsesDeleteResponse,
  AutocompleteResponse,
  CoverageFeatureCollectionResponse,
  GetBulkCoverageGeojsonApiAddressesCoverageBulkGetParams,
  HTTPValidationError,
  IsNycZipApiAddressesZipIsNycGetParams,
  ListNeighborhoodsApiAddressesRegionsNeighborhoodsGetParams,
  NYCZipCheckResponse,
  NeighborhoodsListResponse,
  PlaceDetails,
  PlaceDetailsApiAddressesPlacesDetailsGetParams,
  PlacesAutocompleteApiAddressesPlacesAutocompleteGetParams,
  ServiceAreasResponse,
  ServiceAreasUpdateRequest
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';




/**
 * Return GeoJSON FeatureCollection of neighborhoods served by the given instructors.

'ids' is a comma-separated list of instructor user IDs.
 * @summary Get Bulk Coverage Geojson
 */
export const getBulkCoverageGeojsonApiAddressesCoverageBulkGet = (
    params: GetBulkCoverageGeojsonApiAddressesCoverageBulkGetParams,
 signal?: AbortSignal
) => {


      return customFetch<CoverageFeatureCollectionResponse>(
      {url: `/api/addresses/coverage/bulk`, method: 'GET',
        params, signal
    },
      );
    }




export const getGetBulkCoverageGeojsonApiAddressesCoverageBulkGetQueryKey = (params?: GetBulkCoverageGeojsonApiAddressesCoverageBulkGetParams,) => {
    return [
    `/api/addresses/coverage/bulk`, ...(params ? [params]: [])
    ] as const;
    }


export const getGetBulkCoverageGeojsonApiAddressesCoverageBulkGetQueryOptions = <TData = Awaited<ReturnType<typeof getBulkCoverageGeojsonApiAddressesCoverageBulkGet>>, TError = ErrorType<HTTPValidationError>>(params: GetBulkCoverageGeojsonApiAddressesCoverageBulkGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBulkCoverageGeojsonApiAddressesCoverageBulkGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBulkCoverageGeojsonApiAddressesCoverageBulkGetQueryKey(params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBulkCoverageGeojsonApiAddressesCoverageBulkGet>>> = ({ signal }) => getBulkCoverageGeojsonApiAddressesCoverageBulkGet(params, signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBulkCoverageGeojsonApiAddressesCoverageBulkGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBulkCoverageGeojsonApiAddressesCoverageBulkGetQueryResult = NonNullable<Awaited<ReturnType<typeof getBulkCoverageGeojsonApiAddressesCoverageBulkGet>>>
export type GetBulkCoverageGeojsonApiAddressesCoverageBulkGetQueryError = ErrorType<HTTPValidationError>


export function useGetBulkCoverageGeojsonApiAddressesCoverageBulkGet<TData = Awaited<ReturnType<typeof getBulkCoverageGeojsonApiAddressesCoverageBulkGet>>, TError = ErrorType<HTTPValidationError>>(
 params: GetBulkCoverageGeojsonApiAddressesCoverageBulkGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBulkCoverageGeojsonApiAddressesCoverageBulkGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBulkCoverageGeojsonApiAddressesCoverageBulkGet>>,
          TError,
          Awaited<ReturnType<typeof getBulkCoverageGeojsonApiAddressesCoverageBulkGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBulkCoverageGeojsonApiAddressesCoverageBulkGet<TData = Awaited<ReturnType<typeof getBulkCoverageGeojsonApiAddressesCoverageBulkGet>>, TError = ErrorType<HTTPValidationError>>(
 params: GetBulkCoverageGeojsonApiAddressesCoverageBulkGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBulkCoverageGeojsonApiAddressesCoverageBulkGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBulkCoverageGeojsonApiAddressesCoverageBulkGet>>,
          TError,
          Awaited<ReturnType<typeof getBulkCoverageGeojsonApiAddressesCoverageBulkGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBulkCoverageGeojsonApiAddressesCoverageBulkGet<TData = Awaited<ReturnType<typeof getBulkCoverageGeojsonApiAddressesCoverageBulkGet>>, TError = ErrorType<HTTPValidationError>>(
 params: GetBulkCoverageGeojsonApiAddressesCoverageBulkGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBulkCoverageGeojsonApiAddressesCoverageBulkGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Bulk Coverage Geojson
 */

export function useGetBulkCoverageGeojsonApiAddressesCoverageBulkGet<TData = Awaited<ReturnType<typeof getBulkCoverageGeojsonApiAddressesCoverageBulkGet>>, TError = ErrorType<HTTPValidationError>>(
 params: GetBulkCoverageGeojsonApiAddressesCoverageBulkGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBulkCoverageGeojsonApiAddressesCoverageBulkGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBulkCoverageGeojsonApiAddressesCoverageBulkGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List My Addresses
 */
export const listMyAddressesApiAddressesMeGet = (

 signal?: AbortSignal
) => {


      return customFetch<AddressListResponse>(
      {url: `/api/addresses/me`, method: 'GET', signal
    },
      );
    }




export const getListMyAddressesApiAddressesMeGetQueryKey = () => {
    return [
    `/api/addresses/me`
    ] as const;
    }


export const getListMyAddressesApiAddressesMeGetQueryOptions = <TData = Awaited<ReturnType<typeof listMyAddressesApiAddressesMeGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMyAddressesApiAddressesMeGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListMyAddressesApiAddressesMeGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof listMyAddressesApiAddressesMeGet>>> = ({ signal }) => listMyAddressesApiAddressesMeGet(signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listMyAddressesApiAddressesMeGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListMyAddressesApiAddressesMeGetQueryResult = NonNullable<Awaited<ReturnType<typeof listMyAddressesApiAddressesMeGet>>>
export type ListMyAddressesApiAddressesMeGetQueryError = ErrorType<unknown>


export function useListMyAddressesApiAddressesMeGet<TData = Awaited<ReturnType<typeof listMyAddressesApiAddressesMeGet>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMyAddressesApiAddressesMeGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listMyAddressesApiAddressesMeGet>>,
          TError,
          Awaited<ReturnType<typeof listMyAddressesApiAddressesMeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListMyAddressesApiAddressesMeGet<TData = Awaited<ReturnType<typeof listMyAddressesApiAddressesMeGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMyAddressesApiAddressesMeGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listMyAddressesApiAddressesMeGet>>,
          TError,
          Awaited<ReturnType<typeof listMyAddressesApiAddressesMeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListMyAddressesApiAddressesMeGet<TData = Awaited<ReturnType<typeof listMyAddressesApiAddressesMeGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMyAddressesApiAddressesMeGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List My Addresses
 */

export function useListMyAddressesApiAddressesMeGet<TData = Awaited<ReturnType<typeof listMyAddressesApiAddressesMeGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMyAddressesApiAddressesMeGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListMyAddressesApiAddressesMeGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Create My Address
 */
export const createMyAddressApiAddressesMePost = (
    addressCreate: AddressCreate,
 signal?: AbortSignal
) => {


      return customFetch<AddressResponse>(
      {url: `/api/addresses/me`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: addressCreate, signal
    },
      );
    }



export const getCreateMyAddressApiAddressesMePostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMyAddressApiAddressesMePost>>, TError,{data: AddressCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createMyAddressApiAddressesMePost>>, TError,{data: AddressCreate}, TContext> => {

const mutationKey = ['createMyAddressApiAddressesMePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createMyAddressApiAddressesMePost>>, {data: AddressCreate}> = (props) => {
          const {data} = props ?? {};

          return  createMyAddressApiAddressesMePost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type CreateMyAddressApiAddressesMePostMutationResult = NonNullable<Awaited<ReturnType<typeof createMyAddressApiAddressesMePost>>>
    export type CreateMyAddressApiAddressesMePostMutationBody = AddressCreate
    export type CreateMyAddressApiAddressesMePostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Create My Address
 */
export const useCreateMyAddressApiAddressesMePost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createMyAddressApiAddressesMePost>>, TError,{data: AddressCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createMyAddressApiAddressesMePost>>,
        TError,
        {data: AddressCreate},
        TContext
      > => {

      const mutationOptions = getCreateMyAddressApiAddressesMePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Delete My Address
 */
export const deleteMyAddressApiAddressesMeAddressIdDelete = (
    addressId: string,
 ) => {


      return customFetch<AppSchemasAddressResponsesDeleteResponse>(
      {url: `/api/addresses/me/${addressId}`, method: 'DELETE'
    },
      );
    }



export const getDeleteMyAddressApiAddressesMeAddressIdDeleteMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMyAddressApiAddressesMeAddressIdDelete>>, TError,{addressId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteMyAddressApiAddressesMeAddressIdDelete>>, TError,{addressId: string}, TContext> => {

const mutationKey = ['deleteMyAddressApiAddressesMeAddressIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMyAddressApiAddressesMeAddressIdDelete>>, {addressId: string}> = (props) => {
          const {addressId} = props ?? {};

          return  deleteMyAddressApiAddressesMeAddressIdDelete(addressId,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type DeleteMyAddressApiAddressesMeAddressIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMyAddressApiAddressesMeAddressIdDelete>>>

    export type DeleteMyAddressApiAddressesMeAddressIdDeleteMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Delete My Address
 */
export const useDeleteMyAddressApiAddressesMeAddressIdDelete = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMyAddressApiAddressesMeAddressIdDelete>>, TError,{addressId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteMyAddressApiAddressesMeAddressIdDelete>>,
        TError,
        {addressId: string},
        TContext
      > => {

      const mutationOptions = getDeleteMyAddressApiAddressesMeAddressIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Update My Address
 */
export const updateMyAddressApiAddressesMeAddressIdPatch = (
    addressId: string,
    addressUpdate: AddressUpdate,
 ) => {


      return customFetch<AddressResponse>(
      {url: `/api/addresses/me/${addressId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: addressUpdate
    },
      );
    }



export const getUpdateMyAddressApiAddressesMeAddressIdPatchMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMyAddressApiAddressesMeAddressIdPatch>>, TError,{addressId: string;data: AddressUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateMyAddressApiAddressesMeAddressIdPatch>>, TError,{addressId: string;data: AddressUpdate}, TContext> => {

const mutationKey = ['updateMyAddressApiAddressesMeAddressIdPatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateMyAddressApiAddressesMeAddressIdPatch>>, {addressId: string;data: AddressUpdate}> = (props) => {
          const {addressId,data} = props ?? {};

          return  updateMyAddressApiAddressesMeAddressIdPatch(addressId,data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type UpdateMyAddressApiAddressesMeAddressIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateMyAddressApiAddressesMeAddressIdPatch>>>
    export type UpdateMyAddressApiAddressesMeAddressIdPatchMutationBody = AddressUpdate
    export type UpdateMyAddressApiAddressesMeAddressIdPatchMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Update My Address
 */
export const useUpdateMyAddressApiAddressesMeAddressIdPatch = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateMyAddressApiAddressesMeAddressIdPatch>>, TError,{addressId: string;data: AddressUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateMyAddressApiAddressesMeAddressIdPatch>>,
        TError,
        {addressId: string;data: AddressUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateMyAddressApiAddressesMeAddressIdPatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Provider-agnostic autocomplete passthrough.

Uses the configured provider to retrieve suggestions.
 * @summary Places Autocomplete
 */
export const placesAutocompleteApiAddressesPlacesAutocompleteGet = (
    params: PlacesAutocompleteApiAddressesPlacesAutocompleteGetParams,
 signal?: AbortSignal
) => {


      return customFetch<AutocompleteResponse>(
      {url: `/api/addresses/places/autocomplete`, method: 'GET',
        params, signal
    },
      );
    }




export const getPlacesAutocompleteApiAddressesPlacesAutocompleteGetQueryKey = (params?: PlacesAutocompleteApiAddressesPlacesAutocompleteGetParams,) => {
    return [
    `/api/addresses/places/autocomplete`, ...(params ? [params]: [])
    ] as const;
    }


export const getPlacesAutocompleteApiAddressesPlacesAutocompleteGetQueryOptions = <TData = Awaited<ReturnType<typeof placesAutocompleteApiAddressesPlacesAutocompleteGet>>, TError = ErrorType<HTTPValidationError>>(params: PlacesAutocompleteApiAddressesPlacesAutocompleteGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof placesAutocompleteApiAddressesPlacesAutocompleteGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPlacesAutocompleteApiAddressesPlacesAutocompleteGetQueryKey(params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof placesAutocompleteApiAddressesPlacesAutocompleteGet>>> = ({ signal }) => placesAutocompleteApiAddressesPlacesAutocompleteGet(params, signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof placesAutocompleteApiAddressesPlacesAutocompleteGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PlacesAutocompleteApiAddressesPlacesAutocompleteGetQueryResult = NonNullable<Awaited<ReturnType<typeof placesAutocompleteApiAddressesPlacesAutocompleteGet>>>
export type PlacesAutocompleteApiAddressesPlacesAutocompleteGetQueryError = ErrorType<HTTPValidationError>


export function usePlacesAutocompleteApiAddressesPlacesAutocompleteGet<TData = Awaited<ReturnType<typeof placesAutocompleteApiAddressesPlacesAutocompleteGet>>, TError = ErrorType<HTTPValidationError>>(
 params: PlacesAutocompleteApiAddressesPlacesAutocompleteGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof placesAutocompleteApiAddressesPlacesAutocompleteGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof placesAutocompleteApiAddressesPlacesAutocompleteGet>>,
          TError,
          Awaited<ReturnType<typeof placesAutocompleteApiAddressesPlacesAutocompleteGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePlacesAutocompleteApiAddressesPlacesAutocompleteGet<TData = Awaited<ReturnType<typeof placesAutocompleteApiAddressesPlacesAutocompleteGet>>, TError = ErrorType<HTTPValidationError>>(
 params: PlacesAutocompleteApiAddressesPlacesAutocompleteGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof placesAutocompleteApiAddressesPlacesAutocompleteGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof placesAutocompleteApiAddressesPlacesAutocompleteGet>>,
          TError,
          Awaited<ReturnType<typeof placesAutocompleteApiAddressesPlacesAutocompleteGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePlacesAutocompleteApiAddressesPlacesAutocompleteGet<TData = Awaited<ReturnType<typeof placesAutocompleteApiAddressesPlacesAutocompleteGet>>, TError = ErrorType<HTTPValidationError>>(
 params: PlacesAutocompleteApiAddressesPlacesAutocompleteGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof placesAutocompleteApiAddressesPlacesAutocompleteGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Places Autocomplete
 */

export function usePlacesAutocompleteApiAddressesPlacesAutocompleteGet<TData = Awaited<ReturnType<typeof placesAutocompleteApiAddressesPlacesAutocompleteGet>>, TError = ErrorType<HTTPValidationError>>(
 params: PlacesAutocompleteApiAddressesPlacesAutocompleteGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof placesAutocompleteApiAddressesPlacesAutocompleteGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPlacesAutocompleteApiAddressesPlacesAutocompleteGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Return normalized place details for a selected suggestion.

Frontend uses this to auto-fill form fields without exposing provider payloads.
 * @summary Place Details
 */
export const placeDetailsApiAddressesPlacesDetailsGet = (
    params: PlaceDetailsApiAddressesPlacesDetailsGetParams,
 signal?: AbortSignal
) => {


      return customFetch<PlaceDetails>(
      {url: `/api/addresses/places/details`, method: 'GET',
        params, signal
    },
      );
    }




export const getPlaceDetailsApiAddressesPlacesDetailsGetQueryKey = (params?: PlaceDetailsApiAddressesPlacesDetailsGetParams,) => {
    return [
    `/api/addresses/places/details`, ...(params ? [params]: [])
    ] as const;
    }


export const getPlaceDetailsApiAddressesPlacesDetailsGetQueryOptions = <TData = Awaited<ReturnType<typeof placeDetailsApiAddressesPlacesDetailsGet>>, TError = ErrorType<HTTPValidationError>>(params: PlaceDetailsApiAddressesPlacesDetailsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof placeDetailsApiAddressesPlacesDetailsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPlaceDetailsApiAddressesPlacesDetailsGetQueryKey(params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof placeDetailsApiAddressesPlacesDetailsGet>>> = ({ signal }) => placeDetailsApiAddressesPlacesDetailsGet(params, signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof placeDetailsApiAddressesPlacesDetailsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PlaceDetailsApiAddressesPlacesDetailsGetQueryResult = NonNullable<Awaited<ReturnType<typeof placeDetailsApiAddressesPlacesDetailsGet>>>
export type PlaceDetailsApiAddressesPlacesDetailsGetQueryError = ErrorType<HTTPValidationError>


export function usePlaceDetailsApiAddressesPlacesDetailsGet<TData = Awaited<ReturnType<typeof placeDetailsApiAddressesPlacesDetailsGet>>, TError = ErrorType<HTTPValidationError>>(
 params: PlaceDetailsApiAddressesPlacesDetailsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof placeDetailsApiAddressesPlacesDetailsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof placeDetailsApiAddressesPlacesDetailsGet>>,
          TError,
          Awaited<ReturnType<typeof placeDetailsApiAddressesPlacesDetailsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePlaceDetailsApiAddressesPlacesDetailsGet<TData = Awaited<ReturnType<typeof placeDetailsApiAddressesPlacesDetailsGet>>, TError = ErrorType<HTTPValidationError>>(
 params: PlaceDetailsApiAddressesPlacesDetailsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof placeDetailsApiAddressesPlacesDetailsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof placeDetailsApiAddressesPlacesDetailsGet>>,
          TError,
          Awaited<ReturnType<typeof placeDetailsApiAddressesPlacesDetailsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePlaceDetailsApiAddressesPlacesDetailsGet<TData = Awaited<ReturnType<typeof placeDetailsApiAddressesPlacesDetailsGet>>, TError = ErrorType<HTTPValidationError>>(
 params: PlaceDetailsApiAddressesPlacesDetailsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof placeDetailsApiAddressesPlacesDetailsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Place Details
 */

export function usePlaceDetailsApiAddressesPlacesDetailsGet<TData = Awaited<ReturnType<typeof placeDetailsApiAddressesPlacesDetailsGet>>, TError = ErrorType<HTTPValidationError>>(
 params: PlaceDetailsApiAddressesPlacesDetailsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof placeDetailsApiAddressesPlacesDetailsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPlaceDetailsApiAddressesPlacesDetailsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List Neighborhoods
 */
export const listNeighborhoodsApiAddressesRegionsNeighborhoodsGet = (
    params?: ListNeighborhoodsApiAddressesRegionsNeighborhoodsGetParams,
 signal?: AbortSignal
) => {


      return customFetch<NeighborhoodsListResponse>(
      {url: `/api/addresses/regions/neighborhoods`, method: 'GET',
        params, signal
    },
      );
    }




export const getListNeighborhoodsApiAddressesRegionsNeighborhoodsGetQueryKey = (params?: ListNeighborhoodsApiAddressesRegionsNeighborhoodsGetParams,) => {
    return [
    `/api/addresses/regions/neighborhoods`, ...(params ? [params]: [])
    ] as const;
    }


export const getListNeighborhoodsApiAddressesRegionsNeighborhoodsGetQueryOptions = <TData = Awaited<ReturnType<typeof listNeighborhoodsApiAddressesRegionsNeighborhoodsGet>>, TError = ErrorType<HTTPValidationError>>(params?: ListNeighborhoodsApiAddressesRegionsNeighborhoodsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNeighborhoodsApiAddressesRegionsNeighborhoodsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListNeighborhoodsApiAddressesRegionsNeighborhoodsGetQueryKey(params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof listNeighborhoodsApiAddressesRegionsNeighborhoodsGet>>> = ({ signal }) => listNeighborhoodsApiAddressesRegionsNeighborhoodsGet(params, signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listNeighborhoodsApiAddressesRegionsNeighborhoodsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListNeighborhoodsApiAddressesRegionsNeighborhoodsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listNeighborhoodsApiAddressesRegionsNeighborhoodsGet>>>
export type ListNeighborhoodsApiAddressesRegionsNeighborhoodsGetQueryError = ErrorType<HTTPValidationError>


export function useListNeighborhoodsApiAddressesRegionsNeighborhoodsGet<TData = Awaited<ReturnType<typeof listNeighborhoodsApiAddressesRegionsNeighborhoodsGet>>, TError = ErrorType<HTTPValidationError>>(
 params: undefined |  ListNeighborhoodsApiAddressesRegionsNeighborhoodsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNeighborhoodsApiAddressesRegionsNeighborhoodsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listNeighborhoodsApiAddressesRegionsNeighborhoodsGet>>,
          TError,
          Awaited<ReturnType<typeof listNeighborhoodsApiAddressesRegionsNeighborhoodsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListNeighborhoodsApiAddressesRegionsNeighborhoodsGet<TData = Awaited<ReturnType<typeof listNeighborhoodsApiAddressesRegionsNeighborhoodsGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: ListNeighborhoodsApiAddressesRegionsNeighborhoodsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNeighborhoodsApiAddressesRegionsNeighborhoodsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listNeighborhoodsApiAddressesRegionsNeighborhoodsGet>>,
          TError,
          Awaited<ReturnType<typeof listNeighborhoodsApiAddressesRegionsNeighborhoodsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListNeighborhoodsApiAddressesRegionsNeighborhoodsGet<TData = Awaited<ReturnType<typeof listNeighborhoodsApiAddressesRegionsNeighborhoodsGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: ListNeighborhoodsApiAddressesRegionsNeighborhoodsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNeighborhoodsApiAddressesRegionsNeighborhoodsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Neighborhoods
 */

export function useListNeighborhoodsApiAddressesRegionsNeighborhoodsGet<TData = Awaited<ReturnType<typeof listNeighborhoodsApiAddressesRegionsNeighborhoodsGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: ListNeighborhoodsApiAddressesRegionsNeighborhoodsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listNeighborhoodsApiAddressesRegionsNeighborhoodsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListNeighborhoodsApiAddressesRegionsNeighborhoodsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary List My Service Areas
 */
export const listMyServiceAreasApiAddressesServiceAreasMeGet = (

 signal?: AbortSignal
) => {


      return customFetch<ServiceAreasResponse>(
      {url: `/api/addresses/service-areas/me`, method: 'GET', signal
    },
      );
    }




export const getListMyServiceAreasApiAddressesServiceAreasMeGetQueryKey = () => {
    return [
    `/api/addresses/service-areas/me`
    ] as const;
    }


export const getListMyServiceAreasApiAddressesServiceAreasMeGetQueryOptions = <TData = Awaited<ReturnType<typeof listMyServiceAreasApiAddressesServiceAreasMeGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMyServiceAreasApiAddressesServiceAreasMeGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListMyServiceAreasApiAddressesServiceAreasMeGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof listMyServiceAreasApiAddressesServiceAreasMeGet>>> = ({ signal }) => listMyServiceAreasApiAddressesServiceAreasMeGet(signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listMyServiceAreasApiAddressesServiceAreasMeGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListMyServiceAreasApiAddressesServiceAreasMeGetQueryResult = NonNullable<Awaited<ReturnType<typeof listMyServiceAreasApiAddressesServiceAreasMeGet>>>
export type ListMyServiceAreasApiAddressesServiceAreasMeGetQueryError = ErrorType<unknown>


export function useListMyServiceAreasApiAddressesServiceAreasMeGet<TData = Awaited<ReturnType<typeof listMyServiceAreasApiAddressesServiceAreasMeGet>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMyServiceAreasApiAddressesServiceAreasMeGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listMyServiceAreasApiAddressesServiceAreasMeGet>>,
          TError,
          Awaited<ReturnType<typeof listMyServiceAreasApiAddressesServiceAreasMeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListMyServiceAreasApiAddressesServiceAreasMeGet<TData = Awaited<ReturnType<typeof listMyServiceAreasApiAddressesServiceAreasMeGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMyServiceAreasApiAddressesServiceAreasMeGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listMyServiceAreasApiAddressesServiceAreasMeGet>>,
          TError,
          Awaited<ReturnType<typeof listMyServiceAreasApiAddressesServiceAreasMeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListMyServiceAreasApiAddressesServiceAreasMeGet<TData = Awaited<ReturnType<typeof listMyServiceAreasApiAddressesServiceAreasMeGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMyServiceAreasApiAddressesServiceAreasMeGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List My Service Areas
 */

export function useListMyServiceAreasApiAddressesServiceAreasMeGet<TData = Awaited<ReturnType<typeof listMyServiceAreasApiAddressesServiceAreasMeGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listMyServiceAreasApiAddressesServiceAreasMeGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListMyServiceAreasApiAddressesServiceAreasMeGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Replace My Service Areas
 */
export const replaceMyServiceAreasApiAddressesServiceAreasMePut = (
    serviceAreasUpdateRequest: ServiceAreasUpdateRequest,
 ) => {


      return customFetch<ServiceAreasResponse>(
      {url: `/api/addresses/service-areas/me`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: serviceAreasUpdateRequest
    },
      );
    }



export const getReplaceMyServiceAreasApiAddressesServiceAreasMePutMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replaceMyServiceAreasApiAddressesServiceAreasMePut>>, TError,{data: ServiceAreasUpdateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof replaceMyServiceAreasApiAddressesServiceAreasMePut>>, TError,{data: ServiceAreasUpdateRequest}, TContext> => {

const mutationKey = ['replaceMyServiceAreasApiAddressesServiceAreasMePut'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof replaceMyServiceAreasApiAddressesServiceAreasMePut>>, {data: ServiceAreasUpdateRequest}> = (props) => {
          const {data} = props ?? {};

          return  replaceMyServiceAreasApiAddressesServiceAreasMePut(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type ReplaceMyServiceAreasApiAddressesServiceAreasMePutMutationResult = NonNullable<Awaited<ReturnType<typeof replaceMyServiceAreasApiAddressesServiceAreasMePut>>>
    export type ReplaceMyServiceAreasApiAddressesServiceAreasMePutMutationBody = ServiceAreasUpdateRequest
    export type ReplaceMyServiceAreasApiAddressesServiceAreasMePutMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Replace My Service Areas
 */
export const useReplaceMyServiceAreasApiAddressesServiceAreasMePut = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replaceMyServiceAreasApiAddressesServiceAreasMePut>>, TError,{data: ServiceAreasUpdateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof replaceMyServiceAreasApiAddressesServiceAreasMePut>>,
        TError,
        {data: ServiceAreasUpdateRequest},
        TContext
      > => {

      const mutationOptions = getReplaceMyServiceAreasApiAddressesServiceAreasMePutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Lightweight NYC ZIP check.

Args:
    zip: Five-digit ZIP code.

Returns:
    { "is_nyc": bool, "borough": Optional[str] }

Notes:
    - This endpoint is deterministic and does not require geocoding APIs.
    - It is sufficient for onboarding gating; deeper enrichment occurs when
      we create an address with lat/lng.
 * @summary Is Nyc Zip
 */
export const isNycZipApiAddressesZipIsNycGet = (
    params: IsNycZipApiAddressesZipIsNycGetParams,
 signal?: AbortSignal
) => {


      return customFetch<NYCZipCheckResponse>(
      {url: `/api/addresses/zip/is-nyc`, method: 'GET',
        params, signal
    },
      );
    }




export const getIsNycZipApiAddressesZipIsNycGetQueryKey = (params?: IsNycZipApiAddressesZipIsNycGetParams,) => {
    return [
    `/api/addresses/zip/is-nyc`, ...(params ? [params]: [])
    ] as const;
    }


export const getIsNycZipApiAddressesZipIsNycGetQueryOptions = <TData = Awaited<ReturnType<typeof isNycZipApiAddressesZipIsNycGet>>, TError = ErrorType<HTTPValidationError>>(params: IsNycZipApiAddressesZipIsNycGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isNycZipApiAddressesZipIsNycGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getIsNycZipApiAddressesZipIsNycGetQueryKey(params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof isNycZipApiAddressesZipIsNycGet>>> = ({ signal }) => isNycZipApiAddressesZipIsNycGet(params, signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof isNycZipApiAddressesZipIsNycGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type IsNycZipApiAddressesZipIsNycGetQueryResult = NonNullable<Awaited<ReturnType<typeof isNycZipApiAddressesZipIsNycGet>>>
export type IsNycZipApiAddressesZipIsNycGetQueryError = ErrorType<HTTPValidationError>


export function useIsNycZipApiAddressesZipIsNycGet<TData = Awaited<ReturnType<typeof isNycZipApiAddressesZipIsNycGet>>, TError = ErrorType<HTTPValidationError>>(
 params: IsNycZipApiAddressesZipIsNycGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof isNycZipApiAddressesZipIsNycGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isNycZipApiAddressesZipIsNycGet>>,
          TError,
          Awaited<ReturnType<typeof isNycZipApiAddressesZipIsNycGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsNycZipApiAddressesZipIsNycGet<TData = Awaited<ReturnType<typeof isNycZipApiAddressesZipIsNycGet>>, TError = ErrorType<HTTPValidationError>>(
 params: IsNycZipApiAddressesZipIsNycGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isNycZipApiAddressesZipIsNycGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isNycZipApiAddressesZipIsNycGet>>,
          TError,
          Awaited<ReturnType<typeof isNycZipApiAddressesZipIsNycGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useIsNycZipApiAddressesZipIsNycGet<TData = Awaited<ReturnType<typeof isNycZipApiAddressesZipIsNycGet>>, TError = ErrorType<HTTPValidationError>>(
 params: IsNycZipApiAddressesZipIsNycGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isNycZipApiAddressesZipIsNycGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Is Nyc Zip
 */

export function useIsNycZipApiAddressesZipIsNycGet<TData = Awaited<ReturnType<typeof isNycZipApiAddressesZipIsNycGet>>, TError = ErrorType<HTTPValidationError>>(
 params: IsNycZipApiAddressesZipIsNycGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof isNycZipApiAddressesZipIsNycGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getIsNycZipApiAddressesZipIsNycGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
