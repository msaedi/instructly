/**
 * Generated by orval v7.16.1 ðŸº
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AuthUserResponse,
  AuthUserWithPermissionsResponse,
  BodyLoginApiV1AuthLoginPost,
  HTTPValidationError,
  LoginResponse,
  PasswordChangeRequest,
  PasswordChangeResponse,
  UserCreate,
  UserLogin,
  UserUpdate
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';




/**
 * Change password for the current authenticated user.

Verifies the current password, enforces minimal strength, and updates the hash.
 * @summary Change Password
 */
export const changePasswordApiV1AuthChangePasswordPost = (
    passwordChangeRequest: PasswordChangeRequest,
 signal?: AbortSignal
) => {


      return customFetch<PasswordChangeResponse>(
      {url: `/api/v1/auth/change-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: passwordChangeRequest, signal
    },
      );
    }



export const getChangePasswordApiV1AuthChangePasswordPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changePasswordApiV1AuthChangePasswordPost>>, TError,{data: PasswordChangeRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof changePasswordApiV1AuthChangePasswordPost>>, TError,{data: PasswordChangeRequest}, TContext> => {

const mutationKey = ['changePasswordApiV1AuthChangePasswordPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof changePasswordApiV1AuthChangePasswordPost>>, {data: PasswordChangeRequest}> = (props) => {
          const {data} = props ?? {};

          return  changePasswordApiV1AuthChangePasswordPost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type ChangePasswordApiV1AuthChangePasswordPostMutationResult = NonNullable<Awaited<ReturnType<typeof changePasswordApiV1AuthChangePasswordPost>>>
    export type ChangePasswordApiV1AuthChangePasswordPostMutationBody = PasswordChangeRequest
    export type ChangePasswordApiV1AuthChangePasswordPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Change Password
 */
export const useChangePasswordApiV1AuthChangePasswordPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changePasswordApiV1AuthChangePasswordPost>>, TError,{data: PasswordChangeRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof changePasswordApiV1AuthChangePasswordPost>>,
        TError,
        {data: PasswordChangeRequest},
        TContext
      > => {

      const mutationOptions = getChangePasswordApiV1AuthChangePasswordPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Login with username (email) and password.

Rate limited to prevent brute force attacks.

Args:
    form_data: OAuth2 form with username and password
    auth_service: Authentication service

Returns:
    LoginResponse: Access token metadata for the client

Raises:
    HTTPException: If credentials are invalid or rate limit exceeded
 * @summary Login
 */
export const loginApiV1AuthLoginPost = (
    bodyLoginApiV1AuthLoginPost: BodyLoginApiV1AuthLoginPost,
 signal?: AbortSignal
) => {

      const formUrlEncoded = new URLSearchParams();
if(bodyLoginApiV1AuthLoginPost.client_id !== undefined && bodyLoginApiV1AuthLoginPost.client_id !== null) {
 formUrlEncoded.append(`client_id`, bodyLoginApiV1AuthLoginPost.client_id)
 }
if(bodyLoginApiV1AuthLoginPost.client_secret !== undefined && bodyLoginApiV1AuthLoginPost.client_secret !== null) {
 formUrlEncoded.append(`client_secret`, bodyLoginApiV1AuthLoginPost.client_secret)
 }
if(bodyLoginApiV1AuthLoginPost.grant_type !== undefined && bodyLoginApiV1AuthLoginPost.grant_type !== null) {
 formUrlEncoded.append(`grant_type`, bodyLoginApiV1AuthLoginPost.grant_type)
 }
formUrlEncoded.append(`password`, bodyLoginApiV1AuthLoginPost.password)
if(bodyLoginApiV1AuthLoginPost.scope !== undefined) {
 formUrlEncoded.append(`scope`, bodyLoginApiV1AuthLoginPost.scope)
 }
formUrlEncoded.append(`username`, bodyLoginApiV1AuthLoginPost.username)

      return customFetch<LoginResponse>(
      {url: `/api/v1/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/x-www-form-urlencoded', },
       data: formUrlEncoded, signal
    },
      );
    }



export const getLoginApiV1AuthLoginPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>, TError,{data: BodyLoginApiV1AuthLoginPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>, TError,{data: BodyLoginApiV1AuthLoginPost}, TContext> => {

const mutationKey = ['loginApiV1AuthLoginPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>, {data: BodyLoginApiV1AuthLoginPost}> = (props) => {
          const {data} = props ?? {};

          return  loginApiV1AuthLoginPost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type LoginApiV1AuthLoginPostMutationResult = NonNullable<Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>>
    export type LoginApiV1AuthLoginPostMutationBody = BodyLoginApiV1AuthLoginPost
    export type LoginApiV1AuthLoginPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Login
 */
export const useLoginApiV1AuthLoginPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>, TError,{data: BodyLoginApiV1AuthLoginPost}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>,
        TError,
        {data: BodyLoginApiV1AuthLoginPost},
        TContext
      > => {

      const mutationOptions = getLoginApiV1AuthLoginPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Login with email and password, optionally converting guest searches.

This endpoint supports guest session conversion.

Args:
    login_data: Login credentials with optional guest_session_id
    auth_service: Authentication service
    db: Database session

Returns:
    LoginResponse: Access token metadata for the client

Raises:
    HTTPException: If credentials are invalid or rate limit exceeded
 * @summary Login With Session
 */
export const loginWithSessionApiV1AuthLoginWithSessionPost = (
    userLogin: UserLogin,
 signal?: AbortSignal
) => {


      return customFetch<LoginResponse>(
      {url: `/api/v1/auth/login-with-session`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userLogin, signal
    },
      );
    }



export const getLoginWithSessionApiV1AuthLoginWithSessionPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginWithSessionApiV1AuthLoginWithSessionPost>>, TError,{data: UserLogin}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof loginWithSessionApiV1AuthLoginWithSessionPost>>, TError,{data: UserLogin}, TContext> => {

const mutationKey = ['loginWithSessionApiV1AuthLoginWithSessionPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginWithSessionApiV1AuthLoginWithSessionPost>>, {data: UserLogin}> = (props) => {
          const {data} = props ?? {};

          return  loginWithSessionApiV1AuthLoginWithSessionPost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type LoginWithSessionApiV1AuthLoginWithSessionPostMutationResult = NonNullable<Awaited<ReturnType<typeof loginWithSessionApiV1AuthLoginWithSessionPost>>>
    export type LoginWithSessionApiV1AuthLoginWithSessionPostMutationBody = UserLogin
    export type LoginWithSessionApiV1AuthLoginWithSessionPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Login With Session
 */
export const useLoginWithSessionApiV1AuthLoginWithSessionPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginWithSessionApiV1AuthLoginWithSessionPost>>, TError,{data: UserLogin}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof loginWithSessionApiV1AuthLoginWithSessionPost>>,
        TError,
        {data: UserLogin},
        TContext
      > => {

      const mutationOptions = getLoginWithSessionApiV1AuthLoginWithSessionPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get current user information with roles and permissions.

No additional rate limiting as this requires authentication.

Args:
    current_user: Current user email from JWT
    auth_service: Authentication service
    db: Database session

Returns:
    AuthUserWithPermissionsResponse: Current user data with roles and permissions

Raises:
    HTTPException: If user not found
 * @summary Read Users Me
 */
export const readUsersMeApiV1AuthMeGet = (

 signal?: AbortSignal
) => {


      return customFetch<AuthUserWithPermissionsResponse>(
      {url: `/api/v1/auth/me`, method: 'GET', signal
    },
      );
    }




export const getReadUsersMeApiV1AuthMeGetQueryKey = () => {
    return [
    `/api/v1/auth/me`
    ] as const;
    }


export const getReadUsersMeApiV1AuthMeGetQueryOptions = <TData = Awaited<ReturnType<typeof readUsersMeApiV1AuthMeGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUsersMeApiV1AuthMeGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadUsersMeApiV1AuthMeGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof readUsersMeApiV1AuthMeGet>>> = ({ signal }) => readUsersMeApiV1AuthMeGet(signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readUsersMeApiV1AuthMeGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadUsersMeApiV1AuthMeGetQueryResult = NonNullable<Awaited<ReturnType<typeof readUsersMeApiV1AuthMeGet>>>
export type ReadUsersMeApiV1AuthMeGetQueryError = ErrorType<unknown>


export function useReadUsersMeApiV1AuthMeGet<TData = Awaited<ReturnType<typeof readUsersMeApiV1AuthMeGet>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUsersMeApiV1AuthMeGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readUsersMeApiV1AuthMeGet>>,
          TError,
          Awaited<ReturnType<typeof readUsersMeApiV1AuthMeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadUsersMeApiV1AuthMeGet<TData = Awaited<ReturnType<typeof readUsersMeApiV1AuthMeGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUsersMeApiV1AuthMeGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readUsersMeApiV1AuthMeGet>>,
          TError,
          Awaited<ReturnType<typeof readUsersMeApiV1AuthMeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadUsersMeApiV1AuthMeGet<TData = Awaited<ReturnType<typeof readUsersMeApiV1AuthMeGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUsersMeApiV1AuthMeGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Users Me
 */

export function useReadUsersMeApiV1AuthMeGet<TData = Awaited<ReturnType<typeof readUsersMeApiV1AuthMeGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUsersMeApiV1AuthMeGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadUsersMeApiV1AuthMeGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update current user's profile (including timezone).

Args:
    user_update: Fields to update
    current_user: Current user email from JWT
    auth_service: Authentication service
    db: Database session

Returns:
    AuthUserWithPermissionsResponse: Updated user data

Raises:
    HTTPException: If user not found or update fails
 * @summary Update Current User
 */
export const updateCurrentUserApiV1AuthMePatch = (
    userUpdate: UserUpdate,
 ) => {


      return customFetch<AuthUserWithPermissionsResponse>(
      {url: `/api/v1/auth/me`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: userUpdate
    },
      );
    }



export const getUpdateCurrentUserApiV1AuthMePatchMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCurrentUserApiV1AuthMePatch>>, TError,{data: UserUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCurrentUserApiV1AuthMePatch>>, TError,{data: UserUpdate}, TContext> => {

const mutationKey = ['updateCurrentUserApiV1AuthMePatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCurrentUserApiV1AuthMePatch>>, {data: UserUpdate}> = (props) => {
          const {data} = props ?? {};

          return  updateCurrentUserApiV1AuthMePatch(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type UpdateCurrentUserApiV1AuthMePatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateCurrentUserApiV1AuthMePatch>>>
    export type UpdateCurrentUserApiV1AuthMePatchMutationBody = UserUpdate
    export type UpdateCurrentUserApiV1AuthMePatchMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Update Current User
 */
export const useUpdateCurrentUserApiV1AuthMePatch = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCurrentUserApiV1AuthMePatch>>, TError,{data: UserUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCurrentUserApiV1AuthMePatch>>,
        TError,
        {data: UserUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateCurrentUserApiV1AuthMePatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Register a new user.

Rate limited to prevent spam registrations.

Args:
    payload: User creation data (including optional guest_session_id)
    auth_service: Authentication service
    db: Database session

Returns:
    AuthUserResponse: The created user

Raises:
    HTTPException: If email already registered or rate limit exceeded
 * @summary Register
 */
export const registerApiV1AuthRegisterPost = (
    userCreate: UserCreate,
 signal?: AbortSignal
) => {


      return customFetch<AuthUserResponse>(
      {url: `/api/v1/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreate, signal
    },
      );
    }



export const getRegisterApiV1AuthRegisterPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>, TError,{data: UserCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>, TError,{data: UserCreate}, TContext> => {

const mutationKey = ['registerApiV1AuthRegisterPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>, {data: UserCreate}> = (props) => {
          const {data} = props ?? {};

          return  registerApiV1AuthRegisterPost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type RegisterApiV1AuthRegisterPostMutationResult = NonNullable<Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>>
    export type RegisterApiV1AuthRegisterPostMutationBody = UserCreate
    export type RegisterApiV1AuthRegisterPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Register
 */
export const useRegisterApiV1AuthRegisterPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>, TError,{data: UserCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>,
        TError,
        {data: UserCreate},
        TContext
      > => {

      const mutationOptions = getRegisterApiV1AuthRegisterPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
