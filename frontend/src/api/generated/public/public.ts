/**
 * Generated by orval v8.4.2 üç∫
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  GetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGetParams,
  GetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGetParams,
  GuestSessionResponse,
  HTTPValidationError,
  NextAvailableSlotResponse,
  PublicInstructorAvailability,
  ReferralSendRequest,
  ReferralSendResponse,
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Public endpoint to view instructor's available time slots for booking. No authentication required. Response detail level depends on configuration.
 * @summary Get instructor availability for students
 */
export const getGetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGetUrl =
  (
    instructorId: string,
    params: GetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGetParams
  ) => {
    const normalizedParams = new URLSearchParams();

    Object.entries(params || {}).forEach(([key, value]) => {
      if (value !== undefined) {
        normalizedParams.append(key, value === null ? 'null' : value.toString());
      }
    });

    const stringifiedParams = normalizedParams.toString();

    return stringifiedParams.length > 0
      ? `/api/v1/public/instructors/${instructorId}/availability?${stringifiedParams}`
      : `/api/v1/public/instructors/${instructorId}/availability`;
  };

export const getInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet =
  async (
    instructorId: string,
    params: GetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGetParams,
    options?: RequestInit
  ): Promise<PublicInstructorAvailability> => {
    return customFetch<PublicInstructorAvailability>(
      getGetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGetUrl(
        instructorId,
        params
      ),
      {
        ...options,
        method: 'GET',
      }
    );
  };

export const getGetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGetQueryKey =
  (
    instructorId: string,
    params?: GetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGetParams
  ) => {
    return [
      `/api/v1/public/instructors/${instructorId}/availability`,
      ...(params ? [params] : []),
    ] as const;
  };

export const getGetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<
        typeof getInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet
      >
    >,
    TError = ErrorType<HTTPValidationError>,
  >(
    instructorId: string,
    params: GetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGetParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet
            >
          >,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customFetch>;
    }
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getGetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGetQueryKey(
        instructorId,
        params
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<
          typeof getInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet
        >
      >
    > = ({ signal }) =>
      getInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet(
        instructorId,
        params,
        { signal, ...requestOptions }
      );

    return { queryKey, queryFn, enabled: !!instructorId, ...queryOptions } as UseQueryOptions<
      Awaited<
        ReturnType<
          typeof getInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet
        >
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type GetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<
        typeof getInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet
      >
    >
  >;
export type GetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGetQueryError =
  ErrorType<HTTPValidationError>;

export function useGetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet<
  TData = Awaited<
    ReturnType<
      typeof getInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet
    >
  >,
  TError = ErrorType<HTTPValidationError>,
>(
  instructorId: string,
  params: GetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet
            >
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet<
  TData = Awaited<
    ReturnType<
      typeof getInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet
    >
  >,
  TError = ErrorType<HTTPValidationError>,
>(
  instructorId: string,
  params: GetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet
          >
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet
            >
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet<
  TData = Awaited<
    ReturnType<
      typeof getInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet
    >
  >,
  TError = ErrorType<HTTPValidationError>,
>(
  instructorId: string,
  params: GetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet
          >
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get instructor availability for students
 */

export function useGetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet<
  TData = Awaited<
    ReturnType<
      typeof getInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet
    >
  >,
  TError = ErrorType<HTTPValidationError>,
>(
  instructorId: string,
  params: GetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<
            typeof getInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGet
          >
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions =
    getGetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGetQueryOptions(
      instructorId,
      params,
      options
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Quick endpoint to find the next available booking slot
 * @summary Get next available slot for an instructor
 */
export const getGetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGetUrl = (
  instructorId: string,
  params?: GetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/public/instructors/${instructorId}/next-available?${stringifiedParams}`
    : `/api/v1/public/instructors/${instructorId}/next-available`;
};

export const getNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet = async (
  instructorId: string,
  params?: GetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGetParams,
  options?: RequestInit
): Promise<NextAvailableSlotResponse> => {
  return customFetch<NextAvailableSlotResponse>(
    getGetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGetUrl(
      instructorId,
      params
    ),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGetQueryKey = (
  instructorId: string,
  params?: GetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGetParams
) => {
  return [
    `/api/v1/public/instructors/${instructorId}/next-available`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof getNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet>
    >,
    TError = ErrorType<HTTPValidationError>,
  >(
    instructorId: string,
    params?: GetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGetParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet
            >
          >,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customFetch>;
    }
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getGetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGetQueryKey(
        instructorId,
        params
      );

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<typeof getNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet>
      >
    > = ({ signal }) =>
      getNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet(instructorId, params, {
        signal,
        ...requestOptions,
      });

    return { queryKey, queryFn, enabled: !!instructorId, ...queryOptions } as UseQueryOptions<
      Awaited<
        ReturnType<typeof getNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet>
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type GetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof getNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet>
    >
  >;
export type GetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGetQueryError =
  ErrorType<HTTPValidationError>;

export function useGetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet<
  TData = Awaited<
    ReturnType<typeof getNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet>
  >,
  TError = ErrorType<HTTPValidationError>,
>(
  instructorId: string,
  params: undefined | GetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet
            >
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet<
  TData = Awaited<
    ReturnType<typeof getNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet>
  >,
  TError = ErrorType<HTTPValidationError>,
>(
  instructorId: string,
  params?: GetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet
            >
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet<
  TData = Awaited<
    ReturnType<typeof getNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet>
  >,
  TError = ErrorType<HTTPValidationError>,
>(
  instructorId: string,
  params?: GetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get next available slot for an instructor
 */

export function useGetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet<
  TData = Awaited<
    ReturnType<typeof getNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet>
  >,
  TError = ErrorType<HTTPValidationError>,
>(
  instructorId: string,
  params?: GetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGet>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions =
    getGetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGetQueryOptions(
      instructorId,
      params,
      options
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Clear known session cookies. Public to support cross-origin preview logout.

This does not revoke server sessions; it only instructs the browser to drop cookies.
 * @summary Public Logout
 */
export const getPublicLogoutApiV1PublicLogoutPostUrl = () => {
  return `/api/v1/public/logout`;
};

export const publicLogoutApiV1PublicLogoutPost = async (options?: RequestInit): Promise<void> => {
  return customFetch<void>(getPublicLogoutApiV1PublicLogoutPostUrl(), {
    ...options,
    method: 'POST',
  });
};

export const getPublicLogoutApiV1PublicLogoutPostMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof publicLogoutApiV1PublicLogoutPost>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof publicLogoutApiV1PublicLogoutPost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['publicLogoutApiV1PublicLogoutPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof publicLogoutApiV1PublicLogoutPost>>,
    void
  > = () => {
    return publicLogoutApiV1PublicLogoutPost(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PublicLogoutApiV1PublicLogoutPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof publicLogoutApiV1PublicLogoutPost>>
>;

export type PublicLogoutApiV1PublicLogoutPostMutationError = ErrorType<unknown>;

/**
 * @summary Public Logout
 */
export const usePublicLogoutApiV1PublicLogoutPost = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof publicLogoutApiV1PublicLogoutPost>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof publicLogoutApiV1PublicLogoutPost>>,
  TError,
  void,
  TContext
> => {
  return useMutation(getPublicLogoutApiV1PublicLogoutPostMutationOptions(options), queryClient);
};
/**
 * Send referral invitation emails to one or more recipients.
 * @summary Send referral invites
 */
export const getSendReferralInvitesApiV1PublicReferralsSendPostUrl = () => {
  return `/api/v1/public/referrals/send`;
};

export const sendReferralInvitesApiV1PublicReferralsSendPost = async (
  referralSendRequest: ReferralSendRequest,
  options?: RequestInit
): Promise<ReferralSendResponse> => {
  return customFetch<ReferralSendResponse>(
    getSendReferralInvitesApiV1PublicReferralsSendPostUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(referralSendRequest),
    }
  );
};

export const getSendReferralInvitesApiV1PublicReferralsSendPostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendReferralInvitesApiV1PublicReferralsSendPost>>,
    TError,
    { data: ReferralSendRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendReferralInvitesApiV1PublicReferralsSendPost>>,
  TError,
  { data: ReferralSendRequest },
  TContext
> => {
  const mutationKey = ['sendReferralInvitesApiV1PublicReferralsSendPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendReferralInvitesApiV1PublicReferralsSendPost>>,
    { data: ReferralSendRequest }
  > = (props) => {
    const { data } = props ?? {};

    return sendReferralInvitesApiV1PublicReferralsSendPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SendReferralInvitesApiV1PublicReferralsSendPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof sendReferralInvitesApiV1PublicReferralsSendPost>>
>;
export type SendReferralInvitesApiV1PublicReferralsSendPostMutationBody = ReferralSendRequest;
export type SendReferralInvitesApiV1PublicReferralsSendPostMutationError =
  ErrorType<HTTPValidationError>;

/**
 * @summary Send referral invites
 */
export const useSendReferralInvitesApiV1PublicReferralsSendPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sendReferralInvitesApiV1PublicReferralsSendPost>>,
      TError,
      { data: ReferralSendRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof sendReferralInvitesApiV1PublicReferralsSendPost>>,
  TError,
  { data: ReferralSendRequest },
  TContext
> => {
  return useMutation(
    getSendReferralInvitesApiV1PublicReferralsSendPostMutationOptions(options),
    queryClient
  );
};
/**
 * Issue a first-party guest_id cookie used for optional auth endpoints.

Sets cookie attributes appropriate for cross-site subdomains in preview/prod.
 * @summary Create Guest Session
 */
export const getCreateGuestSessionApiV1PublicSessionGuestPostUrl = () => {
  return `/api/v1/public/session/guest`;
};

export const createGuestSessionApiV1PublicSessionGuestPost = async (
  options?: RequestInit
): Promise<GuestSessionResponse> => {
  return customFetch<GuestSessionResponse>(getCreateGuestSessionApiV1PublicSessionGuestPostUrl(), {
    ...options,
    method: 'POST',
  });
};

export const getCreateGuestSessionApiV1PublicSessionGuestPostMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createGuestSessionApiV1PublicSessionGuestPost>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createGuestSessionApiV1PublicSessionGuestPost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['createGuestSessionApiV1PublicSessionGuestPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createGuestSessionApiV1PublicSessionGuestPost>>,
    void
  > = () => {
    return createGuestSessionApiV1PublicSessionGuestPost(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateGuestSessionApiV1PublicSessionGuestPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createGuestSessionApiV1PublicSessionGuestPost>>
>;

export type CreateGuestSessionApiV1PublicSessionGuestPostMutationError = ErrorType<unknown>;

/**
 * @summary Create Guest Session
 */
export const useCreateGuestSessionApiV1PublicSessionGuestPost = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createGuestSessionApiV1PublicSessionGuestPost>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createGuestSessionApiV1PublicSessionGuestPost>>,
  TError,
  void,
  TContext
> => {
  return useMutation(
    getCreateGuestSessionApiV1PublicSessionGuestPostMutationOptions(options),
    queryClient
  );
};
