/**
 * Generated by orval v8.2.0 ðŸº
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
export interface AccessGrantResponse {
  access_id: string;
  invited_by_code?: string | null;
  phase: string;
  role: string;
  user_id: string;
}

export interface AccountStatusChangeResponse {
  message: string;
  new_status: string;
  previous_status: string;
  success: boolean;
}

export interface AccountStatusResponse {
  account_status: string;
  can_deactivate?: boolean | null;
  can_login: boolean;
  can_reactivate?: boolean | null;
  can_receive_bookings: boolean;
  can_suspend?: boolean | null;
  future_bookings_count?: number | null;
  has_future_bookings?: boolean | null;
  is_active: boolean;
  is_deactivated: boolean;
  is_suspended: boolean;
  role: string;
  user_id: string;
}

export interface AddressCreate {
  administrative_area: string;
  country_code?: string;
  custom_label?: string | null;
  is_default?: boolean;
  /** home|work|other */
  label?: string | null;
  latitude?: number | null;
  locality: string;
  longitude?: number | null;
  place_id?: string | null;
  postal_code: string;
  recipient_name?: string | null;
  street_line1: string;
  street_line2?: string | null;
  verification_status?: string | null;
}

export type AddressResponseLocationMetadata = { [key: string]: unknown } | null;

export interface AddressResponse {
  administrative_area: string;
  country_code?: string;
  custom_label?: string | null;
  district?: string | null;
  id: string;
  is_active: boolean;
  is_default?: boolean;
  /** home|work|other */
  label?: string | null;
  latitude?: number | null;
  locality: string;
  location_metadata?: AddressResponseLocationMetadata;
  longitude?: number | null;
  neighborhood?: string | null;
  place_id?: string | null;
  postal_code: string;
  recipient_name?: string | null;
  street_line1: string;
  street_line2?: string | null;
  subneighborhood?: string | null;
  verification_status?: string | null;
}

export interface AddressListResponse {
  items: AddressResponse[];
  total: number;
}

export interface AddressUpdate {
  administrative_area?: string | null;
  country_code?: string | null;
  custom_label?: string | null;
  is_default?: boolean | null;
  label?: string | null;
  latitude?: number | null;
  locality?: string | null;
  longitude?: number | null;
  place_id?: string | null;
  postal_code?: string | null;
  recipient_name?: string | null;
  street_line1?: string | null;
  street_line2?: string | null;
  verification_status?: string | null;
}

export interface AdminAuditActor {
  email: string;
  id: string;
}

export type AdminAuditEntryDetails = { [key: string]: unknown } | null;

export interface AdminAuditEntry {
  action: string;
  admin: AdminAuditActor;
  details?: AdminAuditEntryDetails;
  id: string;
  resource_id: string;
  resource_type: string;
  timestamp: string;
}

export interface AdminAuditLogSummary {
  captures_count: number;
  captures_total: number;
  refunds_count: number;
  refunds_total: number;
}

export interface AdminAuditLogResponse {
  entries: AdminAuditEntry[];
  page: number;
  per_page: number;
  summary: AdminAuditLogSummary;
  total: number;
  total_pages: number;
}

export interface AdminAwardBadgeSchema {
  criteria_type?: string | null;
  name: string;
  slug: string;
}

export interface BadgeProgressView {
  current?: number | null;
  goal?: number | null;
  percent?: number | null;
  [key: string]: unknown;
}

export interface AdminAwardStudentSchema {
  display_name?: string | null;
  email?: string | null;
  id: string;
}

export interface AdminAwardSchema {
  award_id: string;
  awarded_at: string;
  badge: AdminAwardBadgeSchema;
  confirmed_at?: string | null;
  hold_until?: string | null;
  progress_snapshot?: BadgeProgressView | null;
  revoked_at?: string | null;
  status: string;
  student: AdminAwardStudentSchema;
}

export interface AdminAwardListResponse {
  items: AdminAwardSchema[];
  next_offset?: number | null;
  total: number;
}

export interface AdminBookingPerson {
  email: string;
  id: string;
  name: string;
  phone?: string | null;
}

export interface AdminBookingPaymentInfo {
  credits_applied: number;
  instructor_payout: number;
  lesson_price: number;
  payment_intent_id?: string | null;
  payment_status?: string | null;
  platform_fee: number;
  platform_revenue: number;
  stripe_url?: string | null;
  total_price: number;
}

export interface AdminBookingServiceInfo {
  duration_minutes: number;
  hourly_rate: number;
  id?: string | null;
  name: string;
}

export interface AdminBookingTimelineEvent {
  amount?: number | null;
  event: string;
  timestamp: string;
}

export interface AdminBookingDetailResponse {
  booking_date: string;
  booking_end_utc?: string | null;
  booking_start_utc?: string | null;
  created_at?: string | null;
  end_time: string;
  id: string;
  instructor: AdminBookingPerson;
  instructor_note?: string | null;
  instructor_timezone?: string | null;
  lesson_timezone?: string | null;
  location_type?: 'student_location' | 'instructor_location' | 'online' | 'neutral_location' | null;
  meeting_location?: string | null;
  payment: AdminBookingPaymentInfo;
  service: AdminBookingServiceInfo;
  start_time: string;
  status: string;
  student: AdminBookingPerson;
  student_note?: string | null;
  student_timezone?: string | null;
  timeline: AdminBookingTimelineEvent[];
  updated_at?: string | null;
}

export interface AdminBookingListItem {
  booking_date: string;
  booking_end_utc?: string | null;
  booking_start_utc?: string | null;
  created_at?: string | null;
  end_time: string;
  id: string;
  instructor: AdminBookingPerson;
  instructor_timezone?: string | null;
  lesson_timezone?: string | null;
  payment_intent_id?: string | null;
  payment_status?: string | null;
  service_name: string;
  start_time: string;
  status: string;
  student: AdminBookingPerson;
  student_timezone?: string | null;
  total_price: number;
}

export interface AdminBookingListResponse {
  bookings: AdminBookingListItem[];
  page: number;
  per_page: number;
  total: number;
  total_pages: number;
}

export interface AdminBookingStatsNeedsAction {
  disputed: number;
  pending_completion: number;
}

export interface AdminBookingStatsWeek {
  gmv: number;
  platform_revenue: number;
}

export interface AdminBookingStatsToday {
  booking_count: number;
  revenue: number;
}

export interface AdminBookingStatsResponse {
  needs_action: AdminBookingStatsNeedsAction;
  this_week: AdminBookingStatsWeek;
  today: AdminBookingStatsToday;
}

export type AdminBookingStatusUpdate =
  (typeof AdminBookingStatusUpdate)[keyof typeof AdminBookingStatusUpdate];

export const AdminBookingStatusUpdate = {
  COMPLETED: 'COMPLETED',
  NO_SHOW: 'NO_SHOW',
} as const;

export interface AdminBookingStatusUpdateRequest {
  note?: string | null;
  status: AdminBookingStatusUpdate;
}

export interface AdminBookingStatusUpdateResponse {
  booking_id: string;
  booking_status: string;
  success: boolean;
}

export type AdminBookingSummaryByStatus = { [key: string]: number };

/**
 * A category with booking count.
 */
export interface TopCategory {
  category: string;
  count: number;
}

/**
 * Summary statistics for bookings in a time period.
 */
export interface AdminBookingSummary {
  avg_booking_value_cents: number;
  by_status: AdminBookingSummaryByStatus;
  new_students: number;
  period: string;
  repeat_students: number;
  top_categories: TopCategory[];
  total_bookings: number;
  total_revenue_cents: number;
}

export interface AdminCancelBookingRequest {
  note?: string | null;
  /** @maxLength 100 */
  reason: string;
  refund?: boolean;
}

export interface AdminCancelBookingResponse {
  booking_id: string;
  booking_status: string;
  refund_id?: string | null;
  refund_issued: boolean;
  success: boolean;
}

/**
 * Detailed instructor metadata for administrative tooling.
 */
export interface AdminInstructorDetailResponse {
  bgc_completed_at?: string | null;
  bgc_dispute_note?: string | null;
  bgc_dispute_opened_at?: string | null;
  bgc_dispute_resolved_at?: string | null;
  bgc_expires_in_days?: number | null;
  bgc_in_dispute?: boolean;
  bgc_includes_canceled?: boolean;
  bgc_is_expired?: boolean;
  bgc_report_id?: string | null;
  bgc_status?: string | null;
  bgc_valid_until?: string | null;
  consent_recent_at?: string | null;
  created_at?: string | null;
  email: string;
  id: string;
  is_live: boolean;
  name: string;
  updated_at?: string | null;
}

export type AdminLocationLearningAliasActionResponseStatus =
  (typeof AdminLocationLearningAliasActionResponseStatus)[keyof typeof AdminLocationLearningAliasActionResponseStatus];

export const AdminLocationLearningAliasActionResponseStatus = {
  approved: 'approved',
  rejected: 'rejected',
} as const;

export interface AdminLocationLearningAliasActionResponse {
  alias_id: string;
  status: AdminLocationLearningAliasActionResponseStatus;
}

export interface AdminLocationLearningClickCount {
  count: number;
  region_boundary_id: string;
  region_name?: string | null;
}

/**
 * Create a manual location alias mapping.
 */
export interface AdminLocationLearningCreateAliasRequest {
  /**
   * Alias text to map
   * @minLength 1
   * @maxLength 255
   */
  alias: string;
  /** Classification for this alias (abbreviation|colloquial|landmark|typo) */
  alias_type?: string | null;
  /** If provided (len>=2), create an ambiguous alias requiring clarification */
  candidate_region_ids?: string[] | null;
  /** RegionBoundary id to map to (single-resolution alias) */
  region_boundary_id?: string | null;
}

export interface AdminLocationLearningCreateAliasResponse {
  alias_id: string;
  status: 'created';
}

export interface AdminLocationLearningDismissQueryResponse {
  query_normalized: string;
  status: 'dismissed';
}

export interface AdminLocationLearningLearnedAliasItem {
  alias_normalized: string;
  confidence: number;
  confirmations: number;
  region_boundary_id: string;
  status: string;
}

export interface AdminLocationLearningPendingAliasItem {
  alias_normalized: string;
  confidence: number;
  created_at: string;
  id: string;
  region_boundary_id?: string | null;
  region_name?: string | null;
  status: string;
  user_count: number;
}

export interface AdminLocationLearningPendingAliasesResponse {
  aliases: AdminLocationLearningPendingAliasItem[];
}

export interface AdminLocationLearningProcessResponse {
  learned: AdminLocationLearningLearnedAliasItem[];
  learned_count: number;
}

export interface AdminLocationLearningRegionItem {
  borough?: string | null;
  id: string;
  name: string;
}

export interface AdminLocationLearningRegionsResponse {
  regions: AdminLocationLearningRegionItem[];
}

export interface AdminLocationLearningUnresolvedQueryItem {
  click_count: number;
  clicks: AdminLocationLearningClickCount[];
  first_seen_at: string;
  id: string;
  last_seen_at: string;
  query_normalized: string;
  sample_original_queries: string[];
  search_count: number;
  status: string;
  unique_user_count: number;
}

export interface AdminLocationLearningUnresolvedQueriesResponse {
  queries: AdminLocationLearningUnresolvedQueryItem[];
  total: number;
}

export type AdminNoShowResolution =
  (typeof AdminNoShowResolution)[keyof typeof AdminNoShowResolution];

export const AdminNoShowResolution = {
  confirmed_after_review: 'confirmed_after_review',
  dispute_upheld: 'dispute_upheld',
  cancelled: 'cancelled',
} as const;

export interface AdminNoShowResolutionRequest {
  admin_notes?: string | null;
  resolution: AdminNoShowResolution;
}

export interface AdminNoShowResolutionResponse {
  booking_id: string;
  resolution: string;
  settlement_outcome?: string | null;
  success: boolean;
}

export type AdminReferralsConfigOutFlags = { [key: string]: boolean };

export type AdminReferralsConfigOutSource =
  (typeof AdminReferralsConfigOutSource)[keyof typeof AdminReferralsConfigOutSource];

export const AdminReferralsConfigOutSource = {
  db: 'db',
  defaults: 'defaults',
} as const;

/**
 * Configuration snapshot for the referral program.
 */
export interface AdminReferralsConfigOut {
  expiry_months: number;
  flags: AdminReferralsConfigOutFlags;
  global_cap: number;
  hold_days: number;
  instructor_amount_cents: number;
  min_basket_cents: number;
  source: AdminReferralsConfigOutSource;
  student_amount_cents: number;
  version: number | null;
}

/**
 * Unlocker worker and data health for admin dashboards.
 */
export interface AdminReferralsHealthOut {
  backlog_pending_due: number;
  last_run_age_s?: number | null;
  pending_total: number;
  unlocked_total: number;
  void_total: number;
  workers: string[];
  workers_alive: number;
}

export type AdminReferralsSummaryOutCountsByStatus = { [key: string]: number };

/**
 * Top referrer metadata for admin dashboards.
 */
export interface TopReferrerOut {
  code?: string | null;
  count: number;
  user_id: string;
}

/**
 * Aggregate referral summary metrics for admins.
 */
export interface AdminReferralsSummaryOut {
  attributions_24h: number;
  cap_utilization_percent: number;
  clicks_24h: number;
  counts_by_status: AdminReferralsSummaryOutCountsByStatus;
  top_referrers: TopReferrerOut[];
}

export type AdminRefundReason = (typeof AdminRefundReason)[keyof typeof AdminRefundReason];

export const AdminRefundReason = {
  instructor_no_show: 'instructor_no_show',
  dispute: 'dispute',
  platform_error: 'platform_error',
  other: 'other',
} as const;

export interface AdminRefundRequest {
  /** Refund amount in cents. Full refund if not provided. */
  amount_cents?: number | null;
  /** Admin note explaining the refund */
  note?: string | null;
  /** Reason for refund */
  reason: AdminRefundReason;
}

export interface AdminRefundResponse {
  amount_refunded_cents: number;
  booking_id: string;
  booking_status: string;
  message: string;
  refund_id: string;
  success: boolean;
}

/**
 * A selectable model option.
 */
export interface ModelOption {
  /** Model description */
  description: string;
  /** Model identifier */
  id: string;
  /** Display name */
  name: string;
}

/**
 * Admin search configuration with runtime controls.
 */
export interface AdminSearchConfigResponse {
  /** Available embedding models */
  available_embedding_models: ModelOption[];
  /** Available parsing models */
  available_parsing_models: ModelOption[];
  /**
   * Current in-flight uncached searches
   * @minimum 0
   */
  current_in_flight_requests: number;
  /** Current embedding model */
  embedding_model: string;
  /**
   * Embedding timeout in ms
   * @minimum 500
   * @maximum 10000
   */
  embedding_timeout_ms: number;
  /**
   * High load budget in ms
   * @minimum 50
   */
  high_load_budget_ms: number;
  /**
   * Concurrent requests to trigger high load
   * @minimum 1
   */
  high_load_threshold: number;
  /** Current location model */
  location_model: string;
  /**
   * Location LLM timeout in ms
   * @minimum 500
   * @maximum 10000
   */
  location_timeout_ms: number;
  /**
   * OpenAI max retries
   * @minimum 0
   */
  openai_max_retries: number;
  /** Current parsing model */
  parsing_model: string;
  /**
   * Parsing timeout in ms
   * @minimum 500
   * @maximum 10000
   */
  parsing_timeout_ms: number;
  /**
   * Default request budget in ms
   * @minimum 50
   */
  search_budget_ms: number;
  /**
   * Max concurrent uncached searches per worker
   * @minimum 1
   */
  uncached_concurrency: number;
}

/**
 * Admin update payload for search runtime settings.
 */
export interface AdminSearchConfigUpdate {
  /** New embedding timeout in ms */
  embedding_timeout_ms?: number | null;
  /** New high load budget in ms */
  high_load_budget_ms?: number | null;
  /** New high load threshold */
  high_load_threshold?: number | null;
  /** New location model */
  location_model?: string | null;
  /** New location LLM timeout in ms */
  location_timeout_ms?: number | null;
  /** New OpenAI max retries */
  openai_max_retries?: number | null;
  /** New parsing model */
  parsing_model?: string | null;
  /** New parsing timeout in ms */
  parsing_timeout_ms?: number | null;
  /** New request budget in ms */
  search_budget_ms?: number | null;
  /** New uncached concurrency limit */
  uncached_concurrency?: number | null;
}

/**
 * Alert acknowledgement response.
 */
export interface AlertAcknowledgeResponse {
  /** Alert type that was acknowledged */
  alert_type: string;
  /** Acknowledgement status */
  status: string;
}

/**
 * Details for extremely slow database queries.
 */
export interface ExtremelySlowQueryDetails {
  /** Alert type discriminator */
  alert_type?: 'extremely_slow_query';
  /** Query duration in milliseconds */
  duration_ms: number;
  /** Full query text (only for queries > 2000ms) */
  full_query?: string | null;
  /** First 200 chars of the query */
  query_preview: string;
}

/**
 * Details for extremely slow HTTP requests.
 */
export interface ExtremelySlowRequestDetails {
  /** Alert type discriminator */
  alert_type?: 'extremely_slow_request';
  /** Client IP address */
  client: string;
  /** Request duration in milliseconds */
  duration_ms: number;
  /** HTTP method (GET, POST, etc.) */
  method: string;
  /** Request path */
  path: string;
  /** HTTP response status code */
  status_code: number;
}

/**
 * Details for high database connection pool usage.
 */
export interface HighDbPoolUsageDetails {
  /** Alert type discriminator */
  alert_type?: 'high_db_pool_usage';
  /** Number of checked out connections */
  checked_out?: number | null;
  /** Total possible connections */
  total_possible?: number | null;
  /** Pool usage percentage */
  usage_percent?: number | null;
}

/**
 * Details for high memory usage alerts.
 */
export interface HighMemoryUsageDetails {
  /** Alert type discriminator */
  alert_type?: 'high_memory_usage';
  /** Memory usage in MB */
  memory_mb?: number | null;
  /** Memory usage percentage */
  percent?: number | null;
}

/**
 * Details for low cache hit rate alerts.
 */
export interface LowCacheHitRateDetails {
  /** Alert type discriminator */
  alert_type?: 'low_cache_hit_rate';
  /** Current cache hit rate */
  hit_rate?: number | null;
  /** Target cache hit rate */
  target?: number | null;
}

/**
 * Individual alert details.
 */
export interface AlertDetail {
  /** When the alert was created (ISO format) */
  created_at: string;
  /** Type-specific alert details */
  details?:
    | ExtremelySlowQueryDetails
    | ExtremelySlowRequestDetails
    | HighDbPoolUsageDetails
    | HighMemoryUsageDetails
    | LowCacheHitRateDetails
    | null;
  /** Whether email notification was sent */
  email_sent: boolean;
  /** Whether GitHub issue was created */
  github_issue: boolean;
  /** Alert ID */
  id: string;
  /** Alert message */
  message: string;
  /** Alert severity level */
  severity: string;
  /** Alert title */
  title: string;
  /** Type of alert */
  type: string;
}

/**
 * Alert information.
 */
export interface AlertInfo {
  /** Alert message */
  message: string;
  /** Alert severity (info/warning/critical) */
  severity: string;
  /** Alert timestamp */
  timestamp: string;
  /** Alert type */
  type: string;
}

/**
 * Alert counts grouped by severity
 */
export type AlertSummaryResponseBySeverity = { [key: string]: number };

/**
 * Alert counts grouped by type
 */
export type AlertSummaryResponseByType = { [key: string]: number };

/**
 * Daily alert count for summary.
 */
export interface DailyAlertCount {
  /** Number of alerts on this date */
  count: number;
  /** Date in YYYY-MM-DD format */
  date: string;
}

/**
 * Response for alert summary endpoint.
 */
export interface AlertSummaryResponse {
  /** Daily alert counts */
  by_day: DailyAlertCount[];
  /** Alert counts grouped by severity */
  by_severity: AlertSummaryResponseBySeverity;
  /** Alert counts grouped by type */
  by_type: AlertSummaryResponseByType;
  /** Number of days included in summary */
  days: number;
  /** Total number of alerts in the period */
  total: number;
}

/**
 * Metadata for full catalog-with-instructors payload.
 */
export interface AllServicesMetadata {
  cached_for_seconds: number;
  total_categories: number;
  total_services?: number | null;
  updated_at: string;
}

/**
 * Detailed catalog service information with instructor analytics.
 */
export interface CategoryServiceDetail {
  active_instructors?: number;
  actual_max_price?: number | null;
  actual_min_price?: number | null;
  category_id: string;
  demand_score?: number;
  description?: string | null;
  display_order?: number | null;
  id: string;
  instructor_count?: number;
  is_active?: boolean | null;
  is_trending?: boolean;
  name: string;
  online_capable?: boolean | null;
  requires_certification?: boolean | null;
  search_terms?: string[];
  slug: string;
}

/**
 * Category record containing detailed services.
 */
export interface CategoryWithServices {
  description?: string | null;
  icon_name?: string | null;
  id: string;
  name: string;
  services?: CategoryServiceDetail[];
  slug: string;
  subtitle?: string | null;
}

/**
 * Full catalog payload including instructor analytics.
 */
export interface AllServicesWithInstructorsResponse {
  categories?: CategoryWithServices[];
  metadata: AllServicesMetadata;
}

export interface AppendHistoryResponse {
  /** @minimum 0 */
  count: number;
  status: string;
}

/**
 * Schema for applying a week pattern to a date range.
 */
export interface ApplyToDateRangeRequest {
  end_date: string;
  from_week_start: string;
  start_date: string;
}

export interface ApplyToDateRangeResponse {
  dates_processed?: number;
  dates_with_slots?: number;
  dates_with_windows?: number;
  days_written: number;
  edited_dates?: string[];
  end_date: string;
  message: string;
  skipped_past_targets?: number;
  start_date: string;
  weeks_affected: number;
  weeks_applied: number;
  windows_created: number;
  written_dates?: string[];
}

export interface AuditActor {
  email?: string | null;
  id?: string | null;
  type: string;
}

export type AuditEntryChanges = { [key: string]: unknown } | null;

export interface AuditResource {
  id?: string | null;
  type: string;
}

export interface AuditEntry {
  action: string;
  actor: AuditActor;
  changes?: AuditEntryChanges;
  description?: string | null;
  id: string;
  request_id?: string | null;
  resource: AuditResource;
  status: string;
  timestamp: string;
}

export type AuditLogViewAfter = { [key: string]: unknown } | null;

export type AuditLogViewBefore = { [key: string]: unknown } | null;

/**
 * Single audit log entry.
 */
export interface AuditLogView {
  action: string;
  actor_id?: string | null;
  actor_role?: string | null;
  after?: AuditLogViewAfter;
  before?: AuditLogViewBefore;
  entity_id: string;
  entity_type: string;
  id: string;
  occurred_at: string;
}

/**
 * Paginated audit log response.
 */
export interface AuditLogListResponse {
  items: AuditLogView[];
  limit: number;
  offset: number;
  total: number;
}

export interface AuditSearchMeta {
  returned_count: number;
  since_hours: number;
  total_count: number;
}

export type AuditSearchSummaryByAction = { [key: string]: number };

export type AuditSearchSummaryByActorType = { [key: string]: number };

export type AuditSearchSummaryByStatus = { [key: string]: number };

export interface AuditSearchSummary {
  by_action: AuditSearchSummaryByAction;
  by_actor_type: AuditSearchSummaryByActorType;
  by_status: AuditSearchSummaryByStatus;
}

export interface AuditSearchResponse {
  entries: AuditEntry[];
  meta: AuditSearchMeta;
  summary: AuditSearchSummary;
}

/**
 * Minimal strict representation of a user for auth endpoints.
 */
export interface AuthUserResponse {
  email: string;
  first_name: string;
  /** True if founding instructor status was granted during registration */
  founding_instructor_granted?: boolean | null;
  has_profile_picture?: boolean | null;
  id: string;
  is_active?: boolean;
  last_name: string;
  permissions?: string[];
  phone?: string | null;
  phone_verified?: boolean | null;
  profile_picture_version?: number | null;
  roles?: string[];
  timezone?: string | null;
  zip_code?: string | null;
}

/**
 * Extends auth user response with optional beta metadata.
 */
export interface AuthUserWithPermissionsResponse {
  beta_access?: boolean | null;
  beta_invited_by?: string | null;
  beta_phase?: string | null;
  beta_role?: string | null;
  email: string;
  first_name: string;
  /** True if founding instructor status was granted during registration */
  founding_instructor_granted?: boolean | null;
  has_profile_picture?: boolean | null;
  id: string;
  is_active?: boolean;
  last_name: string;
  permissions?: string[];
  phone?: string | null;
  phone_verified?: boolean | null;
  profile_picture_version?: number | null;
  roles?: string[];
  timezone?: string | null;
  zip_code?: string | null;
}

export interface PlaceSuggestion {
  description: string;
  place_id: string;
  provider: string;
  text: string;
  types?: string[];
}

export interface AutocompleteResponse {
  items: PlaceSuggestion[];
  total: number;
}

/**
 * Detailed availability cache metrics.
 */
export interface AvailabilityCacheMetrics {
  /** Cache efficiency rating */
  cache_efficiency?: string;
  /** Cache hit rate percentage */
  hit_rate?: string;
  /** Cache hits */
  hits?: number;
  /** Cache invalidations */
  invalidations?: number;
  /** Cache misses */
  misses?: number;
  /** Total cache requests */
  total_requests?: number;
}

/**
 * Cache tier configuration
 */
export type AvailabilityCacheMetricsResponseCacheTiersInfo = { [key: string]: string };

/**
 * Availability-specific cache metrics response.
 */
export interface AvailabilityCacheMetricsResponse {
  /** Availability cache metrics */
  availability_cache_metrics: AvailabilityCacheMetrics;
  /** Cache tier configuration */
  cache_tiers_info: AvailabilityCacheMetricsResponseCacheTiersInfo;
  /** Performance recommendations */
  recommendations: string[];
  /** Sample of top cached keys */
  top_cached_keys_sample: string[];
}

/**
 * Check if a specific time is available for booking.

Clean Architecture: Uses instructor, date, and time directly.
No slot references needed.
 */
export interface AvailabilityCheckRequest {
  /** Date to check */
  booking_date: string;
  /** End time to check */
  end_time: string;
  /** Instructor to check */
  instructor_id: string;
  /** Service to book */
  instructor_service_id: string;
  /** Start time to check */
  start_time: string;
}

/**
 * Information about a conflicting booking.
 */
export interface ConflictingBookingInfo {
  /** ID of the conflicting booking */
  booking_id?: string | null;
  /** End time of conflict (HH:MM:SS) */
  end_time?: string | null;
  /** Start time of conflict (HH:MM:SS) */
  start_time?: string | null;
}

/**
 * Time slot information for availability checks.
 */
export interface TimeSlotInfo {
  /** ISO date string (YYYY-MM-DD) */
  date: string;
  /** ISO time string (HH:MM:SS) */
  end_time: string;
  /** Instructor ID */
  instructor_id: string;
  /** ISO time string (HH:MM:SS) */
  start_time: string;
}

/**
 * Response for availability check.
 */
export interface AvailabilityCheckResponse {
  available: boolean;
  /** List of conflicting bookings if any */
  conflicts_with?: ConflictingBookingInfo[] | null;
  min_advance_hours?: number | null;
  reason?: string | null;
  /** Time slot information for the availability check */
  time_info?: TimeSlotInfo | null;
}

/**
 * Information about a booking that conflicts with an availability operation.
 */
export interface AvailabilityConflictInfo {
  /** ID of conflicting booking */
  booking_id?: string | null;
  /** End time of conflict */
  end_time?: string | null;
  /** Start time of conflict */
  start_time?: string | null;
}

/**
 * Availability-specific cache metrics.
 */
export interface AvailabilityMetrics {
  /** Availability cache hit rate */
  availability_hit_rate?: string;
  /** Availability cache invalidations */
  availability_invalidations?: number;
  /** Total availability requests */
  availability_total_requests?: number;
}

/**
 * Response schema for availability windows.
Clean Architecture: Only meaningful fields for single-table design.
 */
export interface AvailabilityWindowResponse {
  end_time: string;
  id: string;
  instructor_id: string;
  specific_date: string;
  start_time: string;
}

/**
 * Schema for updating an availability window.
 */
export interface AvailabilityWindowUpdate {
  end_time?: string | null;
  start_time?: string | null;
}

export interface BGCCaseCountsResponse {
  pending: number;
  review: number;
}

export interface BGCCaseItemModel {
  bgc_completed_at?: string | null;
  bgc_eta?: string | null;
  bgc_expires_in_days?: number | null;
  bgc_includes_canceled?: boolean;
  bgc_is_expired?: boolean;
  bgc_report_id?: string | null;
  bgc_status?: string | null;
  bgc_valid_until?: string | null;
  checkr_report_url?: string | null;
  consent_recent: boolean;
  consent_recent_at?: string | null;
  created_at?: string | null;
  dispute_note?: string | null;
  dispute_opened_at?: string | null;
  dispute_resolved_at?: string | null;
  email: string;
  in_dispute?: boolean;
  instructor_id: string;
  is_live: boolean;
  name: string;
  updated_at?: string | null;
}

export interface BGCCaseListResponse {
  has_next: boolean;
  has_prev: boolean;
  items: BGCCaseItemModel[];
  page: number;
  page_size: number;
  total: number;
  total_pages: number;
}

export interface BGCDisputeResponse {
  dispute_note?: string | null;
  dispute_opened_at?: string | null;
  dispute_resolved_at?: string | null;
  in_dispute: boolean;
  ok: boolean;
  resumed?: boolean;
  scheduled_for?: string | null;
}

export interface BGCExpiringItem {
  bgc_valid_until?: string | null;
  email?: string | null;
  instructor_id: string;
}

export interface BGCHistoryItem {
  completed_at: string;
  created_at: string;
  env: string;
  id: string;
  package?: string | null;
  report_id_present: boolean;
  result: string;
}

export interface BGCHistoryResponse {
  items: BGCHistoryItem[];
  next_cursor?: string | null;
}

export interface BGCLatestConsentResponse {
  consent_version: string;
  consented_at: string;
  instructor_id: string;
  ip_address?: string | null;
}

export type BGCOverrideResponseNewStatus =
  (typeof BGCOverrideResponseNewStatus)[keyof typeof BGCOverrideResponseNewStatus];

export const BGCOverrideResponseNewStatus = {
  passed: 'passed',
  failed: 'failed',
} as const;

export interface BGCOverrideResponse {
  new_status: BGCOverrideResponseNewStatus;
  ok: boolean;
}

export interface BGCReviewCountResponse {
  count: number;
}

export interface BGCReviewItemModel {
  bgc_completed_at?: string | null;
  bgc_eta?: string | null;
  bgc_expires_in_days?: number | null;
  bgc_includes_canceled?: boolean;
  bgc_is_expired?: boolean;
  bgc_report_id?: string | null;
  bgc_status?: string | null;
  bgc_valid_until?: string | null;
  checkr_report_url?: string | null;
  consented_at_recent: boolean;
  consented_at_recent_at?: string | null;
  created_at?: string | null;
  dispute_note?: string | null;
  dispute_opened_at?: string | null;
  dispute_resolved_at?: string | null;
  email: string;
  in_dispute?: boolean;
  instructor_id: string;
  is_live: boolean;
  name: string;
  updated_at?: string | null;
}

export interface BGCReviewListResponse {
  items: BGCReviewItemModel[];
  next_cursor?: string | null;
}

export type BGCWebhookLogEntryPayload = { [key: string]: unknown };

export interface BGCWebhookLogEntry {
  candidate_id?: string | null;
  created_at: string;
  delivery_id?: string | null;
  event_type: string;
  http_status?: number | null;
  id: string;
  instructor_id?: string | null;
  invitation_id?: string | null;
  payload: BGCWebhookLogEntryPayload;
  report_id?: string | null;
  resource_id?: string | null;
  result?: string | null;
  signature?: string | null;
}

export interface BGCWebhookLogListResponse {
  error_count_24h: number;
  items: BGCWebhookLogEntry[];
  next_cursor?: string | null;
}

export interface BGCWebhookStatsResponse {
  error_count_24h: number;
}

/**
 * Payload accepted by the background check invite endpoint.
 */
export interface BackgroundCheckInviteRequest {
  /** Optional Checkr package slug override */
  package_slug?: string | null;
}

export type BackgroundCheckInviteResponseStatus =
  (typeof BackgroundCheckInviteResponseStatus)[keyof typeof BackgroundCheckInviteResponseStatus];

export const BackgroundCheckInviteResponseStatus = {
  pending: 'pending',
  review: 'review',
  consider: 'consider',
  passed: 'passed',
  failed: 'failed',
  canceled: 'canceled',
} as const;

/**
 * Response returned after invoking a background check invitation.
 */
export interface BackgroundCheckInviteResponse {
  already_in_progress?: boolean;
  candidate_id?: string | null;
  invitation_id?: string | null;
  ok?: boolean;
  report_id?: string | null;
  status: BackgroundCheckInviteResponseStatus;
}

export type BackgroundCheckStatusResponseEnv =
  (typeof BackgroundCheckStatusResponseEnv)[keyof typeof BackgroundCheckStatusResponseEnv];

export const BackgroundCheckStatusResponseEnv = {
  sandbox: 'sandbox',
  production: 'production',
} as const;

export type BackgroundCheckStatusResponseStatus =
  (typeof BackgroundCheckStatusResponseStatus)[keyof typeof BackgroundCheckStatusResponseStatus];

export const BackgroundCheckStatusResponseStatus = {
  pending: 'pending',
  review: 'review',
  consider: 'consider',
  passed: 'passed',
  failed: 'failed',
  canceled: 'canceled',
} as const;

/**
 * Current background check status for an instructor.
 */
export interface BackgroundCheckStatusResponse {
  bgc_includes_canceled?: boolean;
  completed_at?: string | null;
  consent_recent?: boolean;
  consent_recent_at?: string | null;
  env: BackgroundCheckStatusResponseEnv;
  eta?: string | null;
  expires_in_days?: number | null;
  is_expired?: boolean;
  report_id?: string | null;
  status: BackgroundCheckStatusResponseStatus;
  valid_until?: string | null;
}

export interface BackupCodesResponse {
  backup_codes: string[];
}

/**
 * Basic cache statistics.
 */
export interface BasicCacheStats {
  /** Cache errors */
  errors?: number;
  /** Cache hit rate percentage */
  hit_rate?: string;
  /** Cache hits */
  hits?: number;
  /** Cache misses */
  misses?: number;
}

export type BetaMetricsSummaryResponsePhaseCounts24h = { [key: string]: number };

export interface BetaMetricsSummaryResponse {
  invites_errors_24h: number;
  invites_sent_24h: number;
  phase_counts_24h: BetaMetricsSummaryResponsePhaseCounts24h;
}

/**
 * Response payload describing beta feature flags.
 */
export interface BetaSettingsResponse {
  allow_signup_without_invite: boolean;
  beta_disabled: boolean;
  beta_phase: string;
}

/**
 * Request payload for updating beta settings.
 */
export interface BetaSettingsUpdateRequest {
  allow_signup_without_invite: boolean;
  beta_disabled: boolean;
  beta_phase: string;
}

/**
 * Schema for creating a blackout date.
 */
export interface BlackoutDateCreate {
  date: string;
  reason?: string | null;
}

/**
 * Response schema for blackout dates.
 */
export interface BlackoutDateResponse {
  created_at: string;
  date: string;
  id: string;
  instructor_id: string;
  reason?: string | null;
}

/**
 * CAPTCHA requirement state.
 */
export interface CaptchaState {
  active: boolean;
}

/**
 * Lockout block state.
 */
export interface LockoutState {
  active: boolean;
  level?: string;
  ttl_seconds?: number;
}

/**
 * Rate limit block state.
 */
export interface RateLimitState {
  active: boolean;
  count?: number;
  limit: number;
  ttl_seconds?: number;
}

/**
 * All block states for an account.
 */
export interface BlocksState {
  captcha_required?: CaptchaState | null;
  lockout?: LockoutState | null;
  rate_limit_hour?: RateLimitState | null;
  rate_limit_minute?: RateLimitState | null;
}

/**
 * Blocked account information.
 */
export interface BlockedAccount {
  blocks: BlocksState;
  email: string;
  failure_count?: number;
}

export interface BodyDisputeCompletionApiV1InstructorBookingsBookingIdDisputePost {
  reason: string;
}

export interface BodyLoginApiV1AuthLoginPost {
  client_id?: string | null;
  client_secret?: string | null;
  grant_type?: string | null;
  password: string;
  scope?: string;
  username: string;
}

export interface BodyProxyUploadToR2ApiV1UploadsR2ProxyPost {
  /** Content type reported by the browser */
  content_type: string;
  file: Blob;
  /** Temporary object key from the signed upload response */
  key: string;
}

export interface BodyRespondToReviewApiV1ReviewsReviewIdRespondPost {
  response_text: string;
}

/**
 * Location type (student_location, instructor_location, online, neutral_location)
 */
export type BookedSlotItemLocationType =
  (typeof BookedSlotItemLocationType)[keyof typeof BookedSlotItemLocationType];

export const BookedSlotItemLocationType = {
  student_location: 'student_location',
  instructor_location: 'instructor_location',
  online: 'online',
  neutral_location: 'neutral_location',
} as const;

/**
 * Individual booked slot with booking details for calendar display.
 */
export interface BookedSlotItem {
  /** ULID of the booking */
  booking_id: string;
  /** ISO date string (YYYY-MM-DD) */
  date: string;
  /** Duration of the booking in minutes */
  duration_minutes: number;
  /** ISO time string (HH:MM:SS) */
  end_time: string;
  /** Location type (student_location, instructor_location, online, neutral_location) */
  location_type: BookedSlotItemLocationType;
  /** Abbreviated service area */
  service_area_short: string;
  /** Name of the service booked */
  service_name: string;
  /** ISO time string (HH:MM:SS) */
  start_time: string;
  /** Student's first name */
  student_first_name: string;
  /** Student's last name initial */
  student_last_initial: string;
}

export interface BookedSlotsResponse {
  /** List of booked slots with booking details */
  booked_slots: BookedSlotItem[];
  week_end: string;
  week_start: string;
}

export interface BookingCancel {
  /**
   * Cancellation reason
   * @minLength 1
   * @maxLength 500
   */
  reason: string;
}

export interface BookingConfirmPayment {
  /** Stripe payment method ID from completed SetupIntent */
  payment_method_id: string;
  /** Whether to save this payment method for future use */
  save_payment_method?: boolean;
}

/**
 * Create a booking with self-contained time information.

Clean Architecture: No slot references - bookings are independent.
The booking contains all necessary information about when and where
the lesson will occur.
 */
export interface BookingCreate {
  /** Date of the booking */
  booking_date: string;
  /** Calculated end time (set automatically) */
  end_time?: string | null;
  /** Instructor to book */
  instructor_id: string;
  /** Instructor service being booked */
  instructor_service_id: string;
  /** Structured location address for in-person lessons */
  location_address?: string | null;
  /** Latitude for the lesson location */
  location_lat?: number | null;
  /** Longitude for the lesson location */
  location_lng?: number | null;
  /** Place ID for the lesson location */
  location_place_id?: string | null;
  /** Type of meeting location */
  location_type?: 'student_location' | 'instructor_location' | 'online' | 'neutral_location' | null;
  /** Specific meeting location if applicable */
  meeting_location?: string | null;
  /**
   * Selected duration in minutes from service's duration_options
   * @minimum 15
   * @maximum 720
   */
  selected_duration: number;
  /** Start time */
  start_time: string;
  /** Optional note from student */
  student_note?: string | null;
  /** IANA timezone for booking times (defaults to instructor timezone) */
  timezone?: string | null;
}

/**
 * Instructor information for booking display.

Privacy-aware: Only shows last initial for privacy protection.
Full last name never exposed to students.
 */
export interface InstructorInfo {
  first_name: string;
  id: string;
  last_initial: string;
}

/**
 * Basic service information for booking display.
 */
export interface ServiceInfo {
  description: string | null;
  id: string;
  name: string;
}

/**
 * Student-facing payment breakdown for a booking.
 */
export interface PaymentSummary {
  credit_applied: number;
  lesson_amount: number;
  service_fee: number;
  subtotal: number;
  tip_amount: number;
  tip_last_updated?: string | null;
  tip_paid: number;
  tip_status?: string | null;
  total_paid: number;
}

/**
 * Minimal info about the original booking used for annotation.
 */
export interface RescheduledFromInfo {
  booking_date: string;
  id: string;
  start_time: string;
}

/**
 * Booking lifecycle statuses.

Case-insensitive: accepts 'completed', 'COMPLETED', or 'Completed'.
 */
export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus];

export const BookingStatus = {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  NO_SHOW: 'NO_SHOW',
} as const;

/**
 * Basic student information for booking display.
 */
export interface StudentInfo {
  email: string;
  first_name: string;
  id: string;
  last_name: string;
}

/**
 * Response after creating a booking with payment setup.

Includes SetupIntent client_secret for collecting payment method.
 */
export interface BookingCreateResponse {
  auth_attempted_at?: string | null;
  auth_failure_count?: number | null;
  auth_last_error?: string | null;
  auth_scheduled_for?: string | null;
  booking_date: string;
  booking_end_utc?: string | null;
  booking_start_utc?: string | null;
  cancellation_reason: string | null;
  cancelled_at: string | null;
  cancelled_by_id: string | null;
  completed_at: string | null;
  confirmed_at: string | null;
  created_at: string;
  credits_reserved_cents?: number | null;
  duration_minutes: number;
  end_time: string;
  has_locked_funds?: boolean | null;
  hourly_rate: number;
  id: string;
  instructor: InstructorInfo;
  instructor_id: string;
  instructor_note: string | null;
  instructor_payout_amount?: number | null;
  instructor_service: ServiceInfo;
  instructor_service_id: string;
  instructor_timezone?: string | null;
  lesson_timezone?: string | null;
  location_address?: string | null;
  location_lat?: number | null;
  location_lng?: number | null;
  location_place_id?: string | null;
  location_type: 'student_location' | 'instructor_location' | 'online' | 'neutral_location' | null;
  lock_resolution?: string | null;
  lock_resolved_at?: string | null;
  locked_amount_cents?: number | null;
  locked_at?: string | null;
  meeting_location: string | null;
  no_show_dispute_reason?: string | null;
  no_show_disputed?: boolean | null;
  no_show_disputed_at?: string | null;
  no_show_reported_at?: string | null;
  no_show_reported_by?: string | null;
  no_show_resolution?: string | null;
  no_show_resolved_at?: string | null;
  no_show_type?: string | null;
  payment_summary?: PaymentSummary | null;
  refunded_to_card_amount?: number | null;
  /** Whether payment method is required before confirmation */
  requires_payment_method?: boolean;
  rescheduled_from?: RescheduledFromInfo | null;
  rescheduled_from_booking_id?: string | null;
  rescheduled_to_booking_id?: string | null;
  service_area: string | null;
  service_name: string;
  settlement_outcome?: string | null;
  /** Stripe SetupIntent client_secret for collecting payment method */
  setup_intent_client_secret?: string | null;
  start_time: string;
  status: BookingStatus;
  student: StudentInfo;
  student_credit_amount?: number | null;
  student_id: string;
  student_note: string | null;
  student_timezone?: string | null;
  total_price: number;
}

/**
 * A booking in a list view with privacy-safe names.
 */
export interface BookingListItem {
  booking_date: string;
  booking_id: string;
  category: string;
  created_at: string;
  end_time: string;
  instructor_name: string;
  location_type: string;
  service_name: string;
  start_time: string;
  status: string;
  student_name: string;
  total_cents: number;
}

/**
 * Request to update a booking's payment method, with optional default flag.
 */
export interface BookingPaymentMethodUpdate {
  /** Stripe payment method ID */
  payment_method_id: string;
  /** Whether to save as default for the student */
  set_as_default?: boolean;
}

export type BookingPeriod = (typeof BookingPeriod)[keyof typeof BookingPeriod];

export const BookingPeriod = {
  today: 'today',
  yesterday: 'yesterday',
  this_week: 'this_week',
  last_7_days: 'last_7_days',
  this_month: 'this_month',
} as const;

export type BookingPreviewResponseLocationType =
  (typeof BookingPreviewResponseLocationType)[keyof typeof BookingPreviewResponseLocationType];

export const BookingPreviewResponseLocationType = {
  student_location: 'student_location',
  instructor_location: 'instructor_location',
  online: 'online',
  neutral_location: 'neutral_location',
} as const;

/**
 * Response for booking preview with privacy protection.
 */
export interface BookingPreviewResponse {
  booking_date: string;
  booking_id: string;
  duration_minutes: number;
  end_time: string;
  instructor_first_name: string;
  instructor_last_name: string;
  location_address?: string | null;
  location_lat?: number | null;
  location_lng?: number | null;
  location_place_id?: string | null;
  location_type: BookingPreviewResponseLocationType;
  location_type_display: string;
  meeting_location: string | null;
  service_area: string | null;
  service_name: string;
  start_time: string;
  status: string;
  student_first_name: string;
  student_last_name: string;
  student_note: string | null;
  total_price: number;
}

/**
 * Request to reschedule an existing booking by specifying a new date/time and duration.

Frontend will subsequently create a new booking; this endpoint prepares the system by
cancelling the old booking according to policy and recording audit events.
 */
export interface BookingRescheduleRequest {
  /** New date for the lesson */
  booking_date: string;
  /** Override service if needed (defaults to old) */
  instructor_service_id?: string | null;
  /**
   * New selected duration in minutes
   * @minimum 15
   * @maximum 720
   */
  selected_duration: number;
  /** New start time (HH:MM) */
  start_time: string;
}

/**
 * Complete booking response with privacy protection.

Shows instructor as "FirstName L" (last initial only).
Students see their own full information.
Clean Architecture: No availability slot references.
 */
export interface BookingResponse {
  auth_attempted_at?: string | null;
  auth_failure_count?: number | null;
  auth_last_error?: string | null;
  auth_scheduled_for?: string | null;
  booking_date: string;
  booking_end_utc?: string | null;
  booking_start_utc?: string | null;
  cancellation_reason: string | null;
  cancelled_at: string | null;
  cancelled_by_id: string | null;
  completed_at: string | null;
  confirmed_at: string | null;
  created_at: string;
  credits_reserved_cents?: number | null;
  duration_minutes: number;
  end_time: string;
  has_locked_funds?: boolean | null;
  hourly_rate: number;
  id: string;
  instructor: InstructorInfo;
  instructor_id: string;
  instructor_note: string | null;
  instructor_payout_amount?: number | null;
  instructor_service: ServiceInfo;
  instructor_service_id: string;
  instructor_timezone?: string | null;
  lesson_timezone?: string | null;
  location_address?: string | null;
  location_lat?: number | null;
  location_lng?: number | null;
  location_place_id?: string | null;
  location_type: 'student_location' | 'instructor_location' | 'online' | 'neutral_location' | null;
  lock_resolution?: string | null;
  lock_resolved_at?: string | null;
  locked_amount_cents?: number | null;
  locked_at?: string | null;
  meeting_location: string | null;
  no_show_dispute_reason?: string | null;
  no_show_disputed?: boolean | null;
  no_show_disputed_at?: string | null;
  no_show_reported_at?: string | null;
  no_show_reported_by?: string | null;
  no_show_resolution?: string | null;
  no_show_resolved_at?: string | null;
  no_show_type?: string | null;
  payment_summary?: PaymentSummary | null;
  refunded_to_card_amount?: number | null;
  rescheduled_from?: RescheduledFromInfo | null;
  rescheduled_from_booking_id?: string | null;
  rescheduled_to_booking_id?: string | null;
  service_area: string | null;
  service_name: string;
  settlement_outcome?: string | null;
  start_time: string;
  status: BookingStatus;
  student: StudentInfo;
  student_credit_amount?: number | null;
  student_id: string;
  student_note: string | null;
  student_timezone?: string | null;
  total_price: number;
}

/**
 * Booking statistics for instructors.
 */
export interface BookingStatsResponse {
  average_rating?: number | null;
  cancelled_bookings: number;
  completed_bookings: number;
  this_month_earnings: number;
  total_bookings: number;
  total_earnings: number;
  upcoming_bookings: number;
}

/**
 * Minimal booking info shown in conversation context.
 */
export interface BookingSummary {
  date: string;
  id: string;
  service_name: string;
  start_time: string;
}

/**
 * Response for booking summary endpoint.
 */
export interface BookingSummaryResponse {
  checked_at: string;
  summary: AdminBookingSummary;
}

/**
 * Schema for updating booking details.

Limited fields can be updated after booking creation.
 */
export interface BookingUpdate {
  instructor_note?: string | null;
  meeting_location?: string | null;
}

/**
 * Request budget tracking.
 */
export interface BudgetInfo {
  /** Degradation level label */
  degradation_level: string;
  /**
   * Initial request budget in ms
   * @minimum 0
   */
  initial_ms: number;
  /** Whether the budget was exceeded */
  over_budget: boolean;
  /**
   * Remaining budget in ms
   * @minimum 0
   */
  remaining_ms: number;
  /** Skipped operations due to budget */
  skipped_operations?: string[];
}

/**
 * Details for build_response pipeline stage.
 */
export interface BuildResponseStageDetails {
  /** Number of results in final response */
  result_count: number;
}

export type OperationResultStatus =
  (typeof OperationResultStatus)[keyof typeof OperationResultStatus];

export const OperationResultStatus = {
  success: 'success',
  failed: 'failed',
  skipped: 'skipped',
} as const;

/**
 * Result of a single operation in bulk update.
 */
export interface OperationResult {
  action: string;
  operation_index: number;
  reason?: string | null;
  slot_id?: string | null;
  status: OperationResultStatus;
}

export interface BulkUpdateResponse {
  failed: number;
  results: OperationResult[];
  skipped: number;
  successful: number;
}

/**
 * Details for burst1 pipeline stage (pre-OpenAI batch).
 */
export interface Burst1StageDetails {
  /** Location resolution tier used */
  location_tier?: number | null;
  /** Whether region lookup was loaded */
  region_lookup_loaded: boolean;
  /** Number of text search candidates */
  text_candidates: number;
}

/**
 * Details for burst2 pipeline stage (post-OpenAI batch).
 */
export interface Burst2StageDetails {
  /** Whether filtering failed */
  filter_failed: boolean;
  /** Whether ranking failed */
  ranking_failed: boolean;
  /** Total candidates after retrieval */
  total_candidates: number;
  /** Whether vector search was used */
  vector_search_used: boolean;
}

/**
 * Details for cache_check pipeline stage.
 */
export interface CacheCheckStageDetails {
  /** Cache check latency in milliseconds */
  latency_ms: number;
}

/**
 * Cache health and performance status.
 */
export interface CacheHealthStatus {
  /** Cache error count */
  errors: number;
  /** Cache hit rate percentage */
  hit_rate: string;
  /** Performance recommendations */
  recommendations: string[];
  /** Health status (healthy/degraded/unhealthy) */
  status: string;
  /** Total cache requests */
  total_requests: number;
}

/**
 * Redis server information
 */
export type CacheMetricsResponseRedisInfo = { [key: string]: unknown } | null;

/**
 * Detailed cache metrics response.
 */
export interface CacheMetricsResponse {
  /** Availability-specific cache metrics */
  availability_metrics: AvailabilityMetrics;
  /** Cache errors */
  errors: number;
  /** Cache hit rate percentage */
  hit_rate: string;
  /** Cache hits */
  hits: number;
  /** Cache misses */
  misses: number;
  /** Cache performance insights */
  performance_insights: string[];
  /** Redis server information */
  redis_info?: CacheMetricsResponseRedisInfo;
}

export interface CandidateCategoryTrend {
  category: string;
  count: number;
  date: string;
}

export type CandidateCategoryTrendsResponse = CandidateCategoryTrend[];

export interface CandidateScoreDistributionResponse {
  gte_0_70_lt_0_80: number;
  gte_0_80_lt_0_90: number;
  gte_0_90: number;
  lt_0_70: number;
}

export interface CandidateServiceQuery {
  position: number;
  results_count: number | null;
  score: number | null;
  search_query: string;
  searched_at: string;
  source: string | null;
}

export type CandidateServiceQueriesResponse = CandidateServiceQuery[];

export type CandidateSummaryResponseSourceBreakdown = { [key: string]: number };

export interface CandidateSummaryResponse {
  avg_candidates_per_event: number;
  events_with_candidates: number;
  source_breakdown: CandidateSummaryResponseSourceBreakdown;
  total_candidates: number;
  zero_result_events_with_candidates: number;
}

export interface CandidateTopService {
  active_instructors: number;
  avg_position: number;
  avg_score: number;
  candidate_count: number;
  category_name: string;
  opportunity_score: number;
  service_catalog_id: string;
  service_name: string;
}

export type CandidateTopServicesResponse = CandidateTopService[];

/**
 * Minimal catalog service response for pills/lists.
 */
export interface CatalogServiceMinimalResponse {
  id: string;
  name: string;
  slug: string;
}

/**
 * Catalog service response.
 */
export interface CatalogServiceResponse {
  category?: string | null;
  category_id: string;
  description?: string | null;
  display_order?: number | null;
  id: string;
  max_recommended_price?: number | null;
  min_recommended_price?: number | null;
  name: string;
  online_capable?: boolean | null;
  requires_certification?: boolean | null;
  search_terms?: string[];
  slug: string;
  typical_duration_options?: number[];
}

/**
 * Service category response.
 */
export interface CategoryResponse {
  description?: string | null;
  display_order: number;
  icon_name?: string | null;
  id: string;
  name: string;
  slug: string;
  subtitle?: string | null;
}

export type CeleryQueuesDataQueues = { [key: string]: number };

/**
 * Celery queue status data.
 */
export interface CeleryQueuesData {
  queues?: CeleryQueuesDataQueues;
  status?: string;
  total_pending?: number;
}

export interface CheckoutApplyRequest {
  order_id: string;
}

export interface CheckoutApplyResponse {
  applied_cents: number;
}

export interface CheckoutResponse {
  /** Payment amount in cents */
  amount: number;
  /** Platform fee in cents */
  application_fee: number;
  /** Client secret for frontend confirmation */
  client_secret?: string | null;
  /** Stripe payment intent ID */
  payment_intent_id: string;
  /** Whether payment requires additional action */
  requires_action?: boolean;
  /** Payment status */
  status: string;
  /** Whether payment was successful */
  success: boolean;
}

/**
 * Request to clear auth blocks.
 */
export interface ClearBlocksRequest {
  /** Reason for clearing blocks (for audit) */
  reason?: string | null;
  /** Block types to clear: lockout, rate_limit, captcha, failures. If not specified, clears all. */
  types?: string[] | null;
}

/**
 * Response after clearing blocks.
 */
export interface ClearBlocksResponse {
  cleared: string[];
  cleared_at: string;
  cleared_by: string;
  email: string;
  reason?: string | null;
}

export interface CodebaseCategoryStats {
  /** @minimum 0 */
  files: number;
  /** @minimum 0 */
  lines: number;
}

export interface CodebaseFileInfo {
  /** @minimum 0 */
  lines: number;
  /** @minimum 0 */
  lines_with_blanks: number;
  path: string;
  /** @minimum 0 */
  size_kb: number;
}

export type CodebaseHistoryEntryCategories = {
  [key: string]: { [key: string]: CodebaseCategoryStats };
} | null;

export interface CodebaseHistoryEntry {
  /** @minimum 0 */
  backend_lines: number;
  categories?: CodebaseHistoryEntryCategories;
  /** @minimum 0 */
  frontend_lines: number;
  /** @minimum 0 */
  git_commits: number;
  timestamp: string;
  /** @minimum 0 */
  total_files: number;
  /** @minimum 0 */
  total_lines: number;
}

export type CodebaseSectionCategories = { [key: string]: CodebaseCategoryStats };

export interface CodebaseSection {
  categories?: CodebaseSectionCategories;
  largest_files?: CodebaseFileInfo[];
  /** @minimum 0 */
  total_files: number;
  /** @minimum 0 */
  total_lines: number;
  /** @minimum 0 */
  total_lines_with_blanks: number;
}

export interface GitStats {
  current_branch: string;
  first_commit: string;
  last_commit: string;
  /** @minimum 0 */
  total_commits: number;
  /** @minimum 0 */
  unique_contributors: number;
}

export interface CodebaseMetricsSummary {
  /** @minimum 0 */
  total_files: number;
  /** @minimum 0 */
  total_lines: number;
}

export interface CodebaseMetricsResponse {
  backend: CodebaseSection;
  frontend: CodebaseSection;
  git: GitStats;
  summary: CodebaseMetricsSummary;
  timestamp: string;
}

export interface CodebaseHistoryResponse {
  current?: CodebaseMetricsResponse | null;
  items?: CodebaseHistoryEntry[];
}

/**
 * Payload required to record FCRA consent.
 */
export interface ConsentPayload {
  /**
   * @minLength 1
   * @maxLength 50
   */
  consent_version: string;
  /**
   * @minLength 1
   * @maxLength 50
   */
  disclosure_version: string;
  user_agent?: string | null;
}

/**
 * Acknowledgement returned after recording consent.
 */
export interface ConsentResponse {
  /** Whether the consent record was stored */
  ok?: boolean;
}

/**
 * Minimal user info for conversation list.
 */
export interface UserSummary {
  first_name: string;
  id: string;
  last_initial: string;
  profile_photo_url?: string | null;
}

/**
 * Full conversation details.
 */
export interface ConversationDetail {
  created_at: string;
  id: string;
  next_booking?: BookingSummary | null;
  other_user: UserSummary;
  state?: string;
  upcoming_bookings?: BookingSummary[];
}

/**
 * Preview of the last message in a conversation.
 */
export interface LastMessage {
  content: string;
  created_at: string;
  is_from_me: boolean;
}

/**
 * Single conversation in the inbox list.
 */
export interface ConversationListItem {
  id: string;
  last_message?: LastMessage | null;
  next_booking?: BookingSummary | null;
  other_user: UserSummary;
  state?: string;
  unread_count?: number;
  upcoming_booking_count?: number;
  upcoming_bookings?: BookingSummary[];
}

/**
 * Response for GET /conversations.
 */
export interface ConversationListResponse {
  conversations: ConversationListItem[];
  next_cursor?: string | null;
}

/**
 * Conversion behavior metrics.
 */
export interface ConversionBehavior {
  /** Average days to conversion */
  avg_days_to_conversion: number;
  /** Average searches before conversion */
  avg_searches_before_conversion: number;
  /** Most common first search query */
  most_common_first_search: string;
}

/**
 * Guest session conversion metrics.
 */
export interface GuestConversionMetrics {
  /** Conversion rate percentage */
  conversion_rate: number;
  /** Number of converted sessions */
  converted: number;
  /** Total guest sessions */
  total: number;
}

/**
 * Combined conversion metrics.
 */
export interface ConversionMetrics {
  /** Conversion behavior metrics */
  conversion_behavior: ConversionBehavior;
  /** Guest session metrics */
  guest_sessions: GuestConversionMetrics;
}

/**
 * Guest engagement metrics.
 */
export interface GuestEngagement {
  /** Average searches per guest session */
  avg_searches_per_session: number;
  /** Sessions with multiple searches */
  engaged_sessions: number;
  /** Percentage of engaged sessions */
  engagement_rate: number;
}

/**
 * Date range for analytics.
 */
export interface DateRange {
  /** Number of days in range */
  days: number;
  /** End date in ISO format */
  end: string;
  /** Start date in ISO format */
  start: string;
}

/**
 * Guest-to-user conversion metrics response.
 */
export interface ConversionMetricsResponse {
  /** Conversion behavior patterns */
  conversion_behavior: ConversionBehavior;
  /** Guest engagement metrics */
  guest_engagement: GuestEngagement;
  /** Guest session conversion metrics */
  guest_sessions: GuestConversionMetrics;
  /** Time period for metrics */
  period: DateRange;
}

/**
 * Schema for copying availability between weeks.
 */
export interface CopyWeekRequest {
  from_week_start: string;
  to_week_start: string;
}

export interface CopyWeekResponse {
  message: string;
  source_week_start: string;
  target_week_start: string;
  windows_copied: number;
}

export type CoverageFeatureCollectionResponseFeaturesItem = { [key: string]: unknown };

export interface CoverageFeatureCollectionResponse {
  features: CoverageFeatureCollectionResponseFeaturesItem[];
  type: string;
}

/**
 * Request to create a checkout/payment for a booking.
 */
export interface CreateCheckoutRequest {
  /** Booking ID to process payment for */
  booking_id: string;
  /** Stripe payment method ID to use when a balance remains */
  payment_method_id?: string | null;
  /** Optional wallet credit amount (in cents) the student wants to apply */
  requested_credit_cents?: number | null;
  /** Whether to save payment method for future use */
  save_payment_method?: boolean;
}

/**
 * Request to create a pre-booking conversation.
 */
export interface CreateConversationRequest {
  initial_message?: string | null;
  /** @pattern ^[0-9A-HJKMNP-TV-Z]{26}$ */
  instructor_id: string;
}

/**
 * Response for POST /conversations.
 */
export interface CreateConversationResponse {
  created: boolean;
  id: string;
}

export type CreateSignedUploadRequestPurpose =
  (typeof CreateSignedUploadRequestPurpose)[keyof typeof CreateSignedUploadRequestPurpose];

export const CreateSignedUploadRequestPurpose = {
  background_check: 'background_check',
  profile_picture: 'profile_picture',
} as const;

export interface CreateSignedUploadRequest {
  /** Browser-reported MIME type */
  content_type: string;
  /** Original file name, used for extension validation */
  filename: string;
  purpose: CreateSignedUploadRequestPurpose;
  /**
   * Max 10MB
   * @minimum 1
   * @maximum 10485760
   */
  size_bytes: number;
}

export interface CreditBalanceResponse {
  /** Available credit balance */
  available: number;
  /** Credit expiration date */
  expires_at?: string | null;
  /** Reserved (pending) credits */
  pending: number;
}

/**
 * Daily search trend data.
 */
export interface DailySearchTrend {
  /** Date in ISO format */
  date: string;
  /** Total searches for the day */
  total_searches: number;
  /** Unique guest sessions */
  unique_guests: number;
  /** Unique authenticated users */
  unique_users: number;
}

export interface DashboardLinkResponse {
  /** URL to Stripe Express dashboard */
  dashboard_url: string;
  /** Minutes until link expires */
  expires_in_minutes?: number;
}

/**
 * The exported user data
 */
export type DataExportResponseData = { [key: string]: unknown };

export interface DataExportResponse {
  /** The exported user data */
  data: DataExportResponseData;
  /** Human-readable message */
  message: string;
  /** Status of the export request */
  status: string;
}

/**
 * Database connection pool status.
 */
export interface DatabasePoolStatus {
  /** Available connections */
  checked_in: number;
  /** Active connections */
  checked_out: number;
  /** Overflow connections */
  overflow: number;
  /** Total pool size */
  pool_size: number;
  /** Pool usage percentage */
  usage_percent: number;
}

/**
 * Database metrics for monitoring dashboard.
 */
export interface DatabaseDashboardMetrics {
  /** Average pool usage percentage */
  average_pool_usage_percent?: number;
  /** Connection pool status */
  pool: DatabasePoolStatus;
  /** Number of slow queries */
  slow_queries_count?: number;
}

/**
 * Database health metrics.
 */
export interface DatabaseHealthMetrics {
  /** Health status */
  status: string;
  /** Pool usage percentage */
  usage_percent: number;
}

/**
 * Database connection pool metrics.
 */
export interface DatabasePoolMetrics {
  /** Available connections */
  checked_in: number;
  /** Active connections */
  checked_out: number;
  /** Maximum pool size */
  max_size: number;
  /** Overflow connections */
  overflow: number;
  /** Base pool size */
  size: number;
  /** Total connections (size + overflow) */
  total: number;
  /** Pool usage percentage */
  usage_percent: number;
}

/**
 * Response for database health check endpoint.
 */
export interface DatabaseHealthResponse {
  /** Error message if unhealthy */
  error?: string | null;
  /** Health check message */
  message: string;
  /** Connection pool status */
  pool_status?: DatabasePoolMetrics | null;
  /** Health status (healthy/unhealthy) */
  status: string;
}

/**
 * SQLAlchemy pool configuration.
 */
export interface DatabasePoolConfiguration {
  /** Maximum overflow connections */
  max_overflow: number;
  /** Base pool size */
  pool_size: number;
  /** Connection recycle time seconds */
  recycle?: number | null;
  /** Connection timeout seconds */
  timeout?: number | null;
}

/**
 * Current load level
 */
export type DatabaseRecommendationsCurrentLoad =
  (typeof DatabaseRecommendationsCurrentLoad)[keyof typeof DatabaseRecommendationsCurrentLoad];

export const DatabaseRecommendationsCurrentLoad = {
  low: 'low',
  normal: 'normal',
  high: 'high',
} as const;

/**
 * Database pool recommendations.
 */
export interface DatabaseRecommendations {
  /** Current load level */
  current_load: DatabaseRecommendationsCurrentLoad;
  /** Whether pool size should be increased */
  increase_pool_size: boolean;
}

/**
 * Response for database pool status endpoint.
 */
export interface DatabasePoolStatusResponse {
  configuration: DatabasePoolConfiguration;
  pool: DatabasePoolMetrics;
  recommendations: DatabaseRecommendations;
  status: string;
}

/**
 * Response for database statistics endpoint.
 */
export interface DatabaseStatsResponse {
  configuration: DatabasePoolConfiguration;
  health: DatabaseHealthMetrics;
  pool: DatabasePoolMetrics;
  status: string;
}

export interface DeleteBlackoutResponse {
  blackout_id: string;
  message?: string;
}

export interface DeleteMessageResponse {
  /** Success message */
  message?: string;
  success?: boolean;
}

export interface DeleteWindowResponse {
  message?: string;
  window_id: string;
}

/**
 * Device information for analytics.
 */
export interface DeviceContext {
  browser?: string | null;
  connection_effective_type?: string | null;
  connection_type?: string | null;
  device_type?: string | null;
  language?: string | null;
  os?: string | null;
  screen_height?: number | null;
  screen_resolution?: string | null;
  screen_width?: number | null;
  timezone?: string | null;
  viewport_size?: string | null;
}

/**
 * Export format (csv or pdf)
 */
export type EarningsExportRequestFormat =
  (typeof EarningsExportRequestFormat)[keyof typeof EarningsExportRequestFormat];

export const EarningsExportRequestFormat = {
  csv: 'csv',
  pdf: 'pdf',
} as const;

/**
 * Request to export instructor earnings.
 */
export interface EarningsExportRequest {
  /** End date (inclusive) for the export */
  end_date?: string | null;
  /** Export format (csv or pdf) */
  format?: EarningsExportRequestFormat;
  /** Start date (inclusive) for the export */
  start_date?: string | null;
}

export interface InstructorInvoiceSummary {
  /** Associated booking ID */
  booking_id: string;
  /** When the payment was completed */
  created_at: string;
  /** Duration of the lesson in minutes */
  duration_minutes?: number | null;
  /** Net payout to the instructor after fees (in cents) */
  instructor_share_cents: number;
  /** Date of the lesson */
  lesson_date: string;
  /** Base lesson price (instructor's rate Ã— duration) */
  lesson_price_cents: number;
  /** Platform fee deducted from instructor earnings */
  platform_fee_cents: number;
  /** Platform fee rate applied (e.g., 0.1 for 10%) */
  platform_fee_rate: number;
  /** Name of the service taught */
  service_name?: string | null;
  /** Lesson start time */
  start_time?: string | null;
  /** Invoice/payment status */
  status: string;
  /** Booking protection fee added to student (not deducted from instructor) */
  student_fee_cents: number;
  /** Student name (privacy aware) */
  student_name?: string | null;
  /** Tip amount included with the payment in cents */
  tip_cents: number;
  /** Total amount paid by the student in cents */
  total_paid_cents: number;
}

export interface EarningsResponse {
  /** Average earning per booking */
  average_earning?: number | null;
  /** Number of bookings */
  booking_count?: number | null;
  /** Total hours invoiced for completed lessons */
  hours_invoiced?: number | null;
  /** Recent invoices contributing to earnings */
  invoices?: InstructorInvoiceSummary[];
  /** End of period */
  period_end?: string | null;
  /** Start of period */
  period_start?: string | null;
  /** Number of completed services contributing to earnings */
  service_count?: number | null;
  /** Total earnings in cents */
  total_earned?: number | null;
  /** Total fees in cents */
  total_fees?: number | null;
  /** Total value of all lessons (before any fees) */
  total_lesson_value?: number | null;
  /** Total platform fees deducted from instructor earnings */
  total_platform_fees?: number | null;
  /** Total tips received */
  total_tips?: number | null;
}

export interface EditMessageRequest {
  /**
   * New message content
   * @minLength 1
   * @maxLength 5000
   */
  content: string;
}

/**
 * Details for embedding pipeline stage.
 */
export interface EmbeddingStageDetails {
  /** Skip/error reason if any */
  reason?: string | null;
  /** Whether embedding was actually used */
  used: boolean;
}

export type ExistingReviewIdsResponse = string[];

/**
 * Analytics export response.
 */
export interface ExportAnalyticsResponse {
  /** Download URL when ready */
  download_url?: string | null;
  /** Export format (csv, xlsx, json) */
  format: string;
  /** Status message */
  message: string;
  /** Export status */
  status: string;
  /** User email who requested export */
  user: string;
}

/**
 * Cache key pattern counts
 */
export type ExtendedCacheStatsKeyPatterns = { [key: string]: number } | null;

/**
 * Redis server information
 */
export type ExtendedCacheStatsRedisInfo = { [key: string]: unknown } | null;

/**
 * Extended cache statistics.
 */
export interface ExtendedCacheStats {
  /** Basic cache statistics */
  basic_stats: BasicCacheStats;
  /** Cache key pattern counts */
  key_patterns?: ExtendedCacheStatsKeyPatterns;
  /** Redis server information */
  redis_info?: ExtendedCacheStatsRedisInfo;
}

/**
 * Response for favorite add/remove operations.
 */
export interface FavoriteResponse {
  /** True if already favorited (for add) */
  already_favorited?: boolean | null;
  /** ID of the created favorite (for add operations) */
  favorite_id?: string | null;
  /** Human-readable message about the operation */
  message: string;
  /** True if not favorited (for remove) */
  not_favorited?: boolean | null;
  /** Whether the operation was successful */
  success: boolean;
}

/**
 * Response for single favorite status check.
 */
export interface FavoriteStatusResponse {
  /** Whether the instructor is favorited */
  is_favorited: boolean;
}

export interface PreferredPublicSpaceOut {
  [key: string]: unknown;
}

export interface PreferredTeachingLocationOut {
  [key: string]: unknown;
}

/**
 * Normalized neighborhood metadata used in instructor service area responses.
 */
export interface ServiceAreaNeighborhood {
  borough?: string | null;
  name?: string | null;
  neighborhood_id: string;
  ntacode?: string | null;
}

/**
 * Schema for service responses.

Includes the service ID and catalog information.
 */
export interface ServiceResponse {
  /** Age groups this service is offered to. Allowed: 'kids', 'adults'. Use both for both. */
  age_groups?: string[] | null;
  description?: string | null;
  /** Display order hint from the catalog (nullable) */
  display_order?: number | null;
  /**
   * Available duration options for this service in minutes
   * @minItems 1
   */
  duration_options?: number[];
  /** List of equipment required (strings) */
  equipment_required?: string[] | null;
  /** Hourly rate in USD */
  hourly_rate: number;
  id: string;
  /** Whether this service is currently active for the instructor */
  is_active?: boolean | null;
  /** Levels taught. Allowed: 'beginner', 'intermediate', 'advanced' */
  levels_taught?: string[] | null;
  /** Where lessons are offered. Allowed: 'in_person', 'online' */
  location_types?: string[] | null;
  /** Resolved name of the service from the catalog */
  name?: string | null;
  /** Whether the instructor offers lessons at their location for this service */
  offers_at_location?: boolean;
  /** Whether the instructor offers online lessons for this service */
  offers_online?: boolean;
  /** Whether the instructor travels to student locations for this service */
  offers_travel?: boolean;
  /** Whether the catalog service supports online delivery */
  online_capable?: boolean | null;
  requirements?: string | null;
  /** Whether the catalog service requires certification */
  requires_certification?: boolean | null;
  /** ID of the service from catalog */
  service_catalog_id: string;
  /**
   * Human-readable name of the catalog service
   * @maxLength 255
   */
  service_catalog_name: string;
}

/**
 * Basic user information with privacy protection.

Shows only last initial instead of full last name for privacy.
Used in student-facing endpoints to protect instructor privacy.
Email is omitted for privacy protection.
 */
export interface UserBasicPrivacy {
  first_name: string;
  id: string;
  last_initial: string;
}

/**
 * Schema for instructor profile responses with privacy protection.

Includes all profile data plus relationships and metadata.
Student-facing endpoints will show only instructor last initial.
 */
export interface InstructorProfileResponse {
  background_check_object_key?: string | null;
  background_check_uploaded_at?: string | null;
  /** Background check status for public display */
  bgc_status?: string | null;
  /**
   * Instructor biography/description
   * @minLength 10
   * @maxLength 1000
   */
  bio: string;
  /**
   * Buffer time between bookings
   * @minimum 0
   * @maximum 60
   */
  buffer_time_minutes?: number;
  created_at: string;
  /** Number of students who favorited this instructor */
  favorited_count?: number;
  id: string;
  identity_verification_session_id?: string | null;
  identity_verified_at?: string | null;
  /** Whether the current user has favorited this instructor */
  is_favorited?: boolean | null;
  /** Whether the instructor is a founding instructor */
  is_founding_instructor?: boolean;
  is_live?: boolean;
  /**
   * Minimum hours in advance for bookings
   * @minimum 0
   * @maximum 168
   */
  min_advance_booking_hours?: number;
  onboarding_completed_at?: string | null;
  preferred_public_spaces?: PreferredPublicSpaceOut[];
  preferred_teaching_locations?: PreferredTeachingLocationOut[];
  service_area_boroughs?: string[];
  service_area_neighborhoods?: ServiceAreaNeighborhood[];
  service_area_summary?: string | null;
  services: ServiceResponse[];
  /** Whether skills/pricing were configured at least once */
  skills_configured?: boolean;
  updated_at?: string | null;
  user: UserBasicPrivacy;
  user_id: string;
  /**
   * Years of teaching experience
   * @minimum 0
   * @maximum 50
   */
  years_experience: number;
}

/**
 * Instructor with favorite metadata.
 */
export interface FavoritedInstructor {
  /** Instructor email */
  email: string;
  /** When this instructor was favorited */
  favorited_at?: string | null;
  /** Instructor first name */
  first_name: string;
  /** Instructor user ID (ULID) */
  id: string;
  /** Whether the instructor is active */
  is_active?: boolean;
  /** Instructor last name */
  last_name: string;
  /** Instructor profile details */
  profile?: InstructorProfileResponse | null;
}

/**
 * List of favorited instructors.
 */
export interface FavoritesList {
  /** List of favorited instructors */
  favorites: FavoritedInstructor[];
  /** Total number of favorites */
  total: number;
}

export interface FinalizeProfilePicturePayload {
  object_key: string;
}

export interface FinalizeProfilePictureRequest {
  /** Temporary upload object key from signed PUT */
  object_key: string;
}

/**
 * Summary of founding instructor utilization.
 */
export interface FoundingCountResponse {
  cap: number;
  count: number;
  remaining: number;
}

/**
 * Public founding phase status.
 */
export interface FoundingStatusResponse {
  is_founding_phase: boolean;
  spots_filled: number;
  spots_remaining: number;
  total_founding_spots: number;
}

/**
 * Simple response indicating gated ping success.
 */
export interface GatedPingResponse {
  ok: boolean;
}

/**
 * Schema for creating guest search history (no user_id required).
 */
export interface GuestSearchHistoryCreate {
  /**
   * UUID for guest session tracking
   * @maxLength 36
   */
  guest_session_id: string;
  /** Number of results returned */
  results_count?: number | null;
  /**
   * The search query string
   * @minLength 1
   */
  search_query: string;
  /** Type of search: natural_language, category, service_pill, filter, or search_history */
  search_type?: string;
}

export interface GuestSessionResponse {
  guest_id: string;
}

export interface ValidationError {
  loc: (string | number)[];
  msg: string;
  type: string;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * Individual component health checks
 */
export type HealthCheckResponseChecks = { [key: string]: boolean };

/**
 * Standard health check response.
 */
export interface HealthCheckResponse {
  /** Individual component health checks */
  checks: HealthCheckResponseChecks;
  /** Service name */
  service?: string;
  /**
   * Service health status
   * @pattern ^(healthy|degraded|unhealthy)$
   */
  status: string;
  /** Check timestamp */
  timestamp?: string;
  /** API version */
  version: string;
}

export interface HealthLiteResponse {
  /** Health status (ok/error) */
  status: string;
}

export interface HealthResponse {
  /** Environment name */
  environment: string;
  /** Service name */
  service: string;
  /** Health status */
  status: string;
  /** UTC ISO8601Z timestamp of the health response */
  timestamp: string;
  /** API version */
  version: string;
}

/**
 * Details for hydrate pipeline stage.
 */
export interface HydrateStageDetails {
  /** Number of results after hydration */
  result_count: number;
}

export interface IdentityRefreshResponse {
  /** Latest verification status from Stripe */
  status: string;
  /** Whether the user is now verified */
  verified: boolean;
}

export interface IdentitySessionResponse {
  /** Client secret for the verification session */
  client_secret: string;
  /** Stripe verification session identifier */
  verification_session_id: string;
}

export interface InstantPayoutResponse {
  /** Whether the instant payout request succeeded */
  ok: boolean;
  /** Stripe payout identifier if one was created */
  payout_id?: string | null;
  /** Stripe status of the payout (e.g., pending, paid) */
  status?: string | null;
}

/**
 * Schema for creating a new service.
 */
export interface ServiceCreate {
  /** Age groups this service is offered to. Allowed: 'kids', 'adults'. Use both for both. */
  age_groups?: string[] | null;
  description?: string | null;
  /**
   * Available duration options for this service in minutes
   * @minItems 1
   */
  duration_options?: number[];
  /** List of equipment required (strings) */
  equipment_required?: string[] | null;
  /** Hourly rate in USD */
  hourly_rate: number | string;
  /** Levels taught. Allowed: 'beginner', 'intermediate', 'advanced' */
  levels_taught?: string[] | null;
  /** Where lessons are offered. Allowed: 'in_person', 'online' */
  location_types?: string[] | null;
  /** Whether the instructor offers lessons at their location for this service */
  offers_at_location?: boolean | null;
  /** Whether the instructor offers online lessons for this service */
  offers_online?: boolean | null;
  /** Whether the instructor travels to student locations for this service */
  offers_travel?: boolean | null;
  requirements?: string | null;
  /** ID of the service from catalog */
  service_catalog_id: string;
}

/**
 * Schema for creating an instructor profile.

Requires at least one service to be defined.
 */
export interface InstructorProfileCreate {
  /**
   * Instructor biography/description
   * @minLength 10
   * @maxLength 1000
   */
  bio: string;
  /**
   * Buffer time between bookings
   * @minimum 0
   * @maximum 60
   */
  buffer_time_minutes?: number;
  /**
   * Minimum hours in advance for bookings
   * @minimum 0
   * @maximum 168
   */
  min_advance_booking_hours?: number;
  /**
   * Services offered by the instructor
   * @minItems 1
   * @maxItems 20
   */
  services: ServiceCreate[];
  /**
   * Years of teaching experience
   * @minimum 0
   * @maximum 50
   */
  years_experience: number;
}

/**
 * Preferred public space input payload.
 */
export interface PreferredPublicSpaceIn {
  /**
   * @minLength 1
   * @maxLength 512
   */
  address: string;
  label?: string | null;
}

/**
 * Preferred teaching location input payload.
 */
export interface PreferredTeachingLocationIn {
  /**
   * @minLength 1
   * @maxLength 512
   */
  address: string;
  label?: string | null;
}

/**
 * Schema for updating an instructor profile.

All fields are optional for partial updates.
 */
export interface InstructorProfileUpdate {
  bio?: string | null;
  /** Buffer time between bookings */
  buffer_time_minutes?: number | null;
  /** Minimum hours in advance for bookings */
  min_advance_booking_hours?: number | null;
  preferred_public_spaces?: PreferredPublicSpaceIn[] | null;
  preferred_teaching_locations?: PreferredTeachingLocationIn[] | null;
  services?: ServiceCreate[] | null;
  years_experience?: number | null;
}

/**
 * Per-service rating statistics.
 */
export interface ServiceRatingStats {
  /** Display-formatted rating or None if below threshold */
  display_rating?: string | null;
  /** ID of the instructor's service offering */
  instructor_service_id: string;
  /** Computed rating or None if below min_reviews threshold */
  rating?: number | null;
  /** Number of reviews for this service */
  review_count: number;
}

/**
 * Overall rating statistics computed using Dirichlet smoothing.
 */
export interface OverallRatingStats {
  /** Display-formatted rating (e.g., '4.5â˜…') or None if below threshold */
  display_rating?: string | null;
  /** Computed rating (Dirichlet-smoothed) */
  rating: number;
  /** Total number of reviews */
  total_reviews: number;
}

/**
 * Instructor rating statistics with overall and per-service breakdown.
 */
export interface InstructorRatingsResponse {
  /** Per-service rating breakdown */
  by_service?: ServiceRatingStats[];
  /** @pattern ^(new|establishing|established|trusted)$ */
  confidence_level: string;
  /** Overall rating statistics */
  overall: OverallRatingStats;
}

/**
 * Service offering in search results.
 */
export interface InstructorSearchResultService {
  catalog_service_id: string;
  custom_description?: string | null;
  duration_options?: number[];
  hourly_rate: number;
  id: string;
  is_active?: boolean;
  name: string;
}

/**
 * Instructor in search results.
 */
export interface InstructorSearchResult {
  average_rating?: number | null;
  bio?: string | null;
  favorited_count?: number;
  first_name: string;
  has_profile_picture?: boolean;
  id: string;
  is_favorited?: boolean | null;
  is_live?: boolean;
  last_initial: string;
  profile_picture_version?: number;
  review_count?: number;
  service_area_boroughs?: string[];
  service_area_summary?: string | null;
  services?: InstructorSearchResultService[];
  teaches_adults?: boolean | null;
  teaches_kids?: boolean | null;
  user_id: string;
  years_experience?: number | null;
}

/**
 * Coordinates payload for service area checks.
 */
export interface ServiceAreaCheckCoordinates {
  /** Latitude */
  lat: number;
  /** Longitude */
  lng: number;
}

/**
 * Response payload for instructor service area coverage checks.
 */
export interface InstructorServiceAreaCheckResponse {
  coordinates: ServiceAreaCheckCoordinates;
  /** Instructor user ULID */
  instructor_id: string;
  /** True when the coordinates fall inside an instructor's active service areas */
  is_covered: boolean;
}

/**
 * Partial update for instructor service location capabilities.
 */
export interface InstructorServiceCapabilitiesUpdate {
  offers_at_location?: boolean | null;
  offers_online?: boolean | null;
  offers_travel?: boolean | null;
}

/**
 * Create instructor service from catalog.
 */
export interface InstructorServiceCreate {
  /** ID of the catalog service */
  catalog_service_id: string;
  /** Custom description (optional) */
  custom_description?: string | null;
  /** Custom duration options in minutes (uses catalog defaults if not provided) */
  duration_options?: number[] | null;
  /**
   * Hourly rate for this service
   * @exclusiveMinimum 0
   */
  hourly_rate: number;
}

/**
 * Instructor service response with catalog info.
 */
export interface InstructorServiceResponse {
  catalog_service_id: string;
  category: string;
  created_at?: string | null;
  description?: string | null;
  duration_options?: number[];
  hourly_rate: number;
  id: string;
  is_active?: boolean;
  /** Legacy location types (in_person, online) */
  location_types?: string[] | null;
  name: string;
  offers_at_location?: boolean;
  offers_online?: boolean;
  offers_travel?: boolean;
  /** Human-readable name of the catalog service */
  service_catalog_name?: string | null;
  updated_at?: string | null;
}

/**
 * Approximate teaching location data for public maps.
 */
export interface InstructorTeachingLocationSummary {
  /** Approximate latitude */
  approx_lat: number;
  /** Approximate longitude */
  approx_lng: number;
  /** Neighborhood or city label */
  neighborhood?: string | null;
}

/**
 * Embedded instructor info for search results.
 */
export interface InstructorSummary {
  /** First 150 chars of bio */
  bio_snippet?: string | null;
  /** Instructor first name */
  first_name: string;
  /** Instructor user ID */
  id: string;
  /** Founding instructor status */
  is_founding_instructor?: boolean;
  /** Last name initial for privacy (e.g., 'D') */
  last_initial: string;
  /** Profile picture URL */
  profile_picture_url?: string | null;
  /** Approximate teaching locations for studio pins */
  teaching_locations?: InstructorTeachingLocationSummary[];
  /** Whether instructor is verified */
  verified?: boolean;
  /** Years of experience */
  years_experience?: number | null;
}

export interface InviteBatchAsyncStartResponse {
  task_id: string;
}

export interface InviteBatchSendFailure {
  email: string;
  reason: string;
}

export interface InviteSendResponse {
  code: string;
  email: string;
  id: string;
  join_url: string;
  welcome_url: string;
}

export interface InviteBatchProgressResponse {
  current: number;
  failed: number;
  failed_items?: InviteBatchSendFailure[] | null;
  sent: number;
  sent_items?: InviteSendResponse[] | null;
  state: string;
  task_id: string;
  total: number;
}

export interface InviteBatchSendRequest {
  base_url?: string | null;
  /** @minItems 1 */
  emails?: string[];
  /**
   * @minimum 1
   * @maximum 180
   */
  expires_in_days?: number;
  role?: string;
  source?: string | null;
}

export interface InviteBatchSendResponse {
  failed: InviteBatchSendFailure[];
  sent: InviteSendResponse[];
}

export interface InviteConsumeRequest {
  code: string;
  phase?: string;
  role?: string;
  user_id: string;
}

export interface InviteGenerateRequest {
  count?: number;
  emails?: string[] | null;
  expires_in_days?: number;
  role?: string;
  source?: string | null;
}

export interface InviteRecord {
  code: string;
  email?: string | null;
  expires_at: string;
  id: string;
  role: string;
}

export interface InviteGenerateResponse {
  invites: InviteRecord[];
}

export interface InviteSendRequest {
  base_url?: string | null;
  /**
   * @minimum 1
   * @maximum 180
   */
  expires_in_days?: number;
  grant_founding_status?: boolean;
  role?: string;
  source?: string | null;
  to_email: string;
}

export type InviteStatus = (typeof InviteStatus)[keyof typeof InviteStatus];

export const InviteStatus = {
  pending: 'pending',
  accepted: 'accepted',
  expired: 'expired',
  revoked: 'revoked',
} as const;

export interface InviteValidateResponse {
  code?: string | null;
  email?: string | null;
  expires_at?: string | null;
  reason?: string | null;
  role?: string | null;
  used_at?: string | null;
  valid: boolean;
}

export interface LineItem {
  /**
   * @minimum -1000000000
   * @maximum 1000000000
   */
  amount_cents: number;
  label: string;
}

/**
 * Response for listing accounts with auth issues.
 */
export interface ListAuthIssuesResponse {
  accounts: BlockedAccount[];
  scanned_at: string;
  total: number;
}

/**
 * Simplified alert item for live view.
 */
export interface LiveAlertItem {
  /** Alert message (truncated if long) */
  message: string;
  /** Alert severity (uppercase) */
  severity: string;
  /** Time in HH:MM:SS format */
  time: string;
  /** Alert type */
  type: string;
}

/**
 * Response for live alerts endpoint.
 */
export interface LiveAlertsResponse {
  /** List of recent alerts */
  alerts: LiveAlertItem[];
  /** Number of alerts in the time period */
  count: number;
  /** Number of minutes included */
  minutes: number;
}

/**
 * Status for pipeline stages and location tiers.
 */
export type StageStatus = (typeof StageStatus)[keyof typeof StageStatus];

export const StageStatus = {
  success: 'success',
  skipped: 'skipped',
  timeout: 'timeout',
  error: 'error',
  cache_hit: 'cache_hit',
  miss: 'miss',
  cancelled: 'cancelled',
} as const;

/**
 * Result of a location resolution tier attempt.
 */
export interface LocationTierResult {
  /** Whether the tier was attempted */
  attempted: boolean;
  /** Confidence score when available */
  confidence?: number | null;
  /** Additional tier details */
  details?: string | null;
  /**
   * Tier duration in ms
   * @minimum 0
   */
  duration_ms: number;
  /** Resolved location name if any */
  result?: string | null;
  /** Tier status */
  status: StageStatus;
  /**
   * Location tier (0-5)
   * @minimum 0
   * @maximum 5
   */
  tier: number;
}

/**
 * Detailed location resolution breakdown.
 */
export interface LocationResolutionInfo {
  /** Original location query */
  query: string;
  /** Resolved location name */
  resolved_name?: string | null;
  /** Resolved sub-regions if applicable */
  resolved_regions?: string[] | null;
  /** Successful tier number if any */
  successful_tier?: number | null;
  /** Per-tier results */
  tiers?: LocationTierResult[];
}

/**
 * Details for location_resolution pipeline stage.
 */
export interface LocationResolutionStageDetails {
  /** Whether location was successfully resolved */
  resolved: boolean;
  /** Resolution tier that succeeded */
  tier?: number | null;
}

export interface LoginResponse {
  access_token?: string | null;
  requires_2fa?: boolean;
  temp_token?: string | null;
  token_type?: string | null;
}

export type MCPActorPrincipalType =
  (typeof MCPActorPrincipalType)[keyof typeof MCPActorPrincipalType];

export const MCPActorPrincipalType = {
  user: 'user',
  service: 'service',
} as const;

export interface MCPActor {
  email: string;
  id: string;
  principal_type?: MCPActorPrincipalType;
}

/**
 * Information about a currently running Celery task.
 */
export interface MCPCeleryActiveTask {
  args?: string | null;
  kwargs?: string | null;
  started_at?: string | null;
  task_id: string;
  task_name: string;
  worker: string;
}

/**
 * Response for active tasks endpoint.
 */
export interface MCPCeleryActiveTasksResponse {
  checked_at: string;
  count: number;
  tasks: MCPCeleryActiveTask[];
}

/**
 * Information about a scheduled periodic task.
 */
export interface MCPCeleryScheduledTask {
  enabled?: boolean;
  last_run?: string | null;
  name: string;
  next_run?: string | null;
  schedule: string;
  task: string;
}

/**
 * Response for beat schedule endpoint.
 */
export interface MCPCeleryBeatScheduleResponse {
  checked_at: string;
  count: number;
  tasks: MCPCeleryScheduledTask[];
}

/**
 * Information about a failed Celery task.
 */
export interface MCPCeleryFailedTask {
  exception?: string | null;
  failed_at?: string | null;
  queue?: string | null;
  task_args?: string | null;
  task_id: string;
  task_kwargs?: string | null;
  task_name: string;
  traceback?: string | null;
}

/**
 * Response for failed tasks endpoint.
 */
export interface MCPCeleryFailedTasksResponse {
  checked_at: string;
  count: number;
  failed_tasks: MCPCeleryFailedTask[];
}

/**
 * Information about the last run of a payment task.
 */
export interface MCPCeleryLastTaskRun {
  last_run_at?: string | null;
  status?: string | null;
  task_name: string;
}

/**
 * A payment health issue.
 */
export interface MCPCeleryPaymentHealthIssue {
  count: number;
  message: string;
  severity: string;
}

/**
 * Response for payment health endpoint.
 */
export interface MCPCeleryPaymentHealthResponse {
  checked_at: string;
  failed_payments_24h: number;
  healthy: boolean;
  issues: MCPCeleryPaymentHealthIssue[];
  last_task_runs: MCPCeleryLastTaskRun[];
  overdue_authorizations: number;
  pending_authorizations: number;
  pending_captures: number;
}

/**
 * Information about a single Celery queue.
 */
export interface MCPCeleryQueueInfo {
  consumers: number;
  depth: number;
  name: string;
}

/**
 * Response for Celery queues endpoint.
 */
export interface MCPCeleryQueuesResponse {
  checked_at: string;
  queues: MCPCeleryQueueInfo[];
  total_depth: number;
}

/**
 * Information about a historical Celery task execution.
 */
export interface MCPCeleryTaskHistoryItem {
  exception?: string | null;
  received_at?: string | null;
  result?: string | null;
  retries?: number;
  runtime_seconds?: number | null;
  started_at?: string | null;
  state: string;
  succeeded_at?: string | null;
  task_id: string;
  task_name: string;
}

export type MCPCeleryTaskHistoryResponseFiltersApplied = { [key: string]: unknown };

/**
 * Response for task history endpoint.
 */
export interface MCPCeleryTaskHistoryResponse {
  checked_at: string;
  count: number;
  filters_applied: MCPCeleryTaskHistoryResponseFiltersApplied;
  tasks: MCPCeleryTaskHistoryItem[];
}

/**
 * Information about a single Celery worker.
 */
export interface MCPCeleryWorkerInfo {
  active_tasks: number;
  concurrency: number;
  hostname: string;
  processed_total: number;
  queues: string[];
  status: string;
}

/**
 * Summary counts for workers.
 */
export interface MCPCeleryWorkersSummary {
  offline_workers: number;
  online_workers: number;
  total_active_tasks: number;
  total_workers: number;
}

/**
 * Response for Celery workers endpoint.
 */
export interface MCPCeleryWorkersResponse {
  checked_at: string;
  summary: MCPCeleryWorkersSummary;
  workers: MCPCeleryWorkerInfo[];
}

export interface MCPConversionRate {
  from_stage: string;
  rate: number;
  to_stage: string;
}

export interface MCPDateWindow {
  end: string;
  start: string;
}

export interface MCPFoundingCap {
  cap: number;
  is_founding_phase: boolean;
  remaining: number;
  used: number;
}

export interface MCPFunnelStage {
  count: number;
  description: string;
  stage: string;
}

export interface MCPMeta {
  actor: MCPActor;
  generated_at: string;
  request_id: string;
}

export interface MCPTimeWindow {
  end?: string | null;
  start?: string | null;
}

export interface MCPFunnelSummaryResponse {
  conversion_rates: MCPConversionRate[];
  founding_cap: MCPFoundingCap;
  meta: MCPMeta;
  stages: MCPFunnelStage[];
  time_window: MCPTimeWindow;
}

export interface MCPInstructorBGC {
  completed_at?: string | null;
  status?: string | null;
  valid_until?: string | null;
}

export interface MCPInstructorOnboarding {
  background_check_uploaded_at?: string | null;
  bgc_completed_at?: string | null;
  bgc_invited_at?: string | null;
  identity_verified_at?: string | null;
  onboarding_completed_at?: string | null;
  profile_created_at?: string | null;
  profile_updated_at?: string | null;
}

export interface MCPInstructorService {
  category: string;
  /** @pattern ^(?!^[-+.]*$)[+-]?0*\d*\.?\d*$ */
  hourly_rate: string;
  is_active: boolean;
  name: string;
  slug: string;
}

export interface MCPInstructorStats {
  bookings_cancelled: number;
  bookings_completed: number;
  no_shows: number;
  rating_avg: number;
  rating_count: number;
  response_rate?: number | null;
}

export interface MCPInstructorDetailResponse {
  admin_url: string;
  bgc: MCPInstructorBGC;
  email: string;
  founding_granted_at?: string | null;
  is_founding: boolean;
  live_at?: string | null;
  meta: MCPMeta;
  name: string;
  onboarding: MCPInstructorOnboarding;
  phone?: string | null;
  services: MCPInstructorService[];
  stats: MCPInstructorStats;
  status: string;
  user_id: string;
}

export interface MCPInstructorListItem {
  admin_url: string;
  bookings_completed: number;
  categories: string[];
  email: string;
  founding_granted_at?: string | null;
  is_founding: boolean;
  live_at?: string | null;
  name: string;
  rating_avg: number;
  services: string[];
  status: string;
  user_id: string;
}

export interface MCPInstructorListResponse {
  items: MCPInstructorListItem[];
  limit: number;
  meta: MCPMeta;
  next_cursor?: string | null;
}

export type MCPInviteDetailDataMetadata = { [key: string]: unknown } | null;

export interface MCPInviteStatusEvent {
  status: string;
  timestamp: string;
}

export interface MCPInviteDetailData {
  accepted_at?: string | null;
  code: string;
  created_at: string;
  email?: string | null;
  expires_at: string;
  grant_founding_status: boolean;
  id: string;
  metadata?: MCPInviteDetailDataMetadata;
  role: string;
  status: string;
  status_history: MCPInviteStatusEvent[];
  used_by_user_id?: string | null;
}

export interface MCPInviteDetailResponse {
  data: MCPInviteDetailData;
  meta: MCPMeta;
}

export interface MCPInviteListItem {
  accepted_at?: string | null;
  code: string;
  created_at: string;
  email?: string | null;
  expires_at: string;
  id: string;
  status: string;
}

export interface MCPInviteListData {
  count: number;
  invites: MCPInviteListItem[];
  next_cursor?: string | null;
}

export interface MCPInviteListResponse {
  data: MCPInviteListData;
  meta: MCPMeta;
}

export interface MCPInvitePreview {
  expires_at: string;
  founding_cap_remaining: number;
  grants_founding: boolean;
  subject: string;
}

export interface MCPInvitePreviewRecipient {
  email: string;
  exists_in_system: boolean;
  user_id?: string | null;
}

export interface MCPInvitePreviewData {
  confirm_expires_at: string;
  confirm_token: string;
  invite_preview: MCPInvitePreview;
  recipient_count: number;
  recipients: MCPInvitePreviewRecipient[];
  warnings: string[];
}

export interface MCPInvitePreviewRequest {
  /**
   * @minimum 1
   * @maximum 180
   */
  expires_in_days?: number;
  grant_founding_status?: boolean;
  message_note?: string | null;
  /**
   * @minItems 1
   * @maxItems 100
   */
  recipient_emails: string[];
}

export interface MCPInvitePreviewResponse {
  data: MCPInvitePreviewData;
  meta: MCPMeta;
}

export interface MCPInviteSendResult {
  code: string;
  email: string;
  status: string;
}

export interface MCPInviteSendData {
  audit_id: string;
  failed_count: number;
  invites: MCPInviteSendResult[];
  sent_count: number;
}

export interface MCPInviteSendRequest {
  confirm_token: string;
  idempotency_key: string;
}

export interface MCPInviteSendResponse {
  data: MCPInviteSendData;
  meta: MCPMeta;
}

export interface MCPMetricDefinition {
  definition: string;
  metric: string;
  related_metrics: string[];
  requirements: string[];
  source_fields: string[];
}

export interface MCPMetricResponse {
  data: MCPMetricDefinition;
  meta: MCPMeta;
}

export interface MCPServiceCatalogItem {
  category_name?: string | null;
  category_slug?: string | null;
  id: string;
  is_active: boolean;
  name: string;
  slug: string;
}

export interface MCPServiceCatalogData {
  count: number;
  services: MCPServiceCatalogItem[];
}

export interface MCPServiceCatalogResponse {
  data: MCPServiceCatalogData;
  meta: MCPMeta;
}

export interface MCPServiceCoverageData {
  group_by: string;
  labels: string[];
  total_instructors: number;
  total_services_offered: number;
  values: number[];
}

export interface MCPServiceCoverageResponse {
  data: MCPServiceCoverageData;
  meta: MCPMeta;
}

export interface MCPServiceLookupData {
  count: number;
  matches: MCPServiceCatalogItem[];
  message?: string | null;
  query: string;
}

export interface MCPServiceLookupResponse {
  data: MCPServiceLookupData;
  meta: MCPMeta;
}

export interface MCPStuckInstructor {
  current_stage: string;
  days_in_stage: number;
  email: string;
  name: string;
  occurred_at?: string | null;
  user_id: string;
}

export interface MCPStuckSummary {
  stage: string;
  stuck_count: number;
}

export interface MCPStuckResponse {
  instructors: MCPStuckInstructor[];
  meta: MCPMeta;
  summary: MCPStuckSummary[];
  total_stuck: number;
}

export interface MCPTopQuery {
  avg_results: number;
  conversion_rate: number;
  count: number;
  query: string;
}

export interface MCPTopQueriesData {
  queries: MCPTopQuery[];
  time_window: MCPDateWindow;
  total_searches: number;
}

export interface MCPTopQueriesResponse {
  data: MCPTopQueriesData;
  meta: MCPMeta;
}

export type MCPWebhookDetailHeaders = { [key: string]: unknown } | null;

export type MCPWebhookDetailPayload = { [key: string]: unknown };

export interface MCPWebhookDetail {
  event_id?: string | null;
  event_type: string;
  headers?: MCPWebhookDetailHeaders;
  id: string;
  idempotency_key?: string | null;
  payload: MCPWebhookDetailPayload;
  processed_at?: string | null;
  processing_duration_ms?: number | null;
  processing_error?: string | null;
  received_at?: string | null;
  related_entity?: string | null;
  replay_count?: number;
  replay_of?: string | null;
  source: string;
  status: string;
}

export interface MCPWebhookDetailMeta {
  generated_at: string;
  request_id: string;
}

export interface MCPWebhookDetailResponse {
  event: MCPWebhookDetail;
  meta: MCPWebhookDetailMeta;
}

export interface MCPWebhookEventItem {
  event_id?: string | null;
  event_type: string;
  id: string;
  processed_at?: string | null;
  processing_duration_ms?: number | null;
  received_at?: string | null;
  related_entity?: string | null;
  replay_count?: number;
  replay_of?: string | null;
  source: string;
  status: string;
}

export interface MCPWebhookFailedItem {
  event_id?: string | null;
  event_type: string;
  id: string;
  processed_at?: string | null;
  processing_duration_ms?: number | null;
  processing_error?: string | null;
  received_at?: string | null;
  related_entity?: string | null;
  replay_count?: number;
  replay_of?: string | null;
  source: string;
  status: string;
}

export interface MCPWebhookFailedMeta {
  generated_at: string;
  request_id: string;
  returned_count: number;
  since_hours: number;
}

export interface MCPWebhookFailedResponse {
  events: MCPWebhookFailedItem[];
  meta: MCPWebhookFailedMeta;
}

export interface MCPWebhookListMeta {
  generated_at: string;
  request_id: string;
  returned_count: number;
  since_hours: number;
  total_count: number;
}

export type MCPWebhookListSummaryBySource = { [key: string]: number };

export type MCPWebhookListSummaryByStatus = { [key: string]: number };

export interface MCPWebhookListSummary {
  by_source?: MCPWebhookListSummaryBySource;
  by_status?: MCPWebhookListSummaryByStatus;
}

export interface MCPWebhookListResponse {
  events: MCPWebhookEventItem[];
  meta: MCPWebhookListMeta;
  summary: MCPWebhookListSummary;
}

export interface MCPWebhookReplayMeta {
  dry_run: boolean;
  generated_at: string;
  request_id: string;
}

export interface MCPWebhookReplayResult {
  error?: string | null;
  replay_event_id?: string | null;
  status: string;
}

export interface MCPWebhookReplayResponse {
  event?: MCPWebhookEventItem | null;
  meta: MCPWebhookReplayMeta;
  note?: string | null;
  result?: MCPWebhookReplayResult | null;
}

export interface MCPZeroResultQuery {
  count: number;
  query: string;
}

export interface MCPZeroResultsData {
  queries: MCPZeroResultQuery[];
  time_window: MCPDateWindow;
  total_zero_result_searches: number;
  zero_result_rate: number;
}

export interface MCPZeroResultsResponse {
  data: MCPZeroResultsData;
  meta: MCPMeta;
}

/**
 * Request to mark messages as read.
 */
export interface MarkMessagesReadRequest {
  /** Mark all messages in this conversation as read */
  conversation_id?: string | null;
  /** Specific message IDs to mark as read */
  message_ids?: string[] | null;
}

export interface MarkMessagesReadResponse {
  /** Number of messages marked as read */
  messages_marked: number;
  success?: boolean;
}

/**
 * System memory metrics.
 */
export interface MemoryMetrics {
  /** Memory usage percentage */
  percent: number;
  /** Total memory in MB */
  total_mb: number;
  /** Used memory in MB */
  used_mb: number;
}

export interface MessageConfigResponse {
  edit_window_minutes: number;
}

/**
 * Reaction on a message.
 */
export interface ReactionInfo {
  emoji: string;
  user_id: string;
}

/**
 * Read receipt entry showing who read and when.
 */
export interface ReadReceiptEntry {
  read_at: string;
  user_id: string;
}

/**
 * Single message in a conversation.
 */
export interface MessageResponse {
  booking_details?: BookingSummary | null;
  booking_id?: string | null;
  content: string;
  conversation_id: string;
  created_at: string;
  delivered_at?: string | null;
  edited_at?: string | null;
  id: string;
  is_deleted?: boolean;
  is_from_me: boolean;
  message_type: string;
  reactions?: ReactionInfo[];
  read_by?: ReadReceiptEntry[];
  sender_id?: string | null;
}

/**
 * Response for GET /conversations/{id}/messages.
 */
export interface MessagesResponse {
  has_more?: boolean;
  messages: MessageResponse[];
  next_cursor?: string | null;
}

/**
 * Background check status after the mock update
 */
export type MockStatusResponseStatus =
  (typeof MockStatusResponseStatus)[keyof typeof MockStatusResponseStatus];

export const MockStatusResponseStatus = {
  pending: 'pending',
  review: 'review',
  consider: 'consider',
  passed: 'passed',
  failed: 'failed',
  canceled: 'canceled',
} as const;

/**
 * Response returned by non-production mock status changers.
 */
export interface MockStatusResponse {
  /** Whether the mock update succeeded */
  ok?: boolean;
  /** Background check status after the mock update */
  status: MockStatusResponseStatus;
}

/**
 * Performance optimization recommendation.
 */
export interface PerformanceRecommendation {
  /** Suggested action */
  action: string;
  /** Recommendation message */
  message: string;
  /** Severity level (info/warning) */
  severity: string;
  /** Recommendation type (database/cache/memory/requests) */
  type: string;
}

/**
 * Request processing metrics.
 */
export interface RequestMetrics {
  /** Currently active requests */
  active_count: number;
  /** Average response time in milliseconds */
  average_response_time_ms: number;
  /** Total requests processed */
  total_count: number;
}

/**
 * Comprehensive monitoring dashboard response.
 */
export interface MonitoringDashboardResponse {
  /** Active system alerts */
  alerts: AlertInfo[];
  /** Cache health status */
  cache: CacheHealthStatus;
  /** Database metrics and pool status */
  database: DatabaseDashboardMetrics;
  /** System memory metrics */
  memory: MemoryMetrics;
  /** Performance recommendations */
  recommendations: PerformanceRecommendation[];
  /** Request processing metrics */
  requests: RequestMetrics;
  /** Overall system status */
  status: string;
  /** Dashboard snapshot timestamp */
  timestamp: string;
}

/**
 * Filter stage counts for debugging (optional)
 */
export type NLSearchMetaFilterStats = { [key: string]: number } | null;

/**
 * Details for parse pipeline stage.
 */
export interface ParseStageDetails {
  /** Parsing mode used (regex/llm) */
  mode: string;
}

/**
 * Details for skipped pipeline stages.
 */
export interface SkippedStageDetails {
  /** Reason the stage was skipped */
  reason: string;
}

/**
 * Timing and status for a pipeline stage.
 */
export interface PipelineStage {
  /** Type-specific stage details */
  details?:
    | CacheCheckStageDetails
    | Burst1StageDetails
    | ParseStageDetails
    | EmbeddingStageDetails
    | LocationResolutionStageDetails
    | Burst2StageDetails
    | HydrateStageDetails
    | BuildResponseStageDetails
    | SkippedStageDetails
    | null;
  /**
   * Stage duration in ms
   * @minimum 0
   */
  duration_ms: number;
  /** Stage name */
  name: string;
  /** Stage status */
  status: StageStatus;
}

/**
 * Full diagnostics for admin tooling.
 */
export interface SearchDiagnostics {
  /**
   * Candidates after availability filter
   * @minimum 0
   */
  after_availability_filter: number;
  /**
   * Candidates after location filter
   * @minimum 0
   */
  after_location_filter: number;
  /**
   * Candidates after price filter
   * @minimum 0
   */
  after_price_filter: number;
  /**
   * Candidates after text search
   * @minimum 0
   */
  after_text_search: number;
  /**
   * Candidates after vector search
   * @minimum 0
   */
  after_vector_search: number;
  /** Budget tracking info */
  budget: BudgetInfo;
  /** Whether cache was hit */
  cache_hit: boolean;
  /** Whether query embedding was used */
  embedding_used: boolean;
  /**
   * Final result count
   * @minimum 0
   */
  final_results: number;
  /**
   * Initial candidate count
   * @minimum 0
   */
  initial_candidates: number;
  /** Location resolution details */
  location_resolution?: LocationResolutionInfo | null;
  /** Parsing mode used */
  parsing_mode: string;
  /** Pipeline stage timings */
  pipeline_stages?: PipelineStage[];
  /**
   * Total latency in ms
   * @minimum 0
   */
  total_latency_ms: number;
  /** Whether vector search was used */
  vector_search_used: boolean;
}

/**
 * Parsed query details for response transparency.
 */
export interface ParsedQueryInfo {
  /** Detected audience hint */
  audience_hint?: string | null;
  /** Extracted date */
  date?: string | null;
  /** Lesson type filter: 'online', 'in_person', or 'any' */
  lesson_type?: string | null;
  /** Extracted location */
  location?: string | null;
  /** Extracted max price */
  max_price?: number | null;
  /** Extracted service query */
  service_query: string;
  /** Detected skill level */
  skill_level?: string | null;
  /** Extracted time constraint */
  time_after?: string | null;
  /** Extracted time constraint end */
  time_before?: string | null;
  /** Detected urgency level */
  urgency?: string | null;
  /** True if 'near me' detected and user location should be used */
  use_user_location?: boolean;
}

/**
 * Search response metadata.
 */
export interface NLSearchMeta {
  /** Whether response was from cache */
  cache_hit?: boolean;
  /** Typo-corrected query if different */
  corrected_query?: string | null;
  /** Reasons for degradation */
  degradation_reasons?: string[];
  /** Whether search was degraded */
  degraded?: boolean;
  /** Detailed diagnostics for admin tooling */
  diagnostics?: SearchDiagnostics | null;
  /** Filter stage counts for debugging (optional) */
  filter_stats?: NLSearchMetaFilterStats;
  /** Filters applied during constraint filtering */
  filters_applied?: string[];
  /**
   * Total search latency in ms
   * @minimum 0
   */
  latency_ms: number;
  /**
   * Requested limit
   * @minimum 1
   */
  limit: number;
  /** User-facing message for location-related issues */
  location_message?: string | null;
  /** True if the location text could not be resolved */
  location_not_found?: boolean;
  /** Resolved location name for display (if available) */
  location_resolved?: string | null;
  /** Parsed query details */
  parsed: ParsedQueryInfo;
  /** Parsing mode used (regex/llm) */
  parsing_mode?: string;
  /** Original search query */
  query: string;
  /** True if 'near me' was requested but user has no saved address */
  requires_address?: boolean;
  /** True if 'near me' was requested but user is not authenticated */
  requires_auth?: boolean;
  /** Search query ID for click tracking */
  search_query_id?: string | null;
  /** Operations skipped during degradation */
  skipped_operations?: string[];
  /** User-facing message when constraints are relaxed */
  soft_filter_message?: string | null;
  /** Whether soft filtering/relaxation was applied */
  soft_filtering_used?: boolean;
  /**
   * Total results returned
   * @minimum 0
   */
  total_results: number;
}

/**
 * A service that matched the search query.
 */
export interface ServiceMatch {
  /** Service description */
  description?: string | null;
  /** Service name */
  name: string;
  /** Instructor teaches at their own location for this service */
  offers_at_location?: boolean | null;
  /** Instructor offers online lessons for this service */
  offers_online?: boolean | null;
  /** Instructor travels to student for this service */
  offers_travel?: boolean | null;
  /**
   * Hourly rate in dollars
   * @minimum 0
   */
  price_per_hour: number;
  /**
   * Semantic match score
   * @minimum 0
   * @maximum 1
   */
  relevance_score: number;
  /** Service catalog ID (for click tracking) */
  service_catalog_id: string;
  /** Instructor service ID (for booking) */
  service_id: string;
}

/**
 * Aggregated rating info for an instructor.
 */
export interface RatingSummary {
  /** Average rating (None if no reviews) */
  average?: number | null;
  /**
   * Number of reviews
   * @minimum 0
   */
  count?: number;
}

/**
 * Single instructor result with all embedded data (eliminates N+1).
 */
export interface NLSearchResultItem {
  /** Best matching service */
  best_match: ServiceMatch;
  /** Service area names */
  coverage_areas?: string[];
  /** Distance from searched location in kilometers (optional) */
  distance_km?: number | null;
  /** Distance from searched location in miles (optional) */
  distance_mi?: number | null;
  /** Instructor profile info */
  instructor: InstructorSummary;
  /** Instructor user ID */
  instructor_id: string;
  /** Other matching services (max 3) */
  other_matches?: ServiceMatch[];
  /** Aggregated rating info */
  rating: RatingSummary;
  /**
   * Best match relevance score
   * @minimum 0
   * @maximum 1
   */
  relevance_score: number;
  /**
   * Total number of matching services
   * @minimum 1
   */
  total_matching_services?: number;
}

/**
 * Complete NL search response with instructor-level results.
 */
export interface NLSearchResponse {
  /** Search metadata */
  meta: NLSearchMeta;
  /** Instructor-level search results */
  results: NLSearchResultItem[];
}

/**
 * Response payload for lightweight NYC ZIP verification.
 */
export interface NYCZipCheckResponse {
  borough?: string | null;
  is_nyc: boolean;
}

/**
 * Single neighborhood entry with optional borough metadata.
 */
export interface NeighborhoodItem {
  borough?: string | null;
  code?: string | null;
  id: string;
  name: string;
}

/**
 * Paginated list of neighborhoods.
 */
export interface NeighborhoodsListResponse {
  items: NeighborhoodItem[];
  page?: number | null;
  per_page?: number | null;
  total: number;
}

/**
 * Response for next available slot endpoint.
 */
export interface NextAvailableSlotResponse {
  /** Date of the next available slot (YYYY-MM-DD) */
  date?: string | null;
  /** Duration in minutes */
  duration_minutes?: number | null;
  /** End time (HH:MM:SS) */
  end_time?: string | null;
  found: boolean;
  /** Message when no slot is found */
  message?: string | null;
  /** Start time (HH:MM:SS) */
  start_time?: string | null;
}

/**
 * Schema for disputing a no-show report.
 */
export interface NoShowDisputeRequest {
  /**
   * @minLength 10
   * @maxLength 500
   */
  reason: string;
}

/**
 * Response for disputing a no-show report.
 */
export interface NoShowDisputeResponse {
  booking_id: string;
  disputed: boolean;
  requires_platform_review: boolean;
  success: boolean;
}

export type NoShowReportRequestNoShowType =
  (typeof NoShowReportRequestNoShowType)[keyof typeof NoShowReportRequestNoShowType];

export const NoShowReportRequestNoShowType = {
  instructor: 'instructor',
  student: 'student',
} as const;

/**
 * Schema for reporting a no-show.
 */
export interface NoShowReportRequest {
  no_show_type: NoShowReportRequestNoShowType;
  reason?: string | null;
}

/**
 * Response for reporting a no-show.
 */
export interface NoShowReportResponse {
  booking_id: string;
  dispute_window_ends: string;
  no_show_type: string;
  payment_status: string;
  success: boolean;
}

export type NotificationResponseData = { [key: string]: unknown } | null;

/**
 * Notification inbox entry.
 */
export interface NotificationResponse {
  body: string | null;
  category: string;
  created_at: string;
  data: NotificationResponseData;
  id: string;
  read_at: string | null;
  title: string;
  type: string;
}

/**
 * Paginated notification response.
 */
export interface NotificationListResponse {
  notifications: NotificationResponse[];
  total: number;
  unread_count: number;
}

/**
 * Simple status response for notification actions.
 */
export interface NotificationStatusResponse {
  message?: string | null;
  success: boolean;
}

/**
 * Unread notification count response.
 */
export interface NotificationUnreadCountResponse {
  /** @minimum 0 */
  unread_count: number;
}

/**
 * Search candidate for observability tracking.
 */
export interface ObservabilityCandidate {
  id?: string | null;
  lexical_score?: number | null;
  position?: number | null;
  score?: number | null;
  service_catalog_id?: string | null;
  source?: string | null;
  vector_score?: number | null;
}

export interface OnboardingResponse {
  /** Stripe connected account ID */
  account_id: string;
  /** Whether onboarding was already completed */
  already_onboarded: boolean;
  /** URL for onboarding flow */
  onboarding_url: string;
}

export interface OnboardingStatusResponse {
  /** Whether account can accept payments */
  charges_enabled: boolean;
  /** Whether required details are submitted */
  details_submitted?: boolean;
  /** Whether instructor has a connected account */
  has_account: boolean;
  /** Whether onboarding is complete */
  onboarding_completed: boolean;
  /** Whether account can receive payouts */
  payouts_enabled?: boolean;
  /** Outstanding requirements */
  requirements?: string[];
}

export type OverridePayloadAction =
  (typeof OverridePayloadAction)[keyof typeof OverridePayloadAction];

export const OverridePayloadAction = {
  approve: 'approve',
  reject: 'reject',
} as const;

export interface OverridePayload {
  action: OverridePayloadAction;
}

export interface PaginatedResponseBookingResponse {
  /** Whether there's a next page */
  has_next: boolean;
  /** Whether there's a previous page */
  has_prev: boolean;
  /** List of items */
  items: BookingResponse[];
  /**
   * Current page number
   * @minimum 1
   */
  page?: number;
  /**
   * Items per page
   * @minimum 1
   * @maximum 100
   */
  per_page?: number;
  /** Total number of items */
  total: number;
}

export interface PaginatedResponseInstructorProfileResponse {
  /** Whether there's a next page */
  has_next: boolean;
  /** Whether there's a previous page */
  has_prev: boolean;
  /** List of items */
  items: InstructorProfileResponse[];
  /**
   * Current page number
   * @minimum 1
   */
  page?: number;
  /**
   * Items per page
   * @minimum 1
   * @maximum 100
   */
  per_page?: number;
  /** Total number of items */
  total: number;
}

/**
 * Simplified response for upcoming bookings widget.

Privacy-aware: instructor_last_name shows last initial for students,
full last name for instructors viewing their own bookings.
 */
export interface UpcomingBookingResponse {
  booking_date: string;
  end_time: string;
  id: string;
  instructor_first_name: string;
  instructor_id: string;
  instructor_last_name: string;
  meeting_location: string | null;
  service_name: string;
  start_time: string;
  student_first_name: string;
  student_last_name: string;
  total_price: number;
}

export interface PaginatedResponseUpcomingBookingResponse {
  /** Whether there's a next page */
  has_next: boolean;
  /** Whether there's a previous page */
  has_prev: boolean;
  /** List of items */
  items: UpcomingBookingResponse[];
  /**
   * Current page number
   * @minimum 1
   */
  page?: number;
  /**
   * Items per page
   * @minimum 1
   * @maximum 100
   */
  per_page?: number;
  /** Total number of items */
  total: number;
}

export interface PasswordChangeRequest {
  /** @minLength 6 */
  current_password: string;
  /** @minLength 8 */
  new_password: string;
}

export interface PasswordChangeResponse {
  message: string;
}

/**
 * Request model for confirming password reset with new password
 */
export interface PasswordResetConfirm {
  /** @minLength 8 */
  new_password: string;
  token: string;
}

/**
 * Request model for initiating password reset
 */
export interface PasswordResetRequest {
  email: string;
}

export interface PasswordResetResponse {
  message: string;
}

export interface PasswordResetVerifyResponse {
  [key: string]: unknown;
}

/**
 * Response for manually triggered payment health check.
 */
export interface PaymentHealthCheckTriggerResponse {
  /** Status message */
  message: string;
  /** Trigger status */
  status: string;
  /** Celery task ID */
  task_id: string;
  /** Trigger timestamp */
  timestamp: string;
}

/**
 * Payment metrics breakdown
 */
export type PaymentHealthResponseMetrics = { [key: string]: number };

/**
 * Payment status counts
 */
export type PaymentHealthResponsePaymentStats = { [key: string]: number };

/**
 * Recent payment event counts
 */
export type PaymentHealthResponseRecentEvents = { [key: string]: number };

/**
 * Payment system health monitoring response.
 */
export interface PaymentHealthResponse {
  /** Current payment system alerts */
  alerts: string[];
  /** Payment metrics breakdown */
  metrics: PaymentHealthResponseMetrics;
  /** Minutes since last successful auth */
  minutes_since_last_auth?: number | null;
  /** Number of overdue authorizations */
  overdue_authorizations: number;
  /** Payment status counts */
  payment_stats: PaymentHealthResponsePaymentStats;
  /** Recent payment event counts */
  recent_events: PaymentHealthResponseRecentEvents;
  /** Payment system health status (healthy/warning/critical) */
  status: string;
  /** Health check timestamp */
  timestamp: string;
}

/**
 * Response model for payment method information.
 */
export interface PaymentMethodResponse {
  /** Card brand (visa, mastercard, etc.) */
  brand: string;
  /** When the payment method was added */
  created_at: string;
  /** Payment method ID */
  id: string;
  /** Whether this is the default payment method */
  is_default: boolean;
  /** Last 4 digits of card */
  last4: string;
}

/**
 * Response for payment pipeline status endpoint.
 */
export interface PaymentPipelineResponse {
  authorized: number;
  captured: number;
  checked_at: string;
  failed: number;
  instructor_payouts_cents: number;
  net_revenue_cents: number;
  overdue_authorizations: number;
  overdue_captures: number;
  pending_authorization: number;
  pending_capture: number;
  platform_fees_cents: number;
  refunded: number;
  total_captured_cents: number;
  total_refunded_cents: number;
}

export interface PayoutSummary {
  /** Amount in cents */
  amount_cents: number;
  /** Expected arrival date */
  arrival_date?: string | null;
  /** When the payout was created */
  created_at: string;
  /** Failure code if payout failed */
  failure_code?: string | null;
  /** Failure message if payout failed */
  failure_message?: string | null;
  /** Payout ID (Stripe) */
  id: string;
  /** Payout status (pending, in_transit, paid, failed, canceled) */
  status: string;
}

export interface PayoutHistoryResponse {
  /** Number of payouts */
  payout_count?: number;
  /** List of payouts */
  payouts?: PayoutSummary[];
  /** Total amount successfully paid out */
  total_paid_cents?: number;
  /** Total amount pending payout */
  total_pending_cents?: number;
}

/**
 * Stripe payout schedule settings that were applied
 */
export type PayoutScheduleResponseSettings = { [key: string]: unknown } | null;

export interface PayoutScheduleResponse {
  /** Stripe connected account identifier */
  account_id?: string | null;
  /** Whether the schedule update succeeded */
  ok: boolean;
  /** Stripe payout schedule settings that were applied */
  settings?: PayoutScheduleResponseSettings;
}

/**
 * An instructor with pending payout.
 */
export interface PendingPayoutItem {
  completed_lessons: number;
  instructor_id: string;
  instructor_name: string;
  oldest_pending_date: string;
  pending_amount_cents: number;
  stripe_connected: boolean;
}

/**
 * Response for pending payouts endpoint.
 */
export interface PendingPayoutsResponse {
  checked_at: string;
  instructor_count: number;
  payouts: PendingPayoutItem[];
  total_pending_cents: number;
}

/**
 * Cache statistics for performance metrics.
 */
export interface PerformanceCacheStats {
  /** Cache hit rate percentage */
  hit_rate?: string;
  /** Cache hits */
  hits?: number;
  /** Cache misses */
  misses?: number;
}

/**
 * Database metrics for performance monitoring.
 */
export interface PerformanceDatabaseMetrics {
  /** Active database connections */
  active_connections?: number;
  /** Connection pool status */
  pool_status: DatabasePoolStatus;
}

/**
 * Search performance metrics.
 */
export interface PerformanceMetrics {
  /** Average results per search */
  avg_results_per_search: number;
  /** Most effective search type */
  most_effective_type: string;
  /** Percentage of searches with zero results */
  zero_result_rate: number;
}

/**
 * System resource metrics
 */
export type PerformanceMetricsResponseSystem = { [key: string]: number };

/**
 * Operation counts by type
 */
export type ServiceMetricsOperations = { [key: string]: number };

/**
 * Service-level performance metrics.
 */
export interface ServiceMetrics {
  /** Cache operations performed */
  cache_operations: number;
  /** Database operations performed */
  db_operations: number;
  /** Operation counts by type */
  operations: ServiceMetricsOperations;
  /** Total operations performed */
  total_operations: number;
}

/**
 * Comprehensive performance metrics response.
 */
export interface PerformanceMetricsResponse {
  /** Availability service metrics */
  availability_service: ServiceMetrics;
  /** Booking service metrics */
  booking_service: ServiceMetrics;
  /** Cache statistics */
  cache: PerformanceCacheStats;
  /** Conflict checker metrics */
  conflict_checker: ServiceMetrics;
  /** Database connection metrics */
  database: PerformanceDatabaseMetrics;
  /** System resource metrics */
  system: PerformanceMetricsResponseSystem;
}

export interface PhoneUpdateRequest {
  /** Phone number in E.164 format */
  phone_number: string;
}

export interface PhoneUpdateResponse {
  phone_number?: string | null;
  verified?: boolean;
}

export interface PhoneVerifyConfirmRequest {
  /**
   * @minLength 6
   * @maxLength 6
   */
  code: string;
}

export interface PhoneVerifyResponse {
  sent?: boolean;
  verified?: boolean;
}

export interface PlaceDetails {
  city?: string | null;
  country?: string | null;
  formatted_address: string;
  latitude: number;
  longitude: number;
  postal_code?: string | null;
  provider_id: string;
  state?: string | null;
  street_name?: string | null;
  street_number?: string | null;
}

export interface PlatformFees {
  /**
   * Platform fee for founding instructors
   * @exclusiveMinimum 0
   * @exclusiveMaximum 1
   */
  founding_instructor: number;
  /**
   * Student booking protection fee
   * @exclusiveMinimum 0
   * @exclusiveMaximum 1
   */
  student_booking_fee: number;
  /**
   * Entry tier platform fee
   * @exclusiveMinimum 0
   * @exclusiveMaximum 1
   */
  tier_1: number;
  /**
   * Second tier platform fee
   * @exclusiveMinimum 0
   * @exclusiveMaximum 1
   */
  tier_2: number;
  /**
   * Third tier platform fee
   * @exclusiveMinimum 0
   * @exclusiveMaximum 1
   */
  tier_3: number;
}

/**
 * A popular search query.
 */
export interface PopularQueryItem {
  /** Average latency in ms */
  avg_latency_ms?: number | null;
  /**
   * Average results for this query
   * @minimum 0
   */
  avg_results: number;
  /**
   * Number of times searched
   * @minimum 1
   */
  count: number;
  /** Search query text */
  query: string;
}

/**
 * List of popular search queries.
 */
export interface PopularQueriesResponse {
  /** Popular queries */
  queries: PopularQueryItem[];
}

/**
 * Popular search query data.
 */
export interface PopularSearch {
  /** Average number of results returned */
  average_results: number;
  /** Search query text */
  query: string;
  /** Number of times searched */
  search_count: number;
  /** Number of unique users who searched */
  unique_users: number;
}

/**
 * Popular searches response.
 */
export type PopularSearchesResponse = PopularSearch[];

/**
 * Data for the one-time referral popup after go-live.
 */
export interface PopupDataResponse {
  bonus_amount_cents: number;
  founding_spots_remaining: number;
  is_founding_phase: boolean;
  referral_code: string;
  referral_link: string;
}

/**
 * Single preference response.
 */
export interface PreferenceResponse {
  category: string;
  channel: string;
  enabled: boolean;
  id: string;
  locked: boolean;
}

/**
 * Single preference update for bulk requests.
 */
export interface PreferenceUpdate {
  category: string;
  channel: string;
  enabled: boolean;
}

export type PreferencesByCategoryLearningTips = { [key: string]: boolean };

export type PreferencesByCategoryLessonUpdates = { [key: string]: boolean };

export type PreferencesByCategoryMessages = { [key: string]: boolean };

export type PreferencesByCategoryPromotional = { [key: string]: boolean };

export type PreferencesByCategoryReviews = { [key: string]: boolean };

export type PreferencesByCategorySystemUpdates = { [key: string]: boolean };

/**
 * Preferences grouped by category for frontend consumption.
 */
export interface PreferencesByCategory {
  learning_tips: PreferencesByCategoryLearningTips;
  lesson_updates: PreferencesByCategoryLessonUpdates;
  messages: PreferencesByCategoryMessages;
  promotional: PreferencesByCategoryPromotional;
  reviews: PreferencesByCategoryReviews;
  system_updates: PreferencesByCategorySystemUpdates;
}

export interface PriceFloorConfig {
  /**
   * Minimum cents for in-person private lessons
   * @minimum 0
   */
  private_in_person: number;
  /**
   * Minimum cents for remote private lessons
   * @minimum 0
   */
  private_remote: number;
}

export interface TierConfig {
  /** Maximum sessions for this tier (inclusive); null for open-ended */
  max?: number | null;
  /**
   * Minimum completed sessions for this tier
   * @minimum 0
   */
  min: number;
  /**
   * Commission percentage expressed as decimal
   * @exclusiveMinimum 0
   * @exclusiveMaximum 1
   */
  pct: number;
}

export interface StudentCreditCycle {
  /**
   * Credit cents issued for $10 milestone
   * @minimum 0
   */
  cents10: number;
  /**
   * Credit cents issued for $20 milestone
   * @minimum 0
   */
  cents20: number;
  /**
   * Length of credit cycle in sessions
   * @exclusiveMinimum 0
   */
  cycle_len: number;
  /**
   * Modulo offset for $10 credit milestone
   * @minimum 0
   */
  mod10: number;
  /**
   * Modulo offset for $20 credit milestone
   * @minimum 0
   */
  mod20: number;
}

export interface PricingConfig {
  /**
   * Maximum number of founding instructors
   * @exclusiveMinimum 0
   */
  founding_instructor_cap?: number;
  /**
   * Platform fee percentage for founding instructors
   * @exclusiveMinimum 0
   * @exclusiveMaximum 1
   */
  founding_instructor_rate_pct?: number;
  /**
   * Search ranking multiplier for founding instructors
   * @exclusiveMinimum 0
   */
  founding_search_boost?: number;
  instructor_tiers: TierConfig[];
  price_floor_cents: PriceFloorConfig;
  student_credit_cycle: StudentCreditCycle;
  /**
   * Student booking protection fee as decimal
   * @exclusiveMinimum 0
   * @exclusiveMaximum 1
   */
  student_fee_pct: number;
  /**
   * Rolling window for tier activity
   * @exclusiveMinimum 0
   */
  tier_activity_window_days: number;
  /**
   * Inactivity period before full reset
   * @exclusiveMinimum 0
   */
  tier_inactivity_reset_days: number;
  /**
   * Maximum tiers to drop per evaluation
   * @minimum 0
   */
  tier_stepdown_max: number;
}

/**
 * Alias for request payload compatibility.
 */
export interface PricingConfigPayload {
  /**
   * Maximum number of founding instructors
   * @exclusiveMinimum 0
   */
  founding_instructor_cap?: number;
  /**
   * Platform fee percentage for founding instructors
   * @exclusiveMinimum 0
   * @exclusiveMaximum 1
   */
  founding_instructor_rate_pct?: number;
  /**
   * Search ranking multiplier for founding instructors
   * @exclusiveMinimum 0
   */
  founding_search_boost?: number;
  instructor_tiers: TierConfig[];
  price_floor_cents: PriceFloorConfig;
  student_credit_cycle: StudentCreditCycle;
  /**
   * Student booking protection fee as decimal
   * @exclusiveMinimum 0
   * @exclusiveMaximum 1
   */
  student_fee_pct: number;
  /**
   * Rolling window for tier activity
   * @exclusiveMinimum 0
   */
  tier_activity_window_days: number;
  /**
   * Inactivity period before full reset
   * @exclusiveMinimum 0
   */
  tier_inactivity_reset_days: number;
  /**
   * Maximum tiers to drop per evaluation
   * @minimum 0
   */
  tier_stepdown_max: number;
}

export interface PricingConfigResponse {
  config: PricingConfig;
  updated_at?: string | null;
}

export type PricingPreviewInLocationType =
  (typeof PricingPreviewInLocationType)[keyof typeof PricingPreviewInLocationType];

export const PricingPreviewInLocationType = {
  student_location: 'student_location',
  instructor_location: 'instructor_location',
  online: 'online',
  neutral_location: 'neutral_location',
} as const;

export interface PricingPreviewIn {
  /** @minimum 0 */
  applied_credit_cents: number;
  /**
   * @minLength 1
   * @pattern ^\d{4}-\d{2}-\d{2}$
   */
  booking_date: string;
  /** @minLength 1 */
  instructor_id: string;
  /** @minLength 1 */
  instructor_service_id: string;
  location_type: PricingPreviewInLocationType;
  meeting_location?: string | null;
  /** @exclusiveMinimum 0 */
  selected_duration: number;
  /**
   * @minLength 1
   * @pattern ^\d{2}:\d{2}$
   */
  start_time: string;
}

export interface PricingPreviewOut {
  /** @minimum 0 */
  application_fee_cents: number;
  /** @minimum 0 */
  base_price_cents: number;
  /** @minimum 0 */
  credit_applied_cents: number;
  /** @minimum 0 */
  instructor_platform_fee_cents: number;
  /**
   * @minimum 0
   * @maximum 1
   */
  instructor_tier_pct: number;
  line_items: LineItem[];
  /** @minimum 0 */
  student_fee_cents: number;
  /** @minimum 0 */
  student_pay_cents: number;
  /** @minimum 0 */
  target_instructor_payout_cents: number;
  /** @minimum 0 */
  top_up_transfer_cents: number;
}

/**
 * Privacy and retention statistics returned by get_privacy_statistics.
 */
export interface PrivacyStatistics {
  /** Number of active users */
  active_users: number;
  /** Number of search event records */
  search_event_records: number;
  /** Search events eligible for deletion based on retention policy */
  search_events_eligible_for_deletion?: number | null;
  /** Number of search history records */
  search_history_records: number;
  /** Total number of bookings */
  total_bookings: number;
  /** Total number of users */
  total_users: number;
}

export interface PrivacyStatisticsResponse {
  /** Privacy and retention statistics */
  statistics: PrivacyStatistics;
  /** Status of the request */
  status: string;
}

/**
 * Problematic search query with low results.
 */
export interface ProblematicQuery {
  /** Average results returned */
  avg_results: number;
  /** Number of times searched */
  count: number;
  /** Search query text */
  query: string;
}

export type ProfilePictureUrlsResponseUrls = { [key: string]: string | null };

export interface ProfilePictureUrlsResponse {
  urls: ProfilePictureUrlsResponseUrls;
}

/**
 * Response payload for proxied uploads in local development.
 */
export interface ProxyUploadResponse {
  ok: boolean;
  url?: string | null;
}

/**
 * Summary of availability for a single date.
 */
export interface PublicAvailabilitySummaryEntry {
  /** Afternoon availability */
  afternoon_available?: boolean;
  /** Date in YYYY-MM-DD format */
  date: string;
  /** Evening availability */
  evening_available?: boolean;
  /** Morning availability */
  morning_available?: boolean;
  /** Total available hours */
  total_hours?: number;
}

export interface PublicConfigResponse {
  fees: PlatformFees;
  updated_at?: string | null;
}

/**
 * A bookable time slot for public viewing.

Note: No slot IDs exposed - frontend should use instructor_id + date + times
for booking requests.
 */
export interface PublicTimeSlot {
  /** End time in HH:MM format */
  end_time: string;
  /** Start time in HH:MM format */
  start_time: string;
}

/**
 * Availability for a single day.
 */
export interface PublicDayAvailability {
  /** List of available time slots for booking */
  available_slots?: PublicTimeSlot[];
  /** Date in YYYY-MM-DD format */
  date: string;
  /** Whether this date is completely unavailable */
  is_blackout?: boolean;
}

/**
 * Availability indexed by date string (YYYY-MM-DD) - only in full detail
 */
export type PublicInstructorAvailabilityAvailabilityByDate = {
  [key: string]: PublicDayAvailability;
} | null;

/**
 * Summary of availability by date - only in summary detail
 */
export type PublicInstructorAvailabilityAvailabilitySummary = {
  [key: string]: PublicAvailabilitySummaryEntry;
} | null;

/**
 * Public availability response for an instructor.

This is the main response schema for the public endpoint.
Provides all necessary information for students to view
availability and make booking decisions.

The detail_level field indicates what data is populated:
- "minimal": Only has_availability and earliest_available_date
- "summary": Includes availability_summary but not specific slots
- "full": Complete availability_by_date with all time slots
 */
export interface PublicInstructorAvailability {
  /** Availability indexed by date string (YYYY-MM-DD) - only in full detail */
  availability_by_date?: PublicInstructorAvailabilityAvailabilityByDate;
  /** Summary of availability by date - only in summary detail */
  availability_summary?: PublicInstructorAvailabilityAvailabilitySummary;
  /** Level of detail: minimal, summary, or full */
  detail_level: string;
  /** Earliest date with availability */
  earliest_available_date?: string | null;
  /** Whether any availability exists */
  has_availability?: boolean | null;
  /** Instructor's first name if privacy settings allow */
  instructor_first_name?: string | null;
  instructor_id: string;
  /** Instructor's last name initial for privacy */
  instructor_last_initial?: string | null;
  /** Instructor's timezone */
  timezone?: string;
  /** Number of days with availability */
  total_available_days?: number | null;
  /** Total number of bookable slots in the date range */
  total_available_slots?: number | null;
}

/**
 * Response after subscribe/unsubscribe.
 */
export interface PushStatusResponse {
  message: string;
  success: boolean;
}

/**
 * Request to subscribe to push notifications.
 */
export interface PushSubscribeRequest {
  /**
   * Auth secret
   * @maxLength 512
   */
  auth: string;
  /**
   * Push service endpoint URL
   * @maxLength 2048
   */
  endpoint: string;
  /**
   * Public encryption key
   * @maxLength 512
   */
  p256dh: string;
  /** Browser/device info */
  user_agent?: string | null;
}

/**
 * Push subscription details.
 */
export interface PushSubscriptionResponse {
  created_at: string;
  endpoint: string;
  id: string;
  user_agent: string | null;
}

/**
 * Request to unsubscribe from push notifications.
 */
export interface PushUnsubscribeRequest {
  /** Push service endpoint URL to remove */
  endpoint: string;
}

/**
 * Rate limit reset response.
 */
export interface RateLimitResetResponse {
  /** Number of limits reset */
  limits_reset: number;
  /** Result message */
  message: string;
  /** Pattern used for matching */
  pattern: string;
  /** Operation status */
  status: string;
}

/**
 * Breakdown by limit type
 */
export type RateLimitStatsBreakdownByType = { [key: string]: number };

/**
 * Rate-limited client information.
 */
export interface RateLimitedClient {
  /** Request count */
  count: number;
  /** Most rate-limited endpoint */
  endpoint: string;
  /** Client identifier key */
  key: string;
}

/**
 * Rate limit statistics.
 */
export interface RateLimitStats {
  /** Breakdown by limit type */
  breakdown_by_type: RateLimitStatsBreakdownByType;
  /** Top rate-limited clients */
  top_limited_clients: RateLimitedClient[];
  /** Total rate limit keys in Redis */
  total_keys: number;
}

/**
 * Rate limit test endpoint response.
 */
export interface RateLimitTestResponse {
  /** Test message */
  message: string;
  /** Rate limit information */
  note: string;
  /** Request timestamp */
  timestamp: string;
}

export interface RatingsBatchItem {
  instructor_id: string;
  rating: number | null;
  review_count: number;
}

export interface RatingsBatchRequest {
  /** @minItems 1 */
  instructor_ids: string[];
}

export interface RatingsBatchResponse {
  results: RatingsBatchItem[];
}

export interface ReactionRequest {
  emoji: string;
}

/**
 * Overall readiness status
 */
export type ReadyProbeResponseStatus =
  (typeof ReadyProbeResponseStatus)[keyof typeof ReadyProbeResponseStatus];

export const ReadyProbeResponseStatus = {
  ok: 'ok',
  db_not_ready: 'db_not_ready',
  cache_not_ready: 'cache_not_ready',
  degraded: 'degraded',
} as const;

export interface ReadyProbeResponse {
  /** Health status of the notification service (real-time messaging) */
  notifications_healthy?: boolean | null;
  /** Overall readiness status */
  status: ReadyProbeResponseStatus;
}

/**
 * Response for recent alerts endpoint.
 */
export interface RecentAlertsResponse {
  /** List of alert details */
  alerts: AlertDetail[];
  /** Number of hours included in the query */
  hours: number;
  /** Total number of alerts in the time period */
  total: number;
}

export type RecentBookingsResponseFiltersApplied = { [key: string]: unknown };

/**
 * Response for recent bookings endpoint.
 */
export interface RecentBookingsResponse {
  bookings: BookingListItem[];
  checked_at: string;
  count: number;
  filters_applied: RecentBookingsResponseFiltersApplied;
}

/**
 * Active Redis connection counts.
 */
export interface RedisActiveConnections {
  local_redis?: number;
  upstash?: number;
}

/**
 * Response for Redis Celery queues.
 */
export interface RedisCeleryQueuesResponse {
  queues: CeleryQueuesData;
}

/**
 * Redis client statistics.
 */
export interface RedisClientStats {
  blocked_clients?: number;
  connected_clients?: number;
}

export type RedisConnectionAuditDataEnvironmentVariables = { [key: string]: string };

/**
 * Redis connection info for a service.
 */
export interface RedisServiceConnection {
  host: string;
  type: string;
  url: string;
}

export type RedisConnectionAuditDataServiceConnections = { [key: string]: RedisServiceConnection };

/**
 * Redis connection audit data.
 */
export interface RedisConnectionAuditData {
  active_connections?: RedisActiveConnections;
  api_cache: string;
  celery_broker: string;
  environment_variables?: RedisConnectionAuditDataEnvironmentVariables;
  migration_status?: string;
  recommendation?: string;
  service_connections?: RedisConnectionAuditDataServiceConnections;
  upstash_detected?: boolean;
}

/**
 * Response for Redis connection audit.
 */
export interface RedisConnectionAuditResponse {
  connections: RedisConnectionAuditData[];
}

/**
 * Redis connection statistics.
 */
export interface RedisConnectionStats {
  evicted_keys?: number;
  expired_keys?: number;
  instantaneous_ops_per_sec?: number;
  rejected_connections?: number;
  total_commands_processed?: number;
  total_connections_received?: number;
}

export interface RedisFlushQueuesResponse {
  message: string;
  queues_flushed: string[];
}

/**
 * Response for Redis health check endpoint.
 */
export interface RedisHealthResponse {
  /** Whether Redis is connected */
  connected: boolean;
  /** Error message if unhealthy */
  error?: string | null;
  /** Health status (healthy/unhealthy) */
  status: string;
}

/**
 * Redis memory metrics.
 */
export interface RedisMemoryInfo {
  maxmemory_human?: string;
  mem_fragmentation_ratio?: number;
  used_memory_human?: string;
  used_memory_peak_human?: string;
  used_memory_rss_human?: string;
}

/**
 * Redis operation rate metrics.
 */
export interface RedisOperationMetrics {
  current_ops_per_sec?: number;
  estimated_daily_ops?: number;
  estimated_monthly_ops?: number;
}

/**
 * Redis server information.
 */
export interface RedisServerInfo {
  redis_version?: string;
  uptime_in_days?: number;
}

export type RedisStatsDataCelery = { [key: string]: number };

/**
 * Complete Redis statistics data.
 */
export interface RedisStatsData {
  celery?: RedisStatsDataCelery;
  clients?: RedisClientStats;
  memory?: RedisMemoryInfo;
  operations?: RedisOperationMetrics;
  server?: RedisServerInfo;
  stats?: RedisConnectionStats;
  status?: string;
}

/**
 * Response for Redis statistics.
 */
export interface RedisStatsResponse {
  stats: RedisStatsData;
}

/**
 * Response for Redis test endpoint.
 */
export interface RedisTestResponse {
  /** Number of connected clients */
  connected_clients?: number | null;
  /** Error message if failed */
  error?: string | null;
  /** Status message */
  message?: string | null;
  /** Ping result */
  ping?: boolean | null;
  /** Redis server version */
  redis_version?: string | null;
  /** Connection status */
  status: string;
  /** Redis uptime in seconds */
  uptime_seconds?: number | null;
}

export interface ReferralClaimRequest {
  code: string;
}

export interface ReferralClaimResponse {
  attributed: boolean;
  reason?: string | null;
}

export interface ReferralErrorResponse {
  reason: string;
}

/**
 * Which party receives the reward.
 */
export type RewardSide = (typeof RewardSide)[keyof typeof RewardSide];

export const RewardSide = {
  student: 'student',
  instructor: 'instructor',
} as const;

/**
 * Lifecycle of a reward.
 */
export type RewardStatus = (typeof RewardStatus)[keyof typeof RewardStatus];

export const RewardStatus = {
  pending: 'pending',
  unlocked: 'unlocked',
  redeemed: 'redeemed',
  void: 'void',
} as const;

/**
 * Serialized reward payload.
 */
export interface RewardOut {
  amount_cents: number;
  created_at: string;
  expire_ts?: string | null;
  id: string;
  side: RewardSide;
  status: RewardStatus;
  unlock_ts?: string | null;
}

export interface ReferralLedgerResponse {
  code: string;
  expiry_notice_days: number[];
  pending: RewardOut[];
  redeemed: RewardOut[];
  share_url: string;
  unlocked: RewardOut[];
}

export interface ReferralResolveResponse {
  code: string;
  ok: boolean;
  redirect: string;
}

/**
 * Details for a failed referral send attempt.
 */
export interface ReferralSendError {
  email: string;
  error: string;
}

/**
 * Request payload for sending referral invites.
 */
export interface ReferralSendRequest {
  /** List of recipient email addresses */
  emails: string[];
  /** Display name of the inviter (falls back to a generic label if omitted) */
  from_name?: string | null;
  /**
   * Referral link to include in the invite
   * @minLength 1
   */
  referral_link: string;
}

export interface ReferralSendResponse {
  /** List of errors for individual recipients */
  errors?: ReferralSendError[];
  /** Number of emails that failed to send */
  failed: number;
  /** Number of emails successfully sent */
  sent: number;
  /** Operation status ('ok' if the operation ran) */
  status: string;
}

/**
 * Stats for instructor's referral activity.
 */
export interface ReferralStatsResponse {
  completed_payouts: number;
  current_bonus_cents: number;
  founding_spots_remaining: number;
  is_founding_phase: boolean;
  pending_payouts: number;
  referral_code: string;
  referral_link: string;
  total_earned_cents: number;
  total_referred: number;
}

/**
 * Info about an instructor this user referred.
 */
export interface ReferredInstructorInfo {
  first_lesson_completed_at?: string | null;
  first_name: string;
  id: string;
  is_live: boolean;
  last_initial: string;
  payout_amount_cents?: number | null;
  payout_status: string;
  referred_at: string;
  went_live_at?: string | null;
}

/**
 * List of instructors referred by current user.
 */
export interface ReferredInstructorsResponse {
  instructors: ReferredInstructorInfo[];
  total_count: number;
}

/**
 * Search result distribution.
 */
export interface ResultDistribution {
  /** Searches with 1-5 results */
  '1_5_results': number;
  /** Searches with 6-10 results */
  '6_10_results': number;
  /** Searches with over 10 results */
  over_10_results: number;
  /** Searches with zero results */
  zero_results: number;
}

/**
 * Statistics from applying retention policies.
 */
export interface RetentionStats {
  /** Number of old bookings anonymized */
  old_bookings_anonymized?: number;
  /** Number of search events deleted */
  search_events_deleted?: number;
}

export interface RetentionPolicyResponse {
  /** Human-readable message */
  message: string;
  /** Statistics of retention policy application */
  stats: RetentionStats;
  /** Status of the retention policy application */
  status: string;
}

/**
 * Response for retrying payment authorization.
 */
export interface RetryPaymentResponse {
  error?: string | null;
  failure_count: number;
  payment_status: string;
  success: boolean;
}

export interface ReviewItem {
  created_at: string;
  id: string;
  instructor_service_id: string;
  rating: number;
  review_text: string | null;
  reviewer_display_name?: string | null;
}

export interface ReviewListPageResponse {
  has_next: boolean;
  has_prev: boolean;
  page: number;
  per_page: number;
  reviews: ReviewItem[];
  total: number;
}

export interface ReviewResponseModel {
  created_at: string;
  id: string;
  instructor_id: string;
  response_text: string;
  review_id: string;
}

export interface ReviewSubmitRequest {
  booking_id: string;
  /**
   * @minimum 1
   * @maximum 5
   */
  rating: number;
  review_text?: string | null;
  tip_amount_cents?: number | null;
}

export interface ReviewSubmitResponse {
  created_at: string;
  id: string;
  instructor_service_id: string;
  rating: number;
  review_text: string | null;
  reviewer_display_name?: string | null;
  tip_client_secret?: string | null;
  tip_status?: string | null;
}

/**
 * Request to save a payment method for a user.
 */
export interface SavePaymentMethodRequest {
  /** Stripe payment method ID */
  payment_method_id: string;
  /** Whether to set as default payment method */
  set_as_default?: boolean;
}

/**
 * Individual schedule item for availability creation.
 */
export interface ScheduleItem {
  /** ISO date string (YYYY-MM-DD) */
  date: string;
  /** End time (HH:MM or HH:MM:SS) */
  end_time: string;
  /** Start time (HH:MM or HH:MM:SS) */
  start_time: string;
}

/**
 * Metrics for a search type.
 */
export interface SearchTypeMetrics {
  /** Number of searches of this type */
  count: number;
  /** Percentage of total searches */
  percentage: number;
}

/**
 * Breakdown by search type
 */
export type SearchAnalyticsSummaryResponseSearchTypes = { [key: string]: SearchTypeMetrics };

/**
 * Search totals and deletion metrics.
 */
export interface SearchTotals {
  /** Number of deleted searches */
  deleted_searches: number;
  /** Percentage of searches deleted */
  deletion_rate: number;
  /** Total number of searches */
  total_searches: number;
  /** Total unique users (authenticated + guests) */
  total_users: number;
  /** Unique guest sessions */
  unique_guests: number;
  /** Unique authenticated users */
  unique_users: number;
}

/**
 * User type breakdown.
 */
export interface UserBreakdown {
  /** Number of authenticated users */
  authenticated: number;
  /** Number of guests who converted to users */
  converted_guests: number;
  /** Percentage of guests */
  guest_percentage: number;
  /** Number of guest sessions */
  guests: number;
  /** Percentage of authenticated users */
  user_percentage: number;
}

/**
 * Comprehensive search analytics summary.
 */
export interface SearchAnalyticsSummaryResponse {
  /** Conversion metrics */
  conversions: ConversionMetrics;
  /** Date range for analytics */
  date_range: DateRange;
  /** Search performance metrics */
  performance: PerformanceMetrics;
  /** Breakdown by search type */
  search_types: SearchAnalyticsSummaryResponseSearchTypes;
  /** Search totals and metrics */
  totals: SearchTotals;
  /** User breakdown by type */
  users: UserBreakdown;
}

/**
 * Request payload for logging a search click.
 */
export interface SearchClickRequest {
  /** Action type: view, book, message, favorite */
  action?: string;
  /** Instructor user ID that was clicked */
  instructor_id: string;
  /**
   * Position in search results (1-indexed)
   * @minimum 1
   */
  position: number;
  /** Search query ID from NL search */
  search_query_id: string;
  /** Service ID that was clicked (instructor_service_id) */
  service_id?: string | null;
}

/**
 * Response for logging a search click.
 */
export interface SearchClickResponse {
  /** ID of the logged click */
  click_id: string;
}

/**
 * Current search configuration.
 */
export interface SearchConfigResponse {
  /** Available embedding models */
  available_embedding_models: ModelOption[];
  /** Available parsing models */
  available_parsing_models: ModelOption[];
  /** Current embedding model */
  embedding_model: string;
  /**
   * Embedding timeout in ms
   * @minimum 500
   * @maximum 10000
   */
  embedding_timeout_ms: number;
  /** Current parsing model */
  parsing_model: string;
  /**
   * Parsing timeout in ms
   * @minimum 500
   * @maximum 10000
   */
  parsing_timeout_ms: number;
}

/**
 * Response after resetting configuration.
 */
export interface SearchConfigResetResponse {
  /** Current config after reset */
  config: SearchConfigResponse;
  /** Reset status */
  status: string;
}

/**
 * Request to update search configuration.
 */
export interface SearchConfigUpdate {
  /** New embedding model */
  embedding_model?: string | null;
  /** New embedding timeout in ms */
  embedding_timeout_ms?: number | null;
  /** New parsing model */
  parsing_model?: string | null;
  /** New parsing timeout in ms */
  parsing_timeout_ms?: number | null;
}

/**
 * Context about where the search originated.
 */
export interface SearchContext {
  page_origin?: string | null;
  referrer?: string | null;
  session_search_count?: number | null;
  viewport_height?: number | null;
  viewport_width?: number | null;
}

/**
 * Search effectiveness metrics.
 */
export interface SearchEffectiveness {
  /** Average results per search */
  avg_results_per_search: number;
  /** Median results per search */
  median_results: number;
  /** Number of searches with at least one result */
  searches_with_results: number;
  /** Percentage of searches with zero results */
  zero_result_rate: number;
}

/**
 * Filters applied to instructor search.
 */
export interface SearchFiltersApplied {
  age_group?: string | null;
  max_price?: number | null;
  min_price?: number | null;
  search?: string | null;
  service_area_boroughs?: string[] | null;
  service_catalog_id?: string | null;
}

/**
 * Cache TTL settings
 */
export type SearchHealthCacheTtls = { [key: string]: number } | null;

/**
 * Cache health status.
 */
export interface SearchHealthCache {
  /** Whether cache is available */
  available: boolean;
  /** Error message if unavailable */
  error?: string | null;
  /** Current cache version */
  response_cache_version?: number | null;
  /** Cache TTL settings */
  ttls?: SearchHealthCacheTtls;
}

/**
 * Health status of search components.
 */
export interface SearchHealthComponents {
  /** Cache health status */
  cache: SearchHealthCache;
  /** Embedding circuit breaker state */
  embedding_circuit: string;
  /** Parsing circuit breaker state */
  parsing_circuit: string;
}

/**
 * Health check response for search service.
 */
export interface SearchHealthResponse {
  /** Component health details */
  components: SearchHealthComponents;
  /** Overall health status */
  status: string;
}

/**
 * Schema for creating search history.
 */
export interface SearchHistoryCreate {
  /** Device context from frontend including screen size, connection type, etc. */
  device_context?: DeviceContext | null;
  /** UUID for guest session tracking */
  guest_session_id?: string | null;
  /** Optional top-N candidate objects for observability. Each item may include: position, service_catalog_id (or id), score, vector_score, lexical_score, source. */
  observability_candidates?: ObservabilityCandidate[] | null;
  /** Number of results returned */
  results_count?: number | null;
  /** Additional context like page origin, viewport size, etc. */
  search_context?: SearchContext | null;
  /**
   * The search query string
   * @minLength 1
   */
  search_query: string;
  /** Type of search: natural_language, category, service_pill, filter, or search_history */
  search_type?: string;
}

/**
 * Schema for search history responses.
 */
export interface SearchHistoryResponse {
  /** When the search was first performed */
  first_searched_at: string;
  /** UUID for guest session tracking */
  guest_session_id?: string | null;
  /** Unique identifier for the search history entry */
  id: string;
  /** When the search was last performed */
  last_searched_at: string;
  /** Number of results returned */
  results_count?: number | null;
  /** Number of times this search was performed */
  search_count: number;
  /** ID of the associated search event for tracking interactions */
  search_event_id?: string | null;
  /**
   * The search query string
   * @minLength 1
   */
  search_query: string;
  /** Type of search: natural_language, category, service_pill, filter, or search_history */
  search_type?: string;
}

/**
 * Response for recording search interaction.
 */
export interface SearchInteractionResponse {
  interaction_id: string;
  message?: string;
  status?: string;
  success: boolean;
}

/**
 * Aggregate search metrics response.
 */
export interface SearchMetricsResponse {
  /**
   * Average latency in ms
   * @minimum 0
   */
  avg_latency_ms: number;
  /**
   * Average results per search
   * @minimum 0
   */
  avg_results: number;
  /**
   * Cache hit rate
   * @minimum 0
   * @maximum 1
   */
  cache_hit_rate: number;
  /**
   * Search degradation rate
   * @minimum 0
   * @maximum 1
   */
  degradation_rate: number;
  /**
   * 50th percentile latency
   * @minimum 0
   */
  p50_latency_ms: number;
  /**
   * 95th percentile latency
   * @minimum 0
   */
  p95_latency_ms: number;
  /**
   * Total number of searches
   * @minimum 0
   */
  total_searches: number;
  /**
   * Rate of zero-result searches
   * @minimum 0
   * @maximum 1
   */
  zero_result_rate: number;
}

/**
 * Pagination metadata for search results.
 */
export interface SearchPagination {
  count?: number;
  limit?: number;
  skip?: number;
}

/**
 * Search performance metrics response.
 */
export interface SearchPerformanceResponse {
  /** Search effectiveness metrics */
  effectiveness: SearchEffectiveness;
  /** Queries with poor results */
  problematic_queries: ProblematicQuery[];
  /** Distribution of search results */
  result_distribution: ResultDistribution;
}

export interface SearchRatingResponse {
  is_service_specific: boolean;
  primary_rating: number | null;
  review_count: number;
}

/**
 * Search referrer page data.
 */
export interface SearchReferrer {
  /** Referrer page URL or path */
  page: string;
  /** Number of searches from this page */
  search_count: number;
  /** Types of searches from this page */
  search_types: string[];
  /** Number of unique sessions */
  unique_sessions: number;
}

/**
 * Search referrers response.
 */
export type SearchReferrersResponse = SearchReferrer[];

/**
 * Search trends over time response.
 */
export type SearchTrendsResponse = DailySearchTrend[];

/**
 * Request to send a message.
 */
export interface SendMessageRequest {
  booking_id?: string | null;
  /**
   * @minLength 1
   * @maxLength 1000
   */
  content: string;
}

/**
 * Response for POST /conversations/{id}/messages.
 */
export interface SendMessageResponse {
  created_at: string;
  id: string;
}

/**
 * Response for sending booking reminders.
 */
export interface SendRemindersResponse {
  failed_reminders: number;
  message: string;
  reminders_sent: number;
}

export interface ServiceAreaItem {
  borough?: string | null;
  name?: string | null;
  neighborhood_id: string;
  ntacode?: string | null;
}

export interface ServiceAreasResponse {
  items: ServiceAreaItem[];
  total: number;
}

export interface ServiceAreasUpdateRequest {
  neighborhood_ids: string[];
}

/**
 * Metadata describing instructor search results.
 */
export interface ServiceSearchMetadata {
  active_instructors?: number;
  filters_applied?: SearchFiltersApplied;
  pagination?: SearchPagination;
  total_matches?: number;
}

/**
 * Envelope for service-focused instructor search results.
 */
export interface ServiceSearchResponse {
  instructors?: InstructorSearchResult[];
  metadata: ServiceSearchMetadata;
  query: string;
  search_type?: 'service';
}

export type SignedUploadResponseHeaders = { [key: string]: string };

/**
 * Response payload for signed upload requests.
 */
export interface SignedUploadResponse {
  expires_at: string;
  headers?: SignedUploadResponseHeaders;
  object_key: string;
  public_url?: string | null;
  upload_url: string;
}

export type SlotOperationAction = (typeof SlotOperationAction)[keyof typeof SlotOperationAction];

export const SlotOperationAction = {
  add: 'add',
  remove: 'remove',
  update: 'update',
} as const;

/**
 * Schema for a single slot operation in bulk update.
 */
export interface SlotOperation {
  action: SlotOperationAction;
  date?: string | null;
  end_time?: string | null;
  slot_id?: string | null;
  start_time?: string | null;
}

/**
 * Slow query information.
 */
export interface SlowQueryInfo {
  /** Query duration in milliseconds */
  duration_ms: number;
  /** API endpoint that triggered the query */
  endpoint?: string | null;
  /** SQL query (truncated) */
  query: string;
  /** Query execution timestamp */
  timestamp: string;
}

/**
 * Slow queries response.
 */
export interface SlowQueriesResponse {
  /** List of slow queries */
  slow_queries: SlowQueryInfo[];
  /** Total number of slow queries tracked */
  total_count: number;
}

/**
 * Slow request information.
 */
export interface SlowRequestInfo {
  /** Request duration in milliseconds */
  duration_ms: number;
  /** HTTP method */
  method: string;
  /** Request path */
  path: string;
  /** Response status code */
  status_code: number;
  /** Request timestamp */
  timestamp: string;
}

/**
 * Slow requests response.
 */
export interface SlowRequestsResponse {
  /** List of slow requests */
  slow_requests: SlowRequestInfo[];
  /** Total number of slow requests tracked */
  total_count: number;
}

/**
 * Schema for creating availability on a specific date.
 */
export interface SpecificDateAvailabilityCreate {
  end_time: string;
  specific_date: string;
  start_time: string;
}

export interface SseTokenResponse {
  expires_in_s: number;
  token: string;
}

export interface StudentBadgeView {
  awarded_at?: string | null;
  confirmed_at?: string | null;
  description?: string | null;
  earned: boolean;
  name: string;
  progress?: BadgeProgressView | null;
  slug: string;
  status?: string | null;
}

/**
 * Optional additional data
 */
export type SuccessResponseData = { [key: string]: unknown } | null;

/**
 * Standard success response for operations.
 */
export interface SuccessResponse {
  /** Optional additional data */
  data?: SuccessResponseData;
  /** Human-readable success message */
  message: string;
  /** Operation success status */
  success?: boolean;
}

/**
 * Summary statistics for auth blocks.
 */
export interface SummaryStats {
  captcha_required?: number;
  locked_out?: number;
  rate_limited?: number;
  total_blocked?: number;
}

export interface TFADisableRequest {
  current_password: string;
}

export interface TFADisableResponse {
  message: string;
}

export interface TFASetupInitiateResponse {
  otpauth_url: string;
  qr_code_data_url: string;
  secret: string;
}

export interface TFASetupVerifyRequest {
  code: string;
}

export interface TFASetupVerifyResponse {
  backup_codes: string[];
  enabled: boolean;
}

export interface TFAStatusResponse {
  enabled: boolean;
  last_used_at?: string | null;
  verified_at?: string | null;
}

export interface TFAVerifyLoginRequest {
  backup_code?: string | null;
  code?: string | null;
  temp_token: string;
}

export interface TFAVerifyLoginResponse {
  access_token: string;
  token_type: string;
}

/**
 * Simple time range for schedule entries.
 */
export interface TimeRange {
  end_time: string;
  start_time: string;
}

/**
 * Time slot for availability.
 */
export interface TimeSlot {
  end_time: string;
  start_time: string;
}

/**
 * Minimal service representation for top-per-category capsules.
 */
export interface TopCategoryServiceItem {
  active_instructors?: number;
  demand_score?: number;
  display_order?: number | null;
  id: string;
  is_trending?: boolean;
  name: string;
  slug: string;
}

/**
 * Top services grouped under a category.
 */
export interface TopCategoryItem {
  icon_name?: string | null;
  id: string;
  name: string;
  services?: TopCategoryServiceItem[];
  slug: string;
}

/**
 * Metadata for top-per-category payloads.
 */
export interface TopServicesMetadata {
  cached_for_seconds: number;
  services_per_category: number;
  total_categories: number;
  updated_at: string;
}

/**
 * Response payload for top services per category.
 */
export interface TopServicesPerCategoryResponse {
  categories?: TopCategoryItem[];
  metadata: TopServicesMetadata;
}

/**
 * Individual transaction in payment history.
 */
export interface TransactionHistoryItem {
  /** Date of the booking */
  booking_date: string;
  /** Booking ID */
  booking_id: string;
  /** When the payment was created */
  created_at: string;
  /** Credits applied to this transaction */
  credit_applied: number;
  /** Duration in minutes */
  duration_minutes: number;
  /** End time of the booking */
  end_time: string;
  /** Hourly rate charged */
  hourly_rate: number;
  /** Payment intent ID */
  id: string;
  /** Instructor name (first name + last initial) */
  instructor_name: string;
  /** Lesson price before fees */
  lesson_amount: number;
  /** Student service fee amount */
  service_fee: number;
  /** Service name */
  service_name: string;
  /** Start time of the booking */
  start_time: string;
  /** Payment status */
  status: string;
  /** Tip amount recorded */
  tip_amount: number;
  /** Tip amount successfully charged */
  tip_paid: number;
  /** Status of the tip payment */
  tip_status?: string | null;
  /** Final amount charged including tips */
  total_paid: number;
}

/**
 * Typing indicator payload.
 */
export interface TypingRequest {
  is_typing?: boolean;
}

export interface UnreadCountResponse {
  unread_count: number;
  user_id: string;
}

export type UpdateConversationStateRequestState =
  (typeof UpdateConversationStateRequestState)[keyof typeof UpdateConversationStateRequestState];

export const UpdateConversationStateRequestState = {
  active: 'active',
  archived: 'archived',
  trashed: 'trashed',
} as const;

/**
 * Request to update a user's state for a conversation.
 */
export interface UpdateConversationStateRequest {
  state: UpdateConversationStateRequestState;
}

export type UpdateConversationStateResponseState =
  (typeof UpdateConversationStateResponseState)[keyof typeof UpdateConversationStateResponseState];

export const UpdateConversationStateResponseState = {
  active: 'active',
  archived: 'archived',
  trashed: 'trashed',
} as const;

/**
 * Response for updating conversation state.
 */
export interface UpdateConversationStateResponse {
  id: string;
  state: UpdateConversationStateResponseState;
}

/**
 * Request to update a single preference.
 */
export interface UpdatePreferenceRequest {
  enabled: boolean;
}

/**
 * Response for user booking history endpoint.
 */
export interface UserBookingHistoryResponse {
  bookings: BookingListItem[];
  checked_at: string;
  total_count: number;
  user_id: string;
  user_name: string;
  user_role: string;
}

/**
 * Metadata provided during user registration.
 */
export interface UserRegistrationMetadata {
  campaign?: string | null;
  invite_code?: string | null;
  marketing_tag?: string | null;
  referral_code?: string | null;
  referral_source?: string | null;
  [key: string]: unknown;
}

export interface UserCreate {
  email: string;
  /**
   * @minLength 1
   * @maxLength 50
   */
  first_name: string;
  guest_session_id?: string | null;
  is_active?: boolean | null;
  /**
   * @minLength 1
   * @maxLength 50
   */
  last_name: string;
  metadata?: UserRegistrationMetadata | null;
  password: string;
  phone?: string | null;
  role?: string | null;
  timezone?: string | null;
  /** @pattern ^\d{5}$ */
  zip_code: string;
}

/**
 * Request schema for user data deletion.
 */
export interface UserDataDeletionRequest {
  /** Whether to delete the entire account or just anonymize data */
  delete_account?: boolean;
}

/**
 * Statistics of deleted records
 */
export type UserDataDeletionResponseDeletionStats = { [key: string]: number };

export interface UserDataDeletionResponse {
  /** Whether the account was deleted */
  account_deleted: boolean;
  /** Statistics of deleted records */
  deletion_stats: UserDataDeletionResponseDeletionStats;
  /** Human-readable message */
  message: string;
  /** Status of the deletion request */
  status: string;
}

/**
 * User information for admin lookup.
 */
export interface UserInfo {
  created_at: string;
  email: string;
  instructor_status?: string | null;
  is_founding: boolean;
  is_verified: boolean;
  last_login?: string | null;
  name: string;
  phone?: string | null;
  rating?: number | null;
  review_count?: number | null;
  role: string;
  stripe_account_id?: string | null;
  stripe_customer_id?: string | null;
  total_bookings: number;
  total_earned_cents?: number | null;
  total_lessons?: number | null;
  total_spent_cents: number;
  user_id: string;
}

export interface UserLogin {
  captcha_token?: string | null;
  email: string;
  guest_session_id?: string | null;
  password: string;
}

/**
 * Response for user lookup endpoint.
 */
export interface UserLookupResponse {
  checked_at: string;
  found: boolean;
  user?: UserInfo | null;
}

export interface UserUpdate {
  first_name?: string | null;
  last_name?: string | null;
  phone?: string | null;
  timezone?: string | null;
  zip_code?: string | null;
}

export type ValidateWeekRequestCurrentWeek = { [key: string]: TimeSlot[] };

export type ValidateWeekRequestSavedWeek = { [key: string]: TimeSlot[] };

/**
 * Request to validate week changes
 */
export interface ValidateWeekRequest {
  current_week: ValidateWeekRequestCurrentWeek;
  saved_week: ValidateWeekRequestSavedWeek;
  week_start: string;
}

/**
 * Details about a slot operation in validation
 */
export interface ValidationSlotDetail {
  action: string;
  /** Bookings that conflict with this operation */
  conflicts_with?: AvailabilityConflictInfo[] | null;
  date?: string | null;
  end_time?: string | null;
  operation_index: number;
  reason?: string | null;
  slot_id?: string | null;
  start_time?: string | null;
}

export type ValidationSummaryEstimatedChanges = { [key: string]: number };

export type ValidationSummaryOperationsByType = { [key: string]: number };

/**
 * Summary of validation results
 */
export interface ValidationSummary {
  estimated_changes: ValidationSummaryEstimatedChanges;
  has_conflicts: boolean;
  invalid_operations: number;
  operations_by_type: ValidationSummaryOperationsByType;
  total_operations: number;
  valid_operations: number;
}

/**
 * VAPID public key response.
 */
export interface VapidPublicKeyResponse {
  public_key: string;
}

/**
 * Standard acknowledgement payload returned by webhook endpoints.
 */
export interface WebhookAckResponse {
  ok?: boolean;
}

export interface WebhookResponse {
  /** Stripe event type */
  event_type: string;
  /** Additional information */
  message?: string | null;
  /** Processing status (success, ignored, error) */
  status: string;
}

/**
 * Week availability mapping keyed by ISO date string.
 */
export interface WeekAvailabilityResponse {
  [key: string]: TimeRange[];
}

export interface WeekAvailabilityUpdateResponse {
  days_written?: number;
  edited_dates?: string[];
  message: string;
  skipped_dates?: string[];
  skipped_past_window?: number;
  version?: string | null;
  week_end: string;
  week_start: string;
  week_version?: string | null;
  weeks_affected?: number;
  windows_created: number;
  windows_deleted: number;
  windows_updated: number;
}

/**
 * Schema for creating schedule for specific dates.
 */
export interface WeekSpecificScheduleCreate {
  /** Client's baseline week version when saving (If-Match fallback) */
  base_version?: string | null;
  /** Whether to clear existing entries for the week before saving */
  clear_existing?: boolean;
  /** If true, bypass server-side version checks when saving */
  override?: boolean;
  /** List of schedule items with date, start_time, and end_time */
  schedule: ScheduleItem[];
  /** Deprecated alias for base_version (optimistic concurrency token) */
  version?: string | null;
  /** Optional Monday date. If not provided, inferred from schedule dates */
  week_start?: string | null;
}

/**
 * Response for week schedule validation
 */
export interface WeekValidationResponse {
  details: ValidationSlotDetail[];
  summary: ValidationSummary;
  valid: boolean;
  warnings?: string[];
}

/**
 * A search query that returned zero results.
 */
export interface ZeroResultQueryItem {
  /**
   * Number of times searched
   * @minimum 1
   */
  count: number;
  /** Last search timestamp */
  last_searched: string;
  /** Search query text */
  query: string;
}

/**
 * List of zero-result queries.
 */
export interface ZeroResultQueriesResponse {
  /** Zero-result queries */
  queries: ZeroResultQueryItem[];
}

/**
 * Standard delete acknowledgement for address resources.
 */
export interface AppSchemasAddressResponsesDeleteResponse {
  message: string;
  success: boolean;
}

/**
 * Request schema for bulk availability update.
 */
export interface AppSchemasAvailabilityWindowBulkUpdateRequest {
  operations: SlotOperation[];
  /** If true, only validate without making changes */
  validate_only?: boolean;
}

/**
 * Standard response for delete operations.
 */
export interface AppSchemasBaseResponsesDeleteResponse {
  /** Deletion timestamp */
  deleted_at?: string;
  /** Human-readable deletion message */
  message: string;
  /** Deletion success status */
  success?: boolean;
}

/**
 * Bulk preference update request.
 */
export interface AppSchemasNotificationPreferencesBulkUpdateRequest {
  updates: PreferenceUpdate[];
}

export interface AppSchemasPaymentSchemasDeleteResponse {
  /** Whether deletion was successful */
  success: boolean;
}

export type GetBulkCoverageGeojsonApiV1AddressesCoverageBulkGetParams = {
  ids: string;
};

export type PlacesAutocompleteApiV1AddressesPlacesAutocompleteGetParams = {
  q: string;
  provider?: string | null;
  scope?: string | null;
};

export type PlaceDetailsApiV1AddressesPlacesDetailsGetParams = {
  place_id: string;
  provider?: string | null;
};

export type ListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGetParams = {
  region_type?: string;
  borough?: string | null;
  page?: number;
  per_page?: number;
};

export type IsNycZipApiV1AddressesZipIsNycGetParams = {
  zip: string;
};

export type ListAuditLogsApiV1AdminAuditGetParams = {
  entity_type?: string | null;
  entity_id?: string | null;
  action?: string | null;
  actor_id?: string | null;
  actor_role?: string | null;
  start?: string | null;
  end?: string | null;
  /**
   * @minimum 1
   * @maximum 200
   */
  limit?: number;
  /**
   * @minimum 0
   */
  offset?: number;
};

export type ListAdminAuditLogApiV1AdminAuditLogGetParams = {
  action?: string[] | null;
  admin_id?: string | null;
  date_from?: string | null;
  date_to?: string | null;
  /**
   * @minimum 1
   */
  page?: number;
  /**
   * @minimum 1
   * @maximum 200
   */
  per_page?: number;
};

export type ListAuthIssuesApiV1AdminAuthBlocksGetParams = {
  /**
   * Filter by block type: lockout, rate_limit, captcha
   */
  type?: string | null;
  /**
   * Search by email (partial match)
   */
  email?: string | null;
};

export type BgcCasesApiV1AdminBackgroundChecksCasesGetParams = {
  /**
   * review, pending, or all
   */
  status?: string;
  /**
   * Search by instructor id, name, or email
   */
  q?: string | null;
  /**
   * @minimum 1
   */
  page?: number;
  /**
   * @minimum 1
   * @maximum 200
   */
  page_size?: number;
  /**
   * Deprecated; use page_size instead.
   */
  limit?: number | null;
};

export type BgcExpiringApiV1AdminBackgroundChecksExpiringGetParams = {
  /**
   * Lookahead window in days
   * @minimum 1
   * @maximum 180
   */
  days?: number;
  /**
   * @minimum 1
   * @maximum 1000
   */
  limit?: number;
};

export type BgcHistoryApiV1AdminBackgroundChecksHistoryInstructorIdGetParams = {
  /**
   * @minimum 1
   * @maximum 200
   */
  limit?: number;
  /**
   * Opaque history ULID cursor
   */
  cursor?: string | null;
};

export type BgcReviewListApiV1AdminBackgroundChecksReviewGetParams = {
  /**
   * @minimum 1
   * @maximum 200
   */
  limit?: number;
  /**
   * Opaque ULID cursor for pagination
   */
  cursor?: string | null;
};

export type BgcWebhookLogsApiV1AdminBackgroundChecksWebhooksGetParams = {
  /**
   * @minimum 1
   * @maximum 200
   */
  limit?: number;
  /**
   * Opaque cursor for pagination
   */
  cursor?: string | null;
  event?: string[];
  status?: string[];
  /**
   * Search delivery id or signature
   */
  q?: string | null;
};

export type OpenBgcDisputeApiV1AdminBackgroundChecksInstructorIdDisputeOpenPostBody = {
  [key: string]: unknown;
};

export type ResolveBgcDisputeApiV1AdminBackgroundChecksInstructorIdDisputeResolvePostBody = {
  [key: string]: unknown;
};

export type ListPendingAwardsApiV1AdminBadgesPendingGetParams = {
  before?: string | null;
  status?: string | null;
  /**
   * @minimum 1
   * @maximum 200
   */
  limit?: number;
  /**
   * @minimum 0
   */
  offset?: number;
};

export type ListAdminBookingsApiV1AdminBookingsGetParams = {
  search?: string | null;
  status?: string[] | null;
  payment_status?: string[] | null;
  date_from?: string | null;
  date_to?: string | null;
  needs_action?: boolean | null;
  /**
   * @minimum 1
   */
  page?: number;
  /**
   * @minimum 1
   * @maximum 200
   */
  per_page?: number;
};

export type ProcessLocationLearningApiV1AdminLocationLearningProcessPostParams = {
  /**
   * @minimum 1
   * @maximum 2000
   */
  limit?: number;
};

export type ListRegionsApiV1AdminLocationLearningRegionsGetParams = {
  /**
   * @minimum 1
   * @maximum 5000
   */
  limit?: number;
};

export type ListUnresolvedLocationQueriesApiV1AdminLocationLearningUnresolvedGetParams = {
  /**
   * @minimum 1
   * @maximum 500
   */
  limit?: number;
};

export type AuditRecentAdminActionsApiV1AdminMcpAuditAdminActionsRecentGetParams = {
  /**
   * @minimum 1
   * @maximum 720
   */
  since_hours?: number;
  /**
   * @minimum 1
   * @maximum 500
   */
  limit?: number;
};

export type AuditResourceHistoryApiV1AdminMcpAuditResourcesResourceTypeResourceIdHistoryGetParams =
  {
    /**
     * @minimum 1
     * @maximum 500
     */
    limit?: number;
  };

export type AuditSearchApiV1AdminMcpAuditSearchGetParams = {
  actor_email?: string | null;
  actor_id?: string | null;
  action?: string | null;
  resource_type?: string | null;
  resource_id?: string | null;
  status?: string | null;
  /**
   * @minimum 1
   * @maximum 720
   */
  since_hours?: number;
  /**
   * @minimum 1
   * @maximum 500
   */
  limit?: number;
};

export type AuditUserActivityApiV1AdminMcpAuditUsersUserEmailActivityGetParams = {
  /**
   * @minimum 1
   * @maximum 365
   */
  since_days?: number;
  /**
   * @minimum 1
   * @maximum 500
   */
  limit?: number;
};

export type GetFailedTasksApiV1AdminMcpCeleryFailedGetParams = {
  /**
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
};

export type GetTaskHistoryApiV1AdminMcpCeleryTasksHistoryGetParams = {
  /**
   * Filter by task name (partial match)
   */
  task_name?: string | null;
  /**
   * Filter by state (SUCCESS, FAILURE, PENDING, STARTED, RETRY)
   */
  state?: string | null;
  /**
   * Look back window in hours (max 24)
   * @minimum 1
   * @maximum 24
   */
  hours?: number;
  /**
   * Max results (max 500)
   * @minimum 1
   * @maximum 500
   */
  limit?: number;
};

export type GetFunnelSummaryApiV1AdminMcpFoundingFunnelGetParams = {
  start_date?: string | null;
  end_date?: string | null;
};

export type GetStuckInstructorsApiV1AdminMcpFoundingStuckGetParams = {
  /**
   * @minimum 1
   * @maximum 90
   */
  stuck_days?: number;
  stage?: string | null;
  /**
   * @minimum 1
   * @maximum 200
   */
  limit?: number;
};

export type ListInstructorsApiV1AdminMcpInstructorsGetParams = {
  status?: 'registered' | 'onboarding' | 'live' | 'paused' | null;
  is_founding?: boolean | null;
  service_slug?: string | null;
  category_slug?: string | null;
  /**
   * @minimum 1
   * @maximum 200
   */
  limit?: number;
  cursor?: string | null;
};

export type GetServiceCoverageApiV1AdminMcpInstructorsCoverageGetParams = {
  status?: GetServiceCoverageApiV1AdminMcpInstructorsCoverageGetStatus;
  group_by?: GetServiceCoverageApiV1AdminMcpInstructorsCoverageGetGroupBy;
  /**
   * @minimum 1
   * @maximum 200
   */
  top?: number;
};

export type GetServiceCoverageApiV1AdminMcpInstructorsCoverageGetStatus =
  (typeof GetServiceCoverageApiV1AdminMcpInstructorsCoverageGetStatus)[keyof typeof GetServiceCoverageApiV1AdminMcpInstructorsCoverageGetStatus];

export const GetServiceCoverageApiV1AdminMcpInstructorsCoverageGetStatus = {
  registered: 'registered',
  onboarding: 'onboarding',
  live: 'live',
  paused: 'paused',
} as const;

export type GetServiceCoverageApiV1AdminMcpInstructorsCoverageGetGroupBy =
  (typeof GetServiceCoverageApiV1AdminMcpInstructorsCoverageGetGroupBy)[keyof typeof GetServiceCoverageApiV1AdminMcpInstructorsCoverageGetGroupBy];

export const GetServiceCoverageApiV1AdminMcpInstructorsCoverageGetGroupBy = {
  category: 'category',
  service: 'service',
} as const;

export type ListInvitesApiV1AdminMcpInvitesGetParams = {
  /**
   * Filter by recipient email
   */
  email?: string | null;
  /**
   * Filter by status: pending, accepted, expired, revoked
   */
  status?: InviteStatus | null;
  /**
   * Filter by created_at start date (YYYY-MM-DD)
   */
  start_date?: string | null;
  /**
   * Filter by created_at end date (YYYY-MM-DD)
   */
  end_date?: string | null;
  /**
   * Max results (max 200)
   * @minimum 1
   * @maximum 200
   */
  limit?: number;
  /**
   * Pagination cursor
   */
  cursor?: string | null;
};

export type GetRecentBookingsApiV1AdminMcpOpsBookingsRecentGetParams = {
  /**
   * Filter by status: confirmed, completed, cancelled, pending
   */
  status?: string | null;
  /**
   * Max results (max 100)
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
  /**
   * Look back window in hours (max 168 = 1 week)
   * @minimum 1
   * @maximum 168
   */
  hours?: number;
};

export type GetBookingSummaryApiV1AdminMcpOpsBookingsSummaryGetParams = {
  /**
   * Time period: today, yesterday, this_week, last_7_days, this_month
   */
  period?: BookingPeriod;
};

export type GetPendingPayoutsApiV1AdminMcpOpsPaymentsPendingPayoutsGetParams = {
  /**
   * Max results (max 100)
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
};

export type LookupUserApiV1AdminMcpOpsUsersLookupGetParams = {
  /**
   * Email, phone number, or user ID
   */
  identifier: string;
};

export type GetUserBookingHistoryApiV1AdminMcpOpsUsersUserIdBookingsGetParams = {
  /**
   * Max results (max 100)
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
};

export type GetTopQueriesApiV1AdminMcpSearchTopQueriesGetParams = {
  start_date?: string | null;
  end_date?: string | null;
  /**
   * @minimum 1
   * @maximum 200
   */
  limit?: number;
  /**
   * @minimum 1
   * @maximum 1000
   */
  min_count?: number;
};

export type GetZeroResultQueriesApiV1AdminMcpSearchZeroResultsGetParams = {
  start_date?: string | null;
  end_date?: string | null;
  /**
   * @minimum 1
   * @maximum 200
   */
  limit?: number;
};

export type LookupServiceCatalogApiV1AdminMcpServicesLookupGetParams = {
  /**
   * Service name or slug to resolve
   * @minLength 2
   */
  q: string;
};

export type ListWebhooksApiV1AdminMcpWebhooksGetParams = {
  source?: string | null;
  status?: string | null;
  event_type?: string | null;
  /**
   * @minimum 1
   * @maximum 168
   */
  since_hours?: number;
  /**
   * @minimum 1
   * @maximum 200
   */
  limit?: number;
};

export type ListFailedWebhooksApiV1AdminMcpWebhooksFailedGetParams = {
  source?: string | null;
  /**
   * @minimum 1
   * @maximum 168
   */
  since_hours?: number;
  /**
   * @minimum 1
   * @maximum 200
   */
  limit?: number;
};

export type ReplayWebhookApiV1AdminMcpWebhooksEventIdReplayPostParams = {
  dry_run?: boolean;
};

export type ExportAnalyticsApiV1AnalyticsExportPostParams = {
  format?: string;
};

export type CandidatesCategoryTrendsApiV1AnalyticsSearchCandidatesCategoryTrendsGetParams = {
  /**
   * @minimum 1
   * @maximum 365
   */
  days?: number;
};

export type CandidateServiceQueriesApiV1AnalyticsSearchCandidatesQueriesGetParams = {
  service_catalog_id: string;
  /**
   * @minimum 1
   * @maximum 365
   */
  days?: number;
  /**
   * @minimum 1
   * @maximum 200
   */
  limit?: number;
};

export type CandidatesScoreDistributionApiV1AnalyticsSearchCandidatesScoreDistributionGetParams = {
  /**
   * @minimum 1
   * @maximum 365
   */
  days?: number;
};

export type CandidatesSummaryApiV1AnalyticsSearchCandidatesSummaryGetParams = {
  /**
   * @minimum 1
   * @maximum 365
   */
  days?: number;
};

export type CandidatesTopServicesApiV1AnalyticsSearchCandidatesTopServicesGetParams = {
  /**
   * @minimum 1
   * @maximum 365
   */
  days?: number;
  /**
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
};

export type GetConversionMetricsApiV1AnalyticsSearchConversionMetricsGetParams = {
  /**
   * @minimum 1
   * @maximum 365
   */
  days?: number;
};

export type GetPopularSearchesApiV1AnalyticsSearchPopularSearchesGetParams = {
  /**
   * @minimum 1
   * @maximum 365
   */
  days?: number;
  /**
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
};

export type GetSearchReferrersApiV1AnalyticsSearchReferrersGetParams = {
  /**
   * @minimum 1
   * @maximum 365
   */
  days?: number;
};

export type GetSearchAnalyticsSummaryApiV1AnalyticsSearchSearchAnalyticsSummaryGetParams = {
  /**
   * @minimum 1
   * @maximum 365
   */
  days?: number;
};

export type GetSearchPerformanceApiV1AnalyticsSearchSearchPerformanceGetParams = {
  /**
   * @minimum 1
   * @maximum 365
   */
  days?: number;
};

export type GetSearchTrendsApiV1AnalyticsSearchSearchTrendsGetParams = {
  /**
   * @minimum 1
   * @maximum 365
   */
  days?: number;
};

export type GetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGetParams = {
  task_id: string;
};

export type ValidateInviteApiV1BetaInvitesValidateGetParams = {
  code?: string | null;
  invite_code?: string | null;
  email?: string | null;
};

export type GetBookingsApiV1BookingsGetParams = {
  status?: BookingStatus | null;
  upcoming_only?: boolean | null;
  upcoming?: boolean | null;
  exclude_future_confirmed?: boolean;
  include_past_confirmed?: boolean;
  /**
   * @minimum 1
   */
  page?: number;
  /**
   * @minimum 1
   * @maximum 100
   */
  per_page?: number;
};

export type GetUpcomingBookingsApiV1BookingsUpcomingGetParams = {
  /**
   * @minimum 1
   * @maximum 20
   */
  limit?: number;
};

export type GetBookingPricingApiV1BookingsBookingIdPricingGetParams = {
  /**
   * @minimum 0
   */
  applied_credit_cents?: number;
};

export type ListConversationsApiV1ConversationsGetParams = {
  state?: string | null;
  /**
   * @minimum 1
   * @maximum 50
   */
  limit?: number;
  /**
   * Pagination cursor (ISO timestamp)
   */
  cursor?: string | null;
};

export type GetMessagesApiV1ConversationsConversationIdMessagesGetParams = {
  /**
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
  /**
   * Cursor for pagination (message ID)
   */
  before?: string | null;
  /**
   * Filter by booking ID
   */
  booking_id?: string | null;
};

export type ListInstructorBookingsApiV1InstructorBookingsGetParams = {
  /**
   * Filter by booking status (COMPLETED, CONFIRMED, etc.)
   */
  status?: BookingStatus | null;
  /**
   * Only include upcoming confirmed bookings
   */
  upcoming?: boolean;
  /**
   * Exclude future confirmed bookings (for History tab)
   */
  exclude_future_confirmed?: boolean;
  /**
   * Page number
   * @minimum 1
   */
  page?: number;
  /**
   * Items per page
   * @minimum 1
   * @maximum 100
   */
  per_page?: number;
  /**
   * Include past confirmed bookings (for BookAgain)
   */
  include_past_confirmed?: boolean;
};

export type GetCompletedBookingsApiV1InstructorBookingsCompletedGetParams = {
  /**
   * Page number
   * @minimum 1
   */
  page?: number;
  /**
   * Items per page
   * @minimum 1
   * @maximum 100
   */
  per_page?: number;
};

export type GetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGetParams = {
  /**
   * Page number
   * @minimum 1
   */
  page?: number;
  /**
   * Items per page
   * @minimum 1
   * @maximum 100
   */
  per_page?: number;
};

export type GetUpcomingBookingsApiV1InstructorBookingsUpcomingGetParams = {
  /**
   * Page number
   * @minimum 1
   */
  page?: number;
  /**
   * Items per page
   * @minimum 1
   * @maximum 100
   */
  per_page?: number;
};

export type MarkLessonCompleteApiV1InstructorBookingsBookingIdCompletePostParams = {
  notes?: string | null;
};

export type GetReferredInstructorsApiV1InstructorReferralsReferredGetParams = {
  /**
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
  /**
   * @minimum 0
   */
  offset?: number;
};

export type ListInstructorsApiV1InstructorsGetParams = {
  /**
   * Service catalog ID (required)
   */
  service_catalog_id: string;
  /**
   * Minimum hourly rate
   * @minimum 0
   * @maximum 1000
   */
  min_price?: number;
  /**
   * Maximum hourly rate
   * @minimum 0
   * @maximum 1000
   */
  max_price?: number;
  /**
   * Filter by age group: 'kids' or 'adults'
   */
  age_group?: string;
  /**
   * Page number
   * @minimum 1
   */
  page?: number;
  /**
   * Items per page
   * @minimum 1
   * @maximum 100
   */
  per_page?: number;
};

export type GetAllAvailabilityApiV1InstructorsAvailabilityGetParams = {
  start_date?: string | null;
  end_date?: string | null;
};

export type GetWeekAvailabilityApiV1InstructorsAvailabilityWeekGetParams = {
  /**
   * Monday of the week
   */
  start_date: string;
};

export type SaveWeekAvailabilityApiV1InstructorsAvailabilityWeekPostParams = {
  /**
   * Set to true to bypass version conflict checks when saving availability
   */
  override?: boolean;
};

export type GetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGetParams = {
  /**
   * Start date (Monday) of the week
   */
  start_date: string;
};

export type CheckServiceAreaApiV1InstructorsInstructorIdCheckServiceAreaGetParams = {
  /**
   * Latitude
   */
  lat: number;
  /**
   * Longitude
   */
  lng: number;
};

export type StreamUserMessagesApiV1MessagesStreamGetParams = {
  sse_token?: string | null;
};

export type GetLiveAlertsApiV1MonitoringAlertsLiveGetParams = {
  /**
   * Get alerts from last N minutes
   */
  minutes?: number;
};

export type GetRecentAlertsApiV1MonitoringAlertsRecentGetParams = {
  /**
   * Get alerts from last N hours
   */
  hours?: number;
  /**
   * Maximum number of alerts to return
   */
  limit?: number;
  /**
   * Filter by severity
   */
  severity?: string | null;
};

export type GetAlertSummaryApiV1MonitoringAlertsSummaryGetParams = {
  /**
   * Number of days to summarize
   */
  days?: number;
};

export type GetSlowQueriesApiV1MonitoringSlowQueriesGetParams = {
  limit?: number;
};

export type GetSlowRequestsApiV1MonitoringSlowRequestsGetParams = {
  limit?: number;
};

export type ListNotificationsApiV1NotificationsGetParams = {
  /**
   * @minimum 1
   * @maximum 50
   */
  limit?: number;
  /**
   * @minimum 0
   */
  offset?: number;
  unread_only?: boolean;
};

export type ResetRateLimitsApiV1OpsRateLimitsResetPostParams = {
  /**
   * Pattern to match (e.g., 'email_*', 'ip_192.168.*')
   */
  pattern: string;
};

export type TestRateLimitApiV1OpsRateLimitsTestGetParams = {
  /**
   * Number of requests to simulate
   * @minimum 1
   * @maximum 20
   */
  requests?: number;
};

export type StartOnboardingApiV1PaymentsConnectOnboardPostParams = {
  return_to?: string | null;
};

export type SetPayoutScheduleApiV1PaymentsConnectPayoutSchedulePostParams = {
  interval?: string;
  weekly_anchor?: string;
};

export type GetInstructorPayoutsApiV1PaymentsPayoutsGetParams = {
  /**
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
};

export type GetTransactionHistoryApiV1PaymentsTransactionsGetParams = {
  limit?: number;
  offset?: number;
};

export type GetInstructorPublicAvailabilityApiV1PublicInstructorsInstructorIdAvailabilityGetParams =
  {
    /**
     * Start date for availability search
     */
    start_date: string;
    /**
     * End date (defaults to configured days from start)
     */
    end_date?: string | null;
  };

export type GetNextAvailableSlotApiV1PublicInstructorsInstructorIdNextAvailableGetParams = {
  /**
   * Required duration in minutes
   */
  duration_minutes?: number;
};

export type GetRecentReviewsApiV1ReviewsInstructorInstructorIdRecentGetParams = {
  instructor_service_id?: string | null;
  /**
   * @minimum 1
   * @maximum 50
   */
  limit?: number;
  /**
   * @minimum 1
   */
  page?: number;
  min_rating?: number | null;
  rating?: number | null;
  with_text?: boolean | null;
};

export type GetSearchRatingApiV1ReviewsInstructorInstructorIdSearchRatingGetParams = {
  instructor_service_id?: string | null;
};

export type NlSearchApiV1SearchGetParams = {
  /**
   * Natural language search query
   * @minLength 1
   * @maxLength 500
   */
  q: string;
  /**
   * User latitude
   */
  lat?: number | null;
  /**
   * User longitude
   */
  lng?: number | null;
  /**
   * Region code for location/price lookups
   */
  region?: string;
  /**
   * Maximum results to return
   * @minimum 1
   * @maximum 50
   */
  limit?: number;
  /**
   * Include detailed diagnostics (admin only)
   */
  diagnostics?: boolean;
  /**
   * Force skip Tier 5 LLM (admin only)
   */
  force_skip_tier5?: boolean;
  /**
   * Force skip Tier 4 embedding (admin only)
   */
  force_skip_tier4?: boolean;
  /**
   * Force skip vector search (admin only)
   */
  force_skip_vector?: boolean;
  /**
   * Force skip embeddings (admin only)
   */
  force_skip_embedding?: boolean;
  /**
   * Force high-load budget (admin only)
   */
  force_high_load?: boolean;
};

export type GetRecentSearchesApiV1SearchHistoryGetParams = {
  limit?: number;
};

export type TrackInteractionApiV1SearchHistoryInteractionPostBody = { [key: string]: unknown };

export type SearchMetricsApiV1SearchAnalyticsMetricsGetParams = {
  /**
   * Number of days to analyze
   * @minimum 1
   * @maximum 30
   */
  days?: number;
};

export type PopularQueriesApiV1SearchAnalyticsPopularGetParams = {
  /**
   * Number of days to analyze
   * @minimum 1
   * @maximum 30
   */
  days?: number;
  /**
   * Maximum queries to return
   * @minimum 1
   * @maximum 200
   */
  limit?: number;
};

export type ZeroResultQueriesApiV1SearchAnalyticsZeroResultsGetParams = {
  /**
   * Number of days to analyze
   * @minimum 1
   * @maximum 30
   */
  days?: number;
  /**
   * Maximum queries to return
   * @minimum 1
   * @maximum 500
   */
  limit?: number;
};

export type LogSearchClickApiV1SearchClickPostParams = {
  /**
   * Search query ID from NL search
   */
  search_query_id?: string | null;
  /**
   * Service ID that was clicked (instructor_service_id)
   */
  service_id?: string | null;
  /**
   * Instructor user ID that was clicked
   */
  instructor_id?: string | null;
  /**
   * Position in search results (1-indexed)
   */
  position?: number | null;
  /**
   * Action type: view, book, message, favorite
   */
  action?: string;
};

export type GetCatalogServicesApiV1ServicesCatalogGetParams = {
  /**
   * Filter by category slug
   */
  category?: string | null;
};

export type GetTopServicesPerCategoryApiV1ServicesCatalogTopPerCategoryGetParams = {
  /**
   * Number of top services per category
   * @minimum 1
   * @maximum 20
   */
  limit?: number;
};

export type SearchServicesApiV1ServicesSearchGetParams = {
  /**
   * Search query
   * @minLength 2
   */
  q: string;
};

export type GetProfilePictureUrlsBatchApiV1UsersProfilePictureUrlsGetParams = {
  /**
   * Comma-separated list of user IDs (ids=1,2,3) or repeated ids parameters.
   */
  ids?: string[];
  variant?: 'original' | 'display' | 'thumb' | null;
};

export type GetProfilePictureUrlApiV1UsersUserIdProfilePictureUrlGetParams = {
  variant?: 'original' | 'display' | 'thumb' | null;
};
