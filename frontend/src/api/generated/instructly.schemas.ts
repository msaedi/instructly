/**
 * Generated by orval v7.16.1 üç∫
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
export type AccessGrantResponseInvitedByCode = string | null;

export interface AccessGrantResponse {
  access_id: string;
  invited_by_code?: AccessGrantResponseInvitedByCode;
  phase: string;
  role: string;
  user_id: string;
}

export interface AccountStatusChangeResponse {
  message: string;
  new_status: string;
  previous_status: string;
  success: boolean;
}

export type AccountStatusResponseCanDeactivate = boolean | null;

export type AccountStatusResponseCanReactivate = boolean | null;

export type AccountStatusResponseCanSuspend = boolean | null;

export type AccountStatusResponseFutureBookingsCount = number | null;

export type AccountStatusResponseHasFutureBookings = boolean | null;

export interface AccountStatusResponse {
  account_status: string;
  can_deactivate?: AccountStatusResponseCanDeactivate;
  can_login: boolean;
  can_reactivate?: AccountStatusResponseCanReactivate;
  can_receive_bookings: boolean;
  can_suspend?: AccountStatusResponseCanSuspend;
  future_bookings_count?: AccountStatusResponseFutureBookingsCount;
  has_future_bookings?: AccountStatusResponseHasFutureBookings;
  is_active: boolean;
  is_deactivated: boolean;
  is_suspended: boolean;
  role: string;
  user_id: string;
}

export type AddressCreateCustomLabel = string | null;

/**
 * home|work|other
 */
export type AddressCreateLabel = string | null;

export type AddressCreateLatitude = number | null;

export type AddressCreateLongitude = number | null;

export type AddressCreatePlaceId = string | null;

export type AddressCreateRecipientName = string | null;

export type AddressCreateStreetLine2 = string | null;

export type AddressCreateVerificationStatus = string | null;

export interface AddressCreate {
  administrative_area: string;
  country_code?: string;
  custom_label?: AddressCreateCustomLabel;
  is_default?: boolean;
  /** home|work|other */
  label?: AddressCreateLabel;
  latitude?: AddressCreateLatitude;
  locality: string;
  longitude?: AddressCreateLongitude;
  place_id?: AddressCreatePlaceId;
  postal_code: string;
  recipient_name?: AddressCreateRecipientName;
  street_line1: string;
  street_line2?: AddressCreateStreetLine2;
  verification_status?: AddressCreateVerificationStatus;
}

export interface AddressListResponse {
  items: AddressResponse[];
  total: number;
}

export type AddressResponseCustomLabel = string | null;

export type AddressResponseDistrict = string | null;

/**
 * home|work|other
 */
export type AddressResponseLabel = string | null;

export type AddressResponseLatitude = number | null;

export type AddressResponseLocationMetadataAnyOf = { [key: string]: unknown };

export type AddressResponseLocationMetadata = AddressResponseLocationMetadataAnyOf | null;

export type AddressResponseLongitude = number | null;

export type AddressResponseNeighborhood = string | null;

export type AddressResponsePlaceId = string | null;

export type AddressResponseRecipientName = string | null;

export type AddressResponseStreetLine2 = string | null;

export type AddressResponseSubneighborhood = string | null;

export type AddressResponseVerificationStatus = string | null;

export interface AddressResponse {
  administrative_area: string;
  country_code?: string;
  custom_label?: AddressResponseCustomLabel;
  district?: AddressResponseDistrict;
  id: string;
  is_active: boolean;
  is_default?: boolean;
  /** home|work|other */
  label?: AddressResponseLabel;
  latitude?: AddressResponseLatitude;
  locality: string;
  location_metadata?: AddressResponseLocationMetadata;
  longitude?: AddressResponseLongitude;
  neighborhood?: AddressResponseNeighborhood;
  place_id?: AddressResponsePlaceId;
  postal_code: string;
  recipient_name?: AddressResponseRecipientName;
  street_line1: string;
  street_line2?: AddressResponseStreetLine2;
  subneighborhood?: AddressResponseSubneighborhood;
  verification_status?: AddressResponseVerificationStatus;
}

export type AddressUpdateAdministrativeArea = string | null;

export type AddressUpdateCountryCode = string | null;

export type AddressUpdateCustomLabel = string | null;

export type AddressUpdateIsDefault = boolean | null;

export type AddressUpdateLabel = string | null;

export type AddressUpdateLatitude = number | null;

export type AddressUpdateLocality = string | null;

export type AddressUpdateLongitude = number | null;

export type AddressUpdatePlaceId = string | null;

export type AddressUpdatePostalCode = string | null;

export type AddressUpdateRecipientName = string | null;

export type AddressUpdateStreetLine1 = string | null;

export type AddressUpdateStreetLine2 = string | null;

export type AddressUpdateVerificationStatus = string | null;

export interface AddressUpdate {
  administrative_area?: AddressUpdateAdministrativeArea;
  country_code?: AddressUpdateCountryCode;
  custom_label?: AddressUpdateCustomLabel;
  is_default?: AddressUpdateIsDefault;
  label?: AddressUpdateLabel;
  latitude?: AddressUpdateLatitude;
  locality?: AddressUpdateLocality;
  longitude?: AddressUpdateLongitude;
  place_id?: AddressUpdatePlaceId;
  postal_code?: AddressUpdatePostalCode;
  recipient_name?: AddressUpdateRecipientName;
  street_line1?: AddressUpdateStreetLine1;
  street_line2?: AddressUpdateStreetLine2;
  verification_status?: AddressUpdateVerificationStatus;
}

export type AdminReferralsConfigOutFlags = {[key: string]: boolean};

export type AdminReferralsConfigOutSource = typeof AdminReferralsConfigOutSource[keyof typeof AdminReferralsConfigOutSource];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AdminReferralsConfigOutSource = {
  db: 'db',
  defaults: 'defaults',
} as const;

export type AdminReferralsConfigOutVersion = number | null;

/**
 * Configuration snapshot for the referral program.
 */
export interface AdminReferralsConfigOut {
  expiry_months: number;
  flags: AdminReferralsConfigOutFlags;
  global_cap: number;
  hold_days: number;
  instructor_amount_cents: number;
  min_basket_cents: number;
  source: AdminReferralsConfigOutSource;
  student_amount_cents: number;
  version: AdminReferralsConfigOutVersion;
}

export type AdminReferralsHealthOutLastRunAgeS = number | null;

/**
 * Unlocker worker and data health for admin dashboards.
 */
export interface AdminReferralsHealthOut {
  backlog_pending_due: number;
  last_run_age_s?: AdminReferralsHealthOutLastRunAgeS;
  pending_total: number;
  unlocked_total: number;
  void_total: number;
  workers: string[];
  workers_alive: number;
}

export type AdminReferralsSummaryOutCountsByStatus = {[key: string]: number};

/**
 * Aggregate referral summary metrics for admins.
 */
export interface AdminReferralsSummaryOut {
  attributions_24h: number;
  cap_utilization_percent: number;
  clicks_24h: number;
  counts_by_status: AdminReferralsSummaryOutCountsByStatus;
  top_referrers: TopReferrerOut[];
}

/**
 * Alert acknowledgement response.
 */
export interface AlertAcknowledgeResponse {
  /** Alert type that was acknowledged */
  alert_type: string;
  /** Acknowledgement status */
  status: string;
}

export type AlertDetailDetailsAnyOf = { [key: string]: unknown };

/**
 * Additional alert details
 */
export type AlertDetailDetails = AlertDetailDetailsAnyOf | null;

/**
 * Individual alert details.
 */
export interface AlertDetail {
  /** When the alert was created (ISO format) */
  created_at: string;
  /** Additional alert details */
  details?: AlertDetailDetails;
  /** Whether email notification was sent */
  email_sent: boolean;
  /** Whether GitHub issue was created */
  github_issue: boolean;
  /** Alert ID */
  id: string;
  /** Alert message */
  message: string;
  /** Alert severity level */
  severity: string;
  /** Alert title */
  title: string;
  /** Type of alert */
  type: string;
}

/**
 * Alert information.
 */
export interface AlertInfo {
  /** Alert message */
  message: string;
  /** Alert severity (info/warning/critical) */
  severity: string;
  /** Alert timestamp */
  timestamp: string;
  /** Alert type */
  type: string;
}

/**
 * Alert counts grouped by severity
 */
export type AlertSummaryResponseBySeverity = {[key: string]: number};

/**
 * Alert counts grouped by type
 */
export type AlertSummaryResponseByType = {[key: string]: number};

/**
 * Response for alert summary endpoint.
 */
export interface AlertSummaryResponse {
  /** Daily alert counts */
  by_day: DailyAlertCount[];
  /** Alert counts grouped by severity */
  by_severity: AlertSummaryResponseBySeverity;
  /** Alert counts grouped by type */
  by_type: AlertSummaryResponseByType;
  /** Number of days included in summary */
  days: number;
  /** Total number of alerts in the period */
  total: number;
}

export type AllServicesMetadataTotalServices = number | null;

/**
 * Metadata for full catalog-with-instructors payload.
 */
export interface AllServicesMetadata {
  cached_for_seconds: number;
  total_categories: number;
  total_services?: AllServicesMetadataTotalServices;
  updated_at: string;
}

/**
 * Full catalog payload including instructor analytics.
 */
export interface AllServicesWithInstructorsResponse {
  categories?: CategoryWithServices[];
  metadata: AllServicesMetadata;
}

export interface AppendHistoryResponse {
  /** @minimum 0 */
  count: number;
  status: string;
}

/**
 * Schema for applying a week pattern to a date range.
 */
export interface ApplyToDateRangeRequest {
  end_date: string;
  from_week_start: string;
  start_date: string;
}

export interface ApplyToDateRangeResponse {
  dates_processed?: number;
  dates_with_slots?: number;
  dates_with_windows?: number;
  days_written: number;
  edited_dates?: string[];
  end_date: string;
  message: string;
  skipped_past_targets?: number;
  start_date: string;
  weeks_affected: number;
  weeks_applied: number;
  windows_created: number;
  written_dates?: string[];
}

export type AuthUserResponseHasProfilePicture = boolean | null;

export type AuthUserResponsePhone = string | null;

export type AuthUserResponseProfilePictureVersion = number | null;

export type AuthUserResponseTimezone = string | null;

export type AuthUserResponseZipCode = string | null;

/**
 * Minimal strict representation of a user for auth endpoints.
 */
export interface AuthUserResponse {
  email: string;
  first_name: string;
  has_profile_picture?: AuthUserResponseHasProfilePicture;
  id: string;
  is_active?: boolean;
  last_name: string;
  permissions?: string[];
  phone?: AuthUserResponsePhone;
  profile_picture_version?: AuthUserResponseProfilePictureVersion;
  roles?: string[];
  timezone?: AuthUserResponseTimezone;
  zip_code?: AuthUserResponseZipCode;
}

export type AuthUserWithPermissionsResponseBetaAccess = boolean | null;

export type AuthUserWithPermissionsResponseBetaInvitedBy = string | null;

export type AuthUserWithPermissionsResponseBetaPhase = string | null;

export type AuthUserWithPermissionsResponseBetaRole = string | null;

export type AuthUserWithPermissionsResponseHasProfilePicture = boolean | null;

export type AuthUserWithPermissionsResponsePhone = string | null;

export type AuthUserWithPermissionsResponseProfilePictureVersion = number | null;

export type AuthUserWithPermissionsResponseTimezone = string | null;

export type AuthUserWithPermissionsResponseZipCode = string | null;

/**
 * Extends auth user response with optional beta metadata.
 */
export interface AuthUserWithPermissionsResponse {
  beta_access?: AuthUserWithPermissionsResponseBetaAccess;
  beta_invited_by?: AuthUserWithPermissionsResponseBetaInvitedBy;
  beta_phase?: AuthUserWithPermissionsResponseBetaPhase;
  beta_role?: AuthUserWithPermissionsResponseBetaRole;
  email: string;
  first_name: string;
  has_profile_picture?: AuthUserWithPermissionsResponseHasProfilePicture;
  id: string;
  is_active?: boolean;
  last_name: string;
  permissions?: string[];
  phone?: AuthUserWithPermissionsResponsePhone;
  profile_picture_version?: AuthUserWithPermissionsResponseProfilePictureVersion;
  roles?: string[];
  timezone?: AuthUserWithPermissionsResponseTimezone;
  zip_code?: AuthUserWithPermissionsResponseZipCode;
}

export interface AutocompleteResponse {
  items: PlaceSuggestion[];
  total: number;
}

/**
 * Availability cache metrics
 */
export type AvailabilityCacheMetricsResponseAvailabilityCacheMetrics = { [key: string]: unknown };

/**
 * Cache tier configuration
 */
export type AvailabilityCacheMetricsResponseCacheTiersInfo = {[key: string]: string};

/**
 * Availability-specific cache metrics response.
 */
export interface AvailabilityCacheMetricsResponse {
  /** Availability cache metrics */
  availability_cache_metrics: AvailabilityCacheMetricsResponseAvailabilityCacheMetrics;
  /** Cache tier configuration */
  cache_tiers_info: AvailabilityCacheMetricsResponseCacheTiersInfo;
  /** Performance recommendations */
  recommendations: string[];
  /** Sample of top cached keys */
  top_cached_keys_sample: string[];
}

/**
 * Check if a specific time is available for booking.

Clean Architecture: Uses instructor, date, and time directly.
No slot references needed.
 */
export interface AvailabilityCheckRequest {
  /** Date to check */
  booking_date: string;
  /** End time to check */
  end_time: string;
  /** Instructor to check */
  instructor_id: string;
  /** Service to book */
  instructor_service_id: string;
  /** Start time to check */
  start_time: string;
}

export type AvailabilityCheckResponseConflictsWithAnyOfItem = { [key: string]: unknown };

export type AvailabilityCheckResponseConflictsWith = AvailabilityCheckResponseConflictsWithAnyOfItem[] | null;

export type AvailabilityCheckResponseMinAdvanceHours = number | null;

export type AvailabilityCheckResponseReason = string | null;

export type AvailabilityCheckResponseTimeInfoAnyOf = { [key: string]: unknown };

export type AvailabilityCheckResponseTimeInfo = AvailabilityCheckResponseTimeInfoAnyOf | null;

/**
 * Response for availability check.
 */
export interface AvailabilityCheckResponse {
  available: boolean;
  conflicts_with?: AvailabilityCheckResponseConflictsWith;
  min_advance_hours?: AvailabilityCheckResponseMinAdvanceHours;
  reason?: AvailabilityCheckResponseReason;
  time_info?: AvailabilityCheckResponseTimeInfo;
}

/**
 * Response schema for availability windows.
Clean Architecture: Only meaningful fields for single-table design.
 */
export interface AvailabilityWindowResponse {
  end_time: string;
  id: string;
  instructor_id: string;
  specific_date: string;
  start_time: string;
}

export type AvailabilityWindowUpdateEndTime = string | null;

export type AvailabilityWindowUpdateStartTime = string | null;

/**
 * Schema for updating an availability window.
 */
export interface AvailabilityWindowUpdate {
  end_time?: AvailabilityWindowUpdateEndTime;
  start_time?: AvailabilityWindowUpdateStartTime;
}

export interface BackupCodesResponse {
  backup_codes: string[];
}

export type BetaMetricsSummaryResponsePhaseCounts24h = {[key: string]: number};

export interface BetaMetricsSummaryResponse {
  invites_errors_24h: number;
  invites_sent_24h: number;
  phase_counts_24h: BetaMetricsSummaryResponsePhaseCounts24h;
}

/**
 * Response payload describing beta feature flags.
 */
export interface BetaSettingsResponse {
  allow_signup_without_invite: boolean;
  beta_disabled: boolean;
  beta_phase: string;
}

/**
 * Request payload for updating beta settings.
 */
export interface BetaSettingsUpdateRequest {
  allow_signup_without_invite: boolean;
  beta_disabled: boolean;
  beta_phase: string;
}

export type BlackoutDateCreateReason = string | null;

/**
 * Schema for creating a blackout date.
 */
export interface BlackoutDateCreate {
  date: string;
  reason?: BlackoutDateCreateReason;
}

export type BlackoutDateResponseReason = string | null;

/**
 * Response schema for blackout dates.
 */
export interface BlackoutDateResponse {
  created_at: string;
  date: string;
  id: string;
  instructor_id: string;
  reason?: BlackoutDateResponseReason;
}

export interface BodyDisputeCompletionApiV1InstructorBookingsBookingIdDisputePost {
  reason: string;
}

export type BodyLoginAuthLoginPostClientId = string | null;

export type BodyLoginAuthLoginPostClientSecret = string | null;

export type BodyLoginAuthLoginPostGrantType = string | null;

export interface BodyLoginAuthLoginPost {
  client_id?: BodyLoginAuthLoginPostClientId;
  client_secret?: BodyLoginAuthLoginPostClientSecret;
  grant_type?: BodyLoginAuthLoginPostGrantType;
  password: string;
  scope?: string;
  username: string;
}

export interface BodyProxyUploadToR2ApiUploadsR2ProxyPost {
  /** Content type reported by the browser */
  content_type: string;
  file: Blob;
  /** Temporary object key from the signed upload response */
  key: string;
}

export type BookedSlotsResponseBookedSlotsItem = { [key: string]: unknown };

export interface BookedSlotsResponse {
  /** List of booked slots with booking details */
  booked_slots: BookedSlotsResponseBookedSlotsItem[];
  week_end: string;
  week_start: string;
}

export interface BookingCancel {
  /**
   * Cancellation reason
   * @minLength 1
   * @maxLength 500
   */
  reason: string;
}

export interface BookingConfirmPayment {
  /** Stripe payment method ID from completed SetupIntent */
  payment_method_id: string;
  /** Whether to save this payment method for future use */
  save_payment_method?: boolean;
}

/**
 * Calculated end time (set automatically)
 */
export type BookingCreateEndTime = string | null;

/**
 * Type of meeting location
 */
export type BookingCreateLocationType = 'student_home' | 'instructor_location' | 'neutral' | 'remote' | 'in_person' | null;

/**
 * Specific meeting location if applicable
 */
export type BookingCreateMeetingLocation = string | null;

/**
 * Optional note from student
 */
export type BookingCreateStudentNote = string | null;

/**
 * Create a booking with self-contained time information.

Clean Architecture: No slot references - bookings are independent.
The booking contains all necessary information about when and where
the lesson will occur.
 */
export interface BookingCreate {
  /** Date of the booking */
  booking_date: string;
  /** Calculated end time (set automatically) */
  end_time?: BookingCreateEndTime;
  /** Instructor to book */
  instructor_id: string;
  /** Instructor service being booked */
  instructor_service_id: string;
  /** Type of meeting location */
  location_type?: BookingCreateLocationType;
  /** Specific meeting location if applicable */
  meeting_location?: BookingCreateMeetingLocation;
  /** Selected duration in minutes from service's duration_options */
  selected_duration: number;
  /** Start time */
  start_time: string;
  /** Optional note from student */
  student_note?: BookingCreateStudentNote;
}

export type BookingCreateResponseCancellationReason = string | null;

export type BookingCreateResponseCancelledAt = string | null;

export type BookingCreateResponseCancelledById = string | null;

export type BookingCreateResponseCompletedAt = string | null;

export type BookingCreateResponseConfirmedAt = string | null;

export type BookingCreateResponseInstructorNote = string | null;

export type BookingCreateResponseLocationType = string | null;

export type BookingCreateResponseMeetingLocation = string | null;

export type BookingCreateResponsePaymentSummary = PaymentSummary | null;

export type BookingCreateResponseRescheduledFrom = RescheduledFromInfo | null;

export type BookingCreateResponseRescheduledFromBookingId = string | null;

export type BookingCreateResponseServiceArea = string | null;

/**
 * Stripe SetupIntent client_secret for collecting payment method
 */
export type BookingCreateResponseSetupIntentClientSecret = string | null;

export type BookingCreateResponseStudentNote = string | null;

/**
 * Response after creating a booking with payment setup.

Includes SetupIntent client_secret for collecting payment method.
 */
export interface BookingCreateResponse {
  booking_date: string;
  cancellation_reason: BookingCreateResponseCancellationReason;
  cancelled_at: BookingCreateResponseCancelledAt;
  cancelled_by_id: BookingCreateResponseCancelledById;
  completed_at: BookingCreateResponseCompletedAt;
  confirmed_at: BookingCreateResponseConfirmedAt;
  created_at: string;
  duration_minutes: number;
  end_time: string;
  hourly_rate: number;
  id: string;
  instructor: AppSchemasBookingInstructorInfo;
  instructor_id: string;
  instructor_note: BookingCreateResponseInstructorNote;
  instructor_service: ServiceInfo;
  instructor_service_id: string;
  location_type: BookingCreateResponseLocationType;
  meeting_location: BookingCreateResponseMeetingLocation;
  payment_summary?: BookingCreateResponsePaymentSummary;
  /** Whether payment method is required before confirmation */
  requires_payment_method?: boolean;
  rescheduled_from?: BookingCreateResponseRescheduledFrom;
  rescheduled_from_booking_id?: BookingCreateResponseRescheduledFromBookingId;
  service_area: BookingCreateResponseServiceArea;
  service_name: string;
  /** Stripe SetupIntent client_secret for collecting payment method */
  setup_intent_client_secret?: BookingCreateResponseSetupIntentClientSecret;
  start_time: string;
  status: BookingStatus;
  student: StudentInfo;
  student_id: string;
  student_note: BookingCreateResponseStudentNote;
  total_price: number;
}

/**
 * Request to update a booking's payment method, with optional default flag.
 */
export interface BookingPaymentMethodUpdate {
  /** Stripe payment method ID */
  payment_method_id: string;
  /** Whether to save as default for the student */
  set_as_default?: boolean;
}

export type BookingPreviewResponseMeetingLocation = string | null;

export type BookingPreviewResponseServiceArea = string | null;

export type BookingPreviewResponseStudentNote = string | null;

/**
 * Response for booking preview with privacy protection.
 */
export interface BookingPreviewResponse {
  booking_date: string;
  booking_id: string;
  duration_minutes: number;
  end_time: string;
  instructor_first_name: string;
  instructor_last_name: string;
  location_type: string;
  location_type_display: string;
  meeting_location: BookingPreviewResponseMeetingLocation;
  service_area: BookingPreviewResponseServiceArea;
  service_name: string;
  start_time: string;
  status: string;
  student_first_name: string;
  student_last_name: string;
  student_note: BookingPreviewResponseStudentNote;
  total_price: number;
}

/**
 * Override service if needed (defaults to old)
 */
export type BookingRescheduleRequestInstructorServiceId = string | null;

/**
 * Request to reschedule an existing booking by specifying a new date/time and duration.

Frontend will subsequently create a new booking; this endpoint prepares the system by
cancelling the old booking according to policy and recording audit events.
 */
export interface BookingRescheduleRequest {
  /** New date for the lesson */
  booking_date: string;
  /** Override service if needed (defaults to old) */
  instructor_service_id?: BookingRescheduleRequestInstructorServiceId;
  /** New selected duration in minutes */
  selected_duration: number;
  /** New start time (HH:MM) */
  start_time: string;
}

export type BookingResponseCancellationReason = string | null;

export type BookingResponseCancelledAt = string | null;

export type BookingResponseCancelledById = string | null;

export type BookingResponseCompletedAt = string | null;

export type BookingResponseConfirmedAt = string | null;

export type BookingResponseInstructorNote = string | null;

export type BookingResponseLocationType = string | null;

export type BookingResponseMeetingLocation = string | null;

export type BookingResponsePaymentSummary = PaymentSummary | null;

export type BookingResponseRescheduledFrom = RescheduledFromInfo | null;

export type BookingResponseRescheduledFromBookingId = string | null;

export type BookingResponseServiceArea = string | null;

export type BookingResponseStudentNote = string | null;

/**
 * Complete booking response with privacy protection.

Shows instructor as "FirstName L" (last initial only).
Students see their own full information.
Clean Architecture: No availability slot references.
 */
export interface BookingResponse {
  booking_date: string;
  cancellation_reason: BookingResponseCancellationReason;
  cancelled_at: BookingResponseCancelledAt;
  cancelled_by_id: BookingResponseCancelledById;
  completed_at: BookingResponseCompletedAt;
  confirmed_at: BookingResponseConfirmedAt;
  created_at: string;
  duration_minutes: number;
  end_time: string;
  hourly_rate: number;
  id: string;
  instructor: AppSchemasBookingInstructorInfo;
  instructor_id: string;
  instructor_note: BookingResponseInstructorNote;
  instructor_service: ServiceInfo;
  instructor_service_id: string;
  location_type: BookingResponseLocationType;
  meeting_location: BookingResponseMeetingLocation;
  payment_summary?: BookingResponsePaymentSummary;
  rescheduled_from?: BookingResponseRescheduledFrom;
  rescheduled_from_booking_id?: BookingResponseRescheduledFromBookingId;
  service_area: BookingResponseServiceArea;
  service_name: string;
  start_time: string;
  status: BookingStatus;
  student: StudentInfo;
  student_id: string;
  student_note: BookingResponseStudentNote;
  total_price: number;
}

export type BookingStatsResponseAverageRating = number | null;

/**
 * Booking statistics for instructors.
 */
export interface BookingStatsResponse {
  average_rating?: BookingStatsResponseAverageRating;
  cancelled_bookings: number;
  completed_bookings: number;
  this_month_earnings: number;
  total_bookings: number;
  total_earnings: number;
  upcoming_bookings: number;
}

/**
 * Booking lifecycle statuses.
 */
export type BookingStatus = typeof BookingStatus[keyof typeof BookingStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BookingStatus = {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  NO_SHOW: 'NO_SHOW',
} as const;

export type BookingUpdateInstructorNote = string | null;

export type BookingUpdateMeetingLocation = string | null;

/**
 * Schema for updating booking details.

Limited fields can be updated after booking creation.
 */
export interface BookingUpdate {
  instructor_note?: BookingUpdateInstructorNote;
  meeting_location?: BookingUpdateMeetingLocation;
}

/**
 * Request schema for bulk availability update.
 */
export interface BulkUpdateRequest {
  operations: SlotOperation[];
  /** If true, only validate without making changes */
  validate_only?: boolean;
}

export interface BulkUpdateResponse {
  failed: number;
  results: OperationResult[];
  skipped: number;
  successful: number;
}

/**
 * Cache health and performance status.
 */
export interface CacheHealthStatus {
  /** Cache error count */
  errors: number;
  /** Cache hit rate percentage */
  hit_rate: string;
  /** Performance recommendations */
  recommendations: string[];
  /** Health status (healthy/degraded/unhealthy) */
  status: string;
  /** Total cache requests */
  total_requests: number;
}

/**
 * Availability-specific cache metrics
 */
export type CacheMetricsResponseAvailabilityMetrics = { [key: string]: unknown };

export type CacheMetricsResponseRedisInfoAnyOf = { [key: string]: unknown };

/**
 * Redis server information
 */
export type CacheMetricsResponseRedisInfo = CacheMetricsResponseRedisInfoAnyOf | null;

/**
 * Detailed cache metrics response.
 */
export interface CacheMetricsResponse {
  /** Availability-specific cache metrics */
  availability_metrics: CacheMetricsResponseAvailabilityMetrics;
  /** Cache errors */
  errors: number;
  /** Cache hit rate percentage */
  hit_rate: string;
  /** Cache hits */
  hits: number;
  /** Cache misses */
  misses: number;
  /** Cache performance insights */
  performance_insights: string[];
  /** Redis server information */
  redis_info?: CacheMetricsResponseRedisInfo;
}

export interface CandidateCategoryTrend {
  category: string;
  count: number;
  date: string;
}

export type CandidateCategoryTrendsResponse = CandidateCategoryTrend[];

export interface CandidateScoreDistributionResponse {
  gte_0_70_lt_0_80: number;
  gte_0_80_lt_0_90: number;
  gte_0_90: number;
  lt_0_70: number;
}

export type CandidateServiceQueriesResponse = CandidateServiceQuery[];

export type CandidateServiceQueryResultsCount = number | null;

export type CandidateServiceQueryScore = number | null;

export type CandidateServiceQuerySource = string | null;

export interface CandidateServiceQuery {
  position: number;
  results_count: CandidateServiceQueryResultsCount;
  score: CandidateServiceQueryScore;
  search_query: string;
  searched_at: string;
  source: CandidateServiceQuerySource;
}

export type CandidateSummaryResponseSourceBreakdown = {[key: string]: number};

export interface CandidateSummaryResponse {
  avg_candidates_per_event: number;
  events_with_candidates: number;
  source_breakdown: CandidateSummaryResponseSourceBreakdown;
  total_candidates: number;
  zero_result_events_with_candidates: number;
}

export interface CandidateTopService {
  active_instructors: number;
  avg_position: number;
  avg_score: number;
  candidate_count: number;
  category_name: string;
  opportunity_score: number;
  service_catalog_id: string;
  service_name: string;
}

export type CandidateTopServicesResponse = CandidateTopService[];

/**
 * Minimal catalog service response for pills/lists.
 */
export interface CatalogServiceMinimalResponse {
  id: string;
  name: string;
  slug: string;
}

export type CatalogServiceResponseCategory = string | null;

export type CatalogServiceResponseDescription = string | null;

export type CatalogServiceResponseDisplayOrder = number | null;

export type CatalogServiceResponseMaxRecommendedPrice = number | null;

export type CatalogServiceResponseMinRecommendedPrice = number | null;

export type CatalogServiceResponseOnlineCapable = boolean | null;

export type CatalogServiceResponseRequiresCertification = boolean | null;

/**
 * Catalog service response.
 */
export interface CatalogServiceResponse {
  category?: CatalogServiceResponseCategory;
  category_id: string;
  description?: CatalogServiceResponseDescription;
  display_order?: CatalogServiceResponseDisplayOrder;
  id: string;
  max_recommended_price?: CatalogServiceResponseMaxRecommendedPrice;
  min_recommended_price?: CatalogServiceResponseMinRecommendedPrice;
  name: string;
  online_capable?: CatalogServiceResponseOnlineCapable;
  requires_certification?: CatalogServiceResponseRequiresCertification;
  search_terms?: string[];
  slug: string;
  typical_duration_options?: number[];
}

export type CategoryResponseDescription = string | null;

export type CategoryResponseIconName = string | null;

export type CategoryResponseSubtitle = string | null;

/**
 * Service category response.
 */
export interface CategoryResponse {
  description?: CategoryResponseDescription;
  display_order: number;
  icon_name?: CategoryResponseIconName;
  id: string;
  name: string;
  slug: string;
  subtitle?: CategoryResponseSubtitle;
}

export type CategoryServiceDetailActualMaxPrice = number | null;

export type CategoryServiceDetailActualMinPrice = number | null;

export type CategoryServiceDetailDescription = string | null;

export type CategoryServiceDetailDisplayOrder = number | null;

export type CategoryServiceDetailIsActive = boolean | null;

export type CategoryServiceDetailOnlineCapable = boolean | null;

export type CategoryServiceDetailRequiresCertification = boolean | null;

/**
 * Detailed catalog service information with instructor analytics.
 */
export interface CategoryServiceDetail {
  active_instructors?: number;
  actual_max_price?: CategoryServiceDetailActualMaxPrice;
  actual_min_price?: CategoryServiceDetailActualMinPrice;
  category_id: string;
  demand_score?: number;
  description?: CategoryServiceDetailDescription;
  display_order?: CategoryServiceDetailDisplayOrder;
  id: string;
  instructor_count?: number;
  is_active?: CategoryServiceDetailIsActive;
  is_trending?: boolean;
  name: string;
  online_capable?: CategoryServiceDetailOnlineCapable;
  requires_certification?: CategoryServiceDetailRequiresCertification;
  search_terms?: string[];
  slug: string;
}

export type CategoryWithServicesDescription = string | null;

export type CategoryWithServicesIconName = string | null;

export type CategoryWithServicesSubtitle = string | null;

/**
 * Category record containing detailed services.
 */
export interface CategoryWithServices {
  description?: CategoryWithServicesDescription;
  icon_name?: CategoryWithServicesIconName;
  id: string;
  name: string;
  services?: CategoryServiceDetail[];
  slug: string;
  subtitle?: CategoryWithServicesSubtitle;
}

export interface CheckoutApplyRequest {
  order_id: string;
}

export interface CheckoutApplyResponse {
  applied_cents: number;
}

/**
 * Client secret for frontend confirmation
 */
export type CheckoutResponseClientSecret = string | null;

export interface CheckoutResponse {
  /** Payment amount in cents */
  amount: number;
  /** Platform fee in cents */
  application_fee: number;
  /** Client secret for frontend confirmation */
  client_secret?: CheckoutResponseClientSecret;
  /** Stripe payment intent ID */
  payment_intent_id: string;
  /** Whether payment requires additional action */
  requires_action?: boolean;
  /** Payment status */
  status: string;
  /** Whether payment was successful */
  success: boolean;
}

export interface CodebaseCategoryStats {
  /** @minimum 0 */
  files: number;
  /** @minimum 0 */
  lines: number;
}

export interface CodebaseFileInfo {
  /** @minimum 0 */
  lines: number;
  /** @minimum 0 */
  lines_with_blanks: number;
  path: string;
  /** @minimum 0 */
  size_kb: number;
}

export type CodebaseHistoryEntryCategoriesAnyOf = {[key: string]: {[key: string]: CodebaseCategoryStats}};

export type CodebaseHistoryEntryCategories = CodebaseHistoryEntryCategoriesAnyOf | null;

export interface CodebaseHistoryEntry {
  /** @minimum 0 */
  backend_lines: number;
  categories?: CodebaseHistoryEntryCategories;
  /** @minimum 0 */
  frontend_lines: number;
  /** @minimum 0 */
  git_commits: number;
  timestamp: string;
  /** @minimum 0 */
  total_files: number;
  /** @minimum 0 */
  total_lines: number;
}

export type CodebaseHistoryResponseCurrent = CodebaseMetricsResponse | null;

export interface CodebaseHistoryResponse {
  current?: CodebaseHistoryResponseCurrent;
  items?: CodebaseHistoryEntry[];
}

export interface CodebaseMetricsResponse {
  backend: CodebaseSection;
  frontend: CodebaseSection;
  git: GitStats;
  summary: CodebaseMetricsSummary;
  timestamp: string;
}

export interface CodebaseMetricsSummary {
  /** @minimum 0 */
  total_files: number;
  /** @minimum 0 */
  total_lines: number;
}

export type CodebaseSectionCategories = {[key: string]: CodebaseCategoryStats};

export interface CodebaseSection {
  categories?: CodebaseSectionCategories;
  largest_files?: CodebaseFileInfo[];
  /** @minimum 0 */
  total_files: number;
  /** @minimum 0 */
  total_lines: number;
  /** @minimum 0 */
  total_lines_with_blanks: number;
}

/**
 * Conversion behavior metrics.
 */
export interface ConversionBehavior {
  /** Average days to conversion */
  avg_days_to_conversion: number;
  /** Average searches before conversion */
  avg_searches_before_conversion: number;
  /** Most common first search query */
  most_common_first_search: string;
}

/**
 * Guest-to-user conversion metrics response.
 */
export interface ConversionMetricsResponse {
  /** Conversion behavior patterns */
  conversion_behavior: ConversionBehavior;
  /** Guest engagement metrics */
  guest_engagement: GuestEngagement;
  /** Guest session conversion metrics */
  guest_sessions: GuestConversionMetrics;
  /** Time period for metrics */
  period: DateRange;
}

/**
 * Schema for copying availability between weeks.
 */
export interface CopyWeekRequest {
  from_week_start: string;
  to_week_start: string;
}

export interface CopyWeekResponse {
  message: string;
  source_week_start: string;
  target_week_start: string;
  windows_copied: number;
}

export type CoverageFeatureCollectionResponseFeaturesItem = { [key: string]: unknown };

export interface CoverageFeatureCollectionResponse {
  features: CoverageFeatureCollectionResponseFeaturesItem[];
  type: string;
}

/**
 * Stripe payment method ID to use when a balance remains
 */
export type CreateCheckoutRequestPaymentMethodId = string | null;

/**
 * Optional wallet credit amount (in cents) the student wants to apply
 */
export type CreateCheckoutRequestRequestedCreditCents = number | null;

/**
 * Request to create a checkout/payment for a booking.
 */
export interface CreateCheckoutRequest {
  /** Booking ID to process payment for */
  booking_id: string;
  /** Stripe payment method ID to use when a balance remains */
  payment_method_id?: CreateCheckoutRequestPaymentMethodId;
  /** Optional wallet credit amount (in cents) the student wants to apply */
  requested_credit_cents?: CreateCheckoutRequestRequestedCreditCents;
  /** Whether to save payment method for future use */
  save_payment_method?: boolean;
}

export type CreateSignedUploadRequestPurpose = typeof CreateSignedUploadRequestPurpose[keyof typeof CreateSignedUploadRequestPurpose];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateSignedUploadRequestPurpose = {
  background_check: 'background_check',
  profile_picture: 'profile_picture',
} as const;

export interface CreateSignedUploadRequest {
  /** Browser-reported MIME type */
  content_type: string;
  /** Original file name, used for extension validation */
  filename: string;
  purpose: CreateSignedUploadRequestPurpose;
  /**
   * Max 10MB
   * @minimum 1
   * @maximum 10485760
   */
  size_bytes: number;
}

/**
 * Credit expiration date
 */
export type CreditBalanceResponseExpiresAt = string | null;

export interface CreditBalanceResponse {
  /** Available credit balance */
  available: number;
  /** Credit expiration date */
  expires_at?: CreditBalanceResponseExpiresAt;
  /** Pending credits */
  pending: number;
}

/**
 * Daily alert count for summary.
 */
export interface DailyAlertCount {
  /** Number of alerts on this date */
  count: number;
  /** Date in YYYY-MM-DD format */
  date: string;
}

/**
 * Daily search trend data.
 */
export interface DailySearchTrend {
  /** Date in ISO format */
  date: string;
  /** Total searches for the day */
  total_searches: number;
  /** Unique guest sessions */
  unique_guests: number;
  /** Unique authenticated users */
  unique_users: number;
}

export interface DashboardLinkResponse {
  /** URL to Stripe Express dashboard */
  dashboard_url: string;
  /** Minutes until link expires */
  expires_in_minutes?: number;
}

/**
 * The exported user data
 */
export type DataExportResponseData = { [key: string]: unknown };

export interface DataExportResponse {
  /** The exported user data */
  data: DataExportResponseData;
  /** Human-readable message */
  message: string;
  /** Status of the export request */
  status: string;
}

/**
 * Error message if unhealthy
 */
export type DatabaseHealthResponseError = string | null;

export type DatabaseHealthResponsePoolStatusAnyOf = { [key: string]: unknown };

/**
 * Connection pool status
 */
export type DatabaseHealthResponsePoolStatus = DatabaseHealthResponsePoolStatusAnyOf | null;

/**
 * Response for database health check endpoint.
 */
export interface DatabaseHealthResponse {
  /** Error message if unhealthy */
  error?: DatabaseHealthResponseError;
  /** Health check message */
  message: string;
  /** Connection pool status */
  pool_status?: DatabaseHealthResponsePoolStatus;
  /** Health status (healthy/unhealthy) */
  status: string;
}

export type DatabasePoolStatusResponseConfiguration = { [key: string]: unknown };

export type DatabasePoolStatusResponsePool = { [key: string]: unknown };

export type DatabasePoolStatusResponseRecommendations = { [key: string]: unknown };

export interface DatabasePoolStatusResponse {
  configuration: DatabasePoolStatusResponseConfiguration;
  pool: DatabasePoolStatusResponsePool;
  recommendations: DatabasePoolStatusResponseRecommendations;
  status: string;
}

export type DatabaseStatsResponseConfiguration = { [key: string]: unknown };

export type DatabaseStatsResponseHealth = { [key: string]: unknown };

export type DatabaseStatsResponsePool = { [key: string]: unknown };

export interface DatabaseStatsResponse {
  configuration: DatabaseStatsResponseConfiguration;
  health: DatabaseStatsResponseHealth;
  pool: DatabaseStatsResponsePool;
  status: string;
}

/**
 * Date range for analytics.
 */
export interface DateRange {
  /** Number of days in range */
  days: number;
  /** End date in ISO format */
  end: string;
  /** Start date in ISO format */
  start: string;
}

export interface DeleteBlackoutResponse {
  blackout_id: string;
  message?: string;
}

export interface DeleteMessageResponse {
  /** Success message */
  message?: string;
  success?: boolean;
}

export interface DeleteWindowResponse {
  message?: string;
  window_id: string;
}

/**
 * Average earning per booking
 */
export type EarningsResponseAverageEarning = number | null;

/**
 * Number of bookings
 */
export type EarningsResponseBookingCount = number | null;

/**
 * Total hours invoiced for completed lessons
 */
export type EarningsResponseHoursInvoiced = number | null;

/**
 * End of period
 */
export type EarningsResponsePeriodEnd = string | null;

/**
 * Start of period
 */
export type EarningsResponsePeriodStart = string | null;

/**
 * Number of completed services contributing to earnings
 */
export type EarningsResponseServiceCount = number | null;

/**
 * Total earnings in cents
 */
export type EarningsResponseTotalEarned = number | null;

/**
 * Total fees in cents
 */
export type EarningsResponseTotalFees = number | null;

export interface EarningsResponse {
  /** Average earning per booking */
  average_earning?: EarningsResponseAverageEarning;
  /** Number of bookings */
  booking_count?: EarningsResponseBookingCount;
  /** Total hours invoiced for completed lessons */
  hours_invoiced?: EarningsResponseHoursInvoiced;
  /** Recent invoices contributing to earnings */
  invoices?: InstructorInvoiceSummary[];
  /** End of period */
  period_end?: EarningsResponsePeriodEnd;
  /** Start of period */
  period_start?: EarningsResponsePeriodStart;
  /** Number of completed services contributing to earnings */
  service_count?: EarningsResponseServiceCount;
  /** Total earnings in cents */
  total_earned?: EarningsResponseTotalEarned;
  /** Total fees in cents */
  total_fees?: EarningsResponseTotalFees;
}

export interface EditMessageRequest {
  content: string;
}

export type ExistingReviewIdsResponse = string[];

/**
 * Download URL when ready
 */
export type ExportAnalyticsResponseDownloadUrl = string | null;

/**
 * Analytics export response.
 */
export interface ExportAnalyticsResponse {
  /** Download URL when ready */
  download_url?: ExportAnalyticsResponseDownloadUrl;
  /** Export format (csv, xlsx, json) */
  format: string;
  /** Status message */
  message: string;
  /** Export status */
  status: string;
  /** User email who requested export */
  user: string;
}

/**
 * Basic cache statistics
 */
export type ExtendedCacheStatsBasicStats = { [key: string]: unknown };

export type ExtendedCacheStatsKeyPatternsAnyOf = {[key: string]: number};

/**
 * Cache key pattern counts
 */
export type ExtendedCacheStatsKeyPatterns = ExtendedCacheStatsKeyPatternsAnyOf | null;

export type ExtendedCacheStatsRedisInfoAnyOf = { [key: string]: unknown };

/**
 * Redis server information
 */
export type ExtendedCacheStatsRedisInfo = ExtendedCacheStatsRedisInfoAnyOf | null;

/**
 * Extended cache statistics.
 */
export interface ExtendedCacheStats {
  /** Basic cache statistics */
  basic_stats: ExtendedCacheStatsBasicStats;
  /** Cache key pattern counts */
  key_patterns?: ExtendedCacheStatsKeyPatterns;
  /** Redis server information */
  redis_info?: ExtendedCacheStatsRedisInfo;
}

/**
 * True if already favorited (for add)
 */
export type FavoriteResponseAlreadyFavorited = boolean | null;

/**
 * ID of the created favorite (for add operations)
 */
export type FavoriteResponseFavoriteId = string | null;

/**
 * True if not favorited (for remove)
 */
export type FavoriteResponseNotFavorited = boolean | null;

/**
 * Response for favorite add/remove operations.
 */
export interface FavoriteResponse {
  /** True if already favorited (for add) */
  already_favorited?: FavoriteResponseAlreadyFavorited;
  /** ID of the created favorite (for add operations) */
  favorite_id?: FavoriteResponseFavoriteId;
  /** Human-readable message about the operation */
  message: string;
  /** True if not favorited (for remove) */
  not_favorited?: FavoriteResponseNotFavorited;
  /** Whether the operation was successful */
  success: boolean;
}

/**
 * Response for single favorite status check.
 */
export interface FavoriteStatusResponse {
  /** Whether the instructor is favorited */
  is_favorited: boolean;
}

/**
 * When this instructor was favorited
 */
export type FavoritedInstructorFavoritedAt = string | null;

/**
 * Instructor profile details
 */
export type FavoritedInstructorProfile = InstructorProfileResponse | null;

/**
 * Instructor with favorite metadata.
 */
export interface FavoritedInstructor {
  /** Instructor email */
  email: string;
  /** When this instructor was favorited */
  favorited_at?: FavoritedInstructorFavoritedAt;
  /** Instructor first name */
  first_name: string;
  /** Instructor user ID (ULID) */
  id: string;
  /** Whether the instructor is active */
  is_active?: boolean;
  /** Instructor last name */
  last_name: string;
  /** Instructor profile details */
  profile?: FavoritedInstructorProfile;
}

/**
 * List of favorited instructors.
 */
export interface FavoritesList {
  /** List of favorited instructors */
  favorites: FavoritedInstructor[];
  /** Total number of favorites */
  total: number;
}

export interface FinalizeProfilePicturePayload {
  object_key: string;
}

export interface FinalizeProfilePictureRequest {
  /** Temporary upload object key from signed PUT */
  object_key: string;
}

/**
 * Simple response indicating gated ping success.
 */
export interface GatedPingResponse {
  ok: boolean;
}

export interface GitStats {
  current_branch: string;
  first_commit: string;
  last_commit: string;
  /** @minimum 0 */
  total_commits: number;
  /** @minimum 0 */
  unique_contributors: number;
}

/**
 * Guest session conversion metrics.
 */
export interface GuestConversionMetrics {
  /** Conversion rate percentage */
  conversion_rate: number;
  /** Number of converted sessions */
  converted: number;
  /** Total guest sessions */
  total: number;
}

/**
 * Guest engagement metrics.
 */
export interface GuestEngagement {
  /** Average searches per guest session */
  avg_searches_per_session: number;
  /** Sessions with multiple searches */
  engaged_sessions: number;
  /** Percentage of engaged sessions */
  engagement_rate: number;
}

/**
 * Number of results returned
 */
export type GuestSearchHistoryCreateResultsCount = number | null;

/**
 * Schema for creating guest search history (no user_id required).
 */
export interface GuestSearchHistoryCreate {
  /**
   * UUID for guest session tracking
   * @maxLength 36
   */
  guest_session_id: string;
  /** Number of results returned */
  results_count?: GuestSearchHistoryCreateResultsCount;
  /**
   * The search query string
   * @minLength 1
   */
  search_query: string;
  /** Type of search: natural_language, category, service_pill, filter, or search_history */
  search_type?: string;
}

export interface GuestSessionResponse {
  guest_id: string;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

/**
 * Individual component health checks
 */
export type HealthCheckResponseChecks = {[key: string]: boolean};

/**
 * Standard health check response.
 */
export interface HealthCheckResponse {
  /** Individual component health checks */
  checks: HealthCheckResponseChecks;
  /** Service name */
  service?: string;
  /**
   * Service health status
   * @pattern ^(healthy|degraded|unhealthy)$
   */
  status: string;
  /** Check timestamp */
  timestamp?: string;
  /** API version */
  version: string;
}

export interface IdentityRefreshResponse {
  /** Latest verification status from Stripe */
  status: string;
  /** Whether the user is now verified */
  verified: boolean;
}

export interface IdentitySessionResponse {
  /** Client secret for the verification session */
  client_secret: string;
  /** Stripe verification session identifier */
  verification_session_id: string;
}

/**
 * Stripe payout identifier if one was created
 */
export type InstantPayoutResponsePayoutId = string | null;

/**
 * Stripe status of the payout (e.g., pending, paid)
 */
export type InstantPayoutResponseStatus = string | null;

export interface InstantPayoutResponse {
  /** Whether the instant payout request succeeded */
  ok: boolean;
  /** Stripe payout identifier if one was created */
  payout_id?: InstantPayoutResponsePayoutId;
  /** Stripe status of the payout (e.g., pending, paid) */
  status?: InstantPayoutResponseStatus;
}

/**
 * Duration of the lesson in minutes
 */
export type InstructorInvoiceSummaryDurationMinutes = number | null;

/**
 * Name of the service taught
 */
export type InstructorInvoiceSummaryServiceName = string | null;

/**
 * Lesson start time
 */
export type InstructorInvoiceSummaryStartTime = string | null;

/**
 * Student name (privacy aware)
 */
export type InstructorInvoiceSummaryStudentName = string | null;

export interface InstructorInvoiceSummary {
  /** Associated booking ID */
  booking_id: string;
  /** When the payment was completed */
  created_at: string;
  /** Duration of the lesson in minutes */
  duration_minutes?: InstructorInvoiceSummaryDurationMinutes;
  /** Net payout to the instructor after fees (in cents) */
  instructor_share_cents: number;
  /** Date of the lesson */
  lesson_date: string;
  /** Name of the service taught */
  service_name?: InstructorInvoiceSummaryServiceName;
  /** Lesson start time */
  start_time?: InstructorInvoiceSummaryStartTime;
  /** Invoice/payment status */
  status: string;
  /** Student name (privacy aware) */
  student_name?: InstructorInvoiceSummaryStudentName;
  /** Tip amount included with the payment in cents */
  tip_cents: number;
  /** Total amount paid by the student in cents */
  total_paid_cents: number;
}

/**
 * Schema for creating an instructor profile.

Requires at least one service to be defined.
 */
export interface InstructorProfileCreate {
  /**
   * Instructor biography/description
   * @minLength 10
   * @maxLength 1000
   */
  bio: string;
  /**
   * Buffer time between bookings
   * @minimum 0
   * @maximum 60
   */
  buffer_time_minutes?: number;
  /**
   * Minimum hours in advance for bookings
   * @minimum 0
   * @maximum 168
   */
  min_advance_booking_hours?: number;
  /**
   * Services offered by the instructor
   * @minItems 1
   * @maxItems 20
   */
  services: ServiceCreate[];
  /**
   * Years of teaching experience
   * @minimum 0
   * @maximum 50
   */
  years_experience: number;
}

export type InstructorProfileResponseBackgroundCheckObjectKey = string | null;

export type InstructorProfileResponseBackgroundCheckUploadedAt = string | null;

export type InstructorProfileResponseIdentityVerificationSessionId = string | null;

export type InstructorProfileResponseIdentityVerifiedAt = string | null;

/**
 * Whether the current user has favorited this instructor
 */
export type InstructorProfileResponseIsFavorited = boolean | null;

export type InstructorProfileResponseOnboardingCompletedAt = string | null;

export type InstructorProfileResponseServiceAreaSummary = string | null;

export type InstructorProfileResponseUpdatedAt = string | null;

/**
 * Schema for instructor profile responses with privacy protection.

Includes all profile data plus relationships and metadata.
Student-facing endpoints will show only instructor last initial.
 */
export interface InstructorProfileResponse {
  background_check_object_key?: InstructorProfileResponseBackgroundCheckObjectKey;
  background_check_uploaded_at?: InstructorProfileResponseBackgroundCheckUploadedAt;
  /**
   * Instructor biography/description
   * @minLength 10
   * @maxLength 1000
   */
  bio: string;
  /**
   * Buffer time between bookings
   * @minimum 0
   * @maximum 60
   */
  buffer_time_minutes?: number;
  created_at: string;
  /** Number of students who favorited this instructor */
  favorited_count?: number;
  id: string;
  identity_verification_session_id?: InstructorProfileResponseIdentityVerificationSessionId;
  identity_verified_at?: InstructorProfileResponseIdentityVerifiedAt;
  /** Whether the current user has favorited this instructor */
  is_favorited?: InstructorProfileResponseIsFavorited;
  is_live?: boolean;
  /**
   * Minimum hours in advance for bookings
   * @minimum 0
   * @maximum 168
   */
  min_advance_booking_hours?: number;
  onboarding_completed_at?: InstructorProfileResponseOnboardingCompletedAt;
  preferred_public_spaces?: PreferredPublicSpaceOut[];
  preferred_teaching_locations?: PreferredTeachingLocationOut[];
  service_area_boroughs?: string[];
  service_area_neighborhoods?: ServiceAreaNeighborhood[];
  service_area_summary?: InstructorProfileResponseServiceAreaSummary;
  services: ServiceResponse[];
  /** Whether skills/pricing were configured at least once */
  skills_configured?: boolean;
  updated_at?: InstructorProfileResponseUpdatedAt;
  user: UserBasicPrivacy;
  user_id: string;
  /**
   * Years of teaching experience
   * @minimum 0
   * @maximum 50
   */
  years_experience: number;
}

export type InstructorProfileUpdateBio = string | null;

/**
 * Buffer time between bookings
 */
export type InstructorProfileUpdateBufferTimeMinutes = number | null;

/**
 * Minimum hours in advance for bookings
 */
export type InstructorProfileUpdateMinAdvanceBookingHours = number | null;

export type InstructorProfileUpdatePreferredPublicSpaces = PreferredPublicSpaceIn[] | null;

export type InstructorProfileUpdatePreferredTeachingLocations = PreferredTeachingLocationIn[] | null;

export type InstructorProfileUpdateServices = ServiceCreate[] | null;

export type InstructorProfileUpdateYearsExperience = number | null;

/**
 * Schema for updating an instructor profile.

All fields are optional for partial updates.
 */
export interface InstructorProfileUpdate {
  bio?: InstructorProfileUpdateBio;
  /** Buffer time between bookings */
  buffer_time_minutes?: InstructorProfileUpdateBufferTimeMinutes;
  /** Minimum hours in advance for bookings */
  min_advance_booking_hours?: InstructorProfileUpdateMinAdvanceBookingHours;
  preferred_public_spaces?: InstructorProfileUpdatePreferredPublicSpaces;
  preferred_teaching_locations?: InstructorProfileUpdatePreferredTeachingLocations;
  services?: InstructorProfileUpdateServices;
  years_experience?: InstructorProfileUpdateYearsExperience;
}

export type InstructorRatingsResponseByServiceItem = { [key: string]: unknown };

export type InstructorRatingsResponseOverall = { [key: string]: unknown };

export interface InstructorRatingsResponse {
  by_service?: InstructorRatingsResponseByServiceItem[];
  /** @pattern ^(new|establishing|established|trusted)$ */
  confidence_level: string;
  overall: InstructorRatingsResponseOverall;
}

/**
 * Parsed query information
 */
export type InstructorSearchResponseParsed = { [key: string]: unknown };

/**
 * Response for instructor search endpoint.
 */
export interface InstructorSearchResponse {
  /** Parsed query information */
  parsed: InstructorSearchResponseParsed;
  /** Original search query */
  query: string;
  /** Search results */
  results: SearchResult[];
  /** Search metadata */
  search_metadata: SearchMetadata;
  /** Total number of results found */
  total_found: number;
}

/**
 * Custom description (optional)
 */
export type InstructorServiceCreateCustomDescription = string | null;

/**
 * Custom duration options in minutes (uses catalog defaults if not provided)
 */
export type InstructorServiceCreateDurationOptions = number[] | null;

/**
 * Create instructor service from catalog.
 */
export interface InstructorServiceCreate {
  /** ID of the catalog service */
  catalog_service_id: string;
  /** Custom description (optional) */
  custom_description?: InstructorServiceCreateCustomDescription;
  /** Custom duration options in minutes (uses catalog defaults if not provided) */
  duration_options?: InstructorServiceCreateDurationOptions;
  /**
   * Hourly rate for this service
   */
  hourly_rate: number;
}

export type InstructorServiceResponseCreatedAt = string | null;

export type InstructorServiceResponseDescription = string | null;

export type InstructorServiceResponseUpdatedAt = string | null;

/**
 * Instructor service response with catalog info.
 */
export interface InstructorServiceResponse {
  catalog_service_id: string;
  category: string;
  created_at?: InstructorServiceResponseCreatedAt;
  description?: InstructorServiceResponseDescription;
  duration_options?: number[];
  hourly_rate: number;
  id: string;
  is_active?: boolean;
  name: string;
  updated_at?: InstructorServiceResponseUpdatedAt;
}

export interface InviteBatchAsyncStartResponse {
  task_id: string;
}

export type InviteBatchProgressResponseFailedItems = InviteBatchSendFailure[] | null;

export type InviteBatchProgressResponseSentItems = InviteSendResponse[] | null;

export interface InviteBatchProgressResponse {
  current: number;
  failed: number;
  failed_items?: InviteBatchProgressResponseFailedItems;
  sent: number;
  sent_items?: InviteBatchProgressResponseSentItems;
  state: string;
  task_id: string;
  total: number;
}

export interface InviteBatchSendFailure {
  email: string;
  reason: string;
}

export type InviteBatchSendRequestBaseUrl = string | null;

export type InviteBatchSendRequestSource = string | null;

export interface InviteBatchSendRequest {
  base_url?: InviteBatchSendRequestBaseUrl;
  /** @minItems 1 */
  emails?: string[];
  /**
   * @minimum 1
   * @maximum 180
   */
  expires_in_days?: number;
  role?: string;
  source?: InviteBatchSendRequestSource;
}

export interface InviteBatchSendResponse {
  failed: InviteBatchSendFailure[];
  sent: InviteSendResponse[];
}

export interface InviteConsumeRequest {
  code: string;
  phase?: string;
  role?: string;
  user_id: string;
}

export type InviteGenerateRequestEmails = string[] | null;

export type InviteGenerateRequestSource = string | null;

export interface InviteGenerateRequest {
  count?: number;
  emails?: InviteGenerateRequestEmails;
  expires_in_days?: number;
  role?: string;
  source?: InviteGenerateRequestSource;
}

export interface InviteGenerateResponse {
  invites: InviteRecord[];
}

export type InviteRecordEmail = string | null;

export interface InviteRecord {
  code: string;
  email?: InviteRecordEmail;
  expires_at: string;
  id: string;
  role: string;
}

export type InviteSendRequestBaseUrl = string | null;

export type InviteSendRequestSource = string | null;

export interface InviteSendRequest {
  base_url?: InviteSendRequestBaseUrl;
  /**
   * @minimum 1
   * @maximum 180
   */
  expires_in_days?: number;
  role?: string;
  source?: InviteSendRequestSource;
  to_email: string;
}

export interface InviteSendResponse {
  code: string;
  email: string;
  id: string;
  join_url: string;
  welcome_url: string;
}

export type InviteValidateResponseCode = string | null;

export type InviteValidateResponseEmail = string | null;

export type InviteValidateResponseExpiresAt = string | null;

export type InviteValidateResponseReason = string | null;

export type InviteValidateResponseRole = string | null;

export type InviteValidateResponseUsedAt = string | null;

export interface InviteValidateResponse {
  code?: InviteValidateResponseCode;
  email?: InviteValidateResponseEmail;
  expires_at?: InviteValidateResponseExpiresAt;
  reason?: InviteValidateResponseReason;
  role?: InviteValidateResponseRole;
  used_at?: InviteValidateResponseUsedAt;
  valid: boolean;
}

/**
 * Simplified alert item for live view.
 */
export interface LiveAlertItem {
  /** Alert message (truncated if long) */
  message: string;
  /** Alert severity (uppercase) */
  severity: string;
  /** Time in HH:MM:SS format */
  time: string;
  /** Alert type */
  type: string;
}

/**
 * Response for live alerts endpoint.
 */
export interface LiveAlertsResponse {
  /** List of recent alerts */
  alerts: LiveAlertItem[];
  /** Number of alerts in the time period */
  count: number;
  /** Number of minutes included */
  minutes: number;
}

export type LoginResponseAccessToken = string | null;

export type LoginResponseTempToken = string | null;

export type LoginResponseTokenType = string | null;

export interface LoginResponse {
  access_token?: LoginResponseAccessToken;
  requires_2fa?: boolean;
  temp_token?: LoginResponseTempToken;
  token_type?: LoginResponseTokenType;
}

/**
 * Mark all messages in this booking as read
 */
export type MarkMessagesReadRequestBookingId = string | null;

/**
 * Specific message IDs to mark as read
 */
export type MarkMessagesReadRequestMessageIds = string[] | null;

/**
 * Request to mark messages as read.
 */
export interface MarkMessagesReadRequest {
  /** Mark all messages in this booking as read */
  booking_id?: MarkMessagesReadRequestBookingId;
  /** Specific message IDs to mark as read */
  message_ids?: MarkMessagesReadRequestMessageIds;
}

export interface MarkMessagesReadResponse {
  /** Number of messages marked as read */
  messages_marked: number;
  success?: boolean;
}

/**
 * System memory metrics.
 */
export interface MemoryMetrics {
  /** Memory usage percentage */
  percent: number;
  /** Total memory in MB */
  total_mb: number;
  /** Used memory in MB */
  used_mb: number;
}

export interface MessageConfigResponse {
  edit_window_minutes: number;
}

export type MessageResponseDeliveredAt = string | null;

export type MessageResponseEditedAt = string | null;

export type MessageResponseMyReactions = string[] | null;

export type MessageResponseReactionsAnyOf = { [key: string]: unknown };

export type MessageResponseReactions = MessageResponseReactionsAnyOf | null;

export type MessageResponseReadByAnyOfItem = { [key: string]: unknown };

export type MessageResponseReadBy = MessageResponseReadByAnyOfItem[] | null;

export type MessageResponseSender = MessageSenderResponse | null;

/**
 * Response schema for a single message.
 */
export interface MessageResponse {
  booking_id: string;
  content: string;
  created_at: string;
  delivered_at?: MessageResponseDeliveredAt;
  edited_at?: MessageResponseEditedAt;
  id: string;
  is_deleted?: boolean;
  my_reactions?: MessageResponseMyReactions;
  reactions?: MessageResponseReactions;
  read_by?: MessageResponseReadBy;
  sender?: MessageResponseSender;
  sender_id: string;
  updated_at: string;
}

/**
 * Response schema for message sender info.
 */
export interface MessageSenderResponse {
  email: string;
  first_name: string;
  id: string;
  last_name: string;
}

export interface MessagesHistoryResponse {
  booking_id: string;
  has_more: boolean;
  limit: number;
  messages: MessageResponse[];
  offset: number;
}

/**
 * Database metrics and pool status
 */
export type MonitoringDashboardResponseDatabase = { [key: string]: unknown };

/**
 * Comprehensive monitoring dashboard response.
 */
export interface MonitoringDashboardResponse {
  /** Active system alerts */
  alerts: AlertInfo[];
  /** Cache health status */
  cache: CacheHealthStatus;
  /** Database metrics and pool status */
  database: MonitoringDashboardResponseDatabase;
  /** System memory metrics */
  memory: MemoryMetrics;
  /** Performance recommendations */
  recommendations: PerformanceRecommendation[];
  /** Request processing metrics */
  requests: RequestMetrics;
  /** Overall system status */
  status: string;
  /** Dashboard snapshot timestamp */
  timestamp: string;
}

export type NYCZipCheckResponseBorough = string | null;

/**
 * Response payload for lightweight NYC ZIP verification.
 */
export interface NYCZipCheckResponse {
  borough?: NYCZipCheckResponseBorough;
  is_nyc: boolean;
}

export type NeighborhoodItemBorough = string | null;

export type NeighborhoodItemCode = string | null;

/**
 * Single neighborhood entry with optional borough metadata.
 */
export interface NeighborhoodItem {
  borough?: NeighborhoodItemBorough;
  code?: NeighborhoodItemCode;
  id: string;
  name: string;
}

export type NeighborhoodsListResponsePage = number | null;

export type NeighborhoodsListResponsePerPage = number | null;

/**
 * Paginated list of neighborhoods.
 */
export interface NeighborhoodsListResponse {
  items: NeighborhoodItem[];
  page?: NeighborhoodsListResponsePage;
  per_page?: NeighborhoodsListResponsePerPage;
  total: number;
}

/**
 * Date of the next available slot (YYYY-MM-DD)
 */
export type NextAvailableSlotResponseDate = string | null;

/**
 * Duration in minutes
 */
export type NextAvailableSlotResponseDurationMinutes = number | null;

/**
 * End time (HH:MM:SS)
 */
export type NextAvailableSlotResponseEndTime = string | null;

/**
 * Message when no slot is found
 */
export type NextAvailableSlotResponseMessage = string | null;

/**
 * Start time (HH:MM:SS)
 */
export type NextAvailableSlotResponseStartTime = string | null;

/**
 * Response for next available slot endpoint.
 */
export interface NextAvailableSlotResponse {
  /** Date of the next available slot (YYYY-MM-DD) */
  date?: NextAvailableSlotResponseDate;
  /** Duration in minutes */
  duration_minutes?: NextAvailableSlotResponseDurationMinutes;
  /** End time (HH:MM:SS) */
  end_time?: NextAvailableSlotResponseEndTime;
  found: boolean;
  /** Message when no slot is found */
  message?: NextAvailableSlotResponseMessage;
  /** Start time (HH:MM:SS) */
  start_time?: NextAvailableSlotResponseStartTime;
}

export interface OnboardingResponse {
  /** Stripe connected account ID */
  account_id: string;
  /** Whether onboarding was already completed */
  already_onboarded: boolean;
  /** URL for onboarding flow */
  onboarding_url: string;
}

export interface OnboardingStatusResponse {
  /** Whether account can accept payments */
  charges_enabled: boolean;
  /** Whether required details are submitted */
  details_submitted?: boolean;
  /** Whether instructor has a connected account */
  has_account: boolean;
  /** Whether onboarding is complete */
  onboarding_completed: boolean;
  /** Whether account can receive payouts */
  payouts_enabled?: boolean;
  /** Outstanding requirements */
  requirements?: string[];
}

export type OperationResultReason = string | null;

export type OperationResultSlotId = string | null;

export type OperationResultStatus = typeof OperationResultStatus[keyof typeof OperationResultStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OperationResultStatus = {
  success: 'success',
  failed: 'failed',
  skipped: 'skipped',
} as const;

/**
 * Result of a single operation in bulk update.
 */
export interface OperationResult {
  action: string;
  operation_index: number;
  reason?: OperationResultReason;
  slot_id?: OperationResultSlotId;
  status: OperationResultStatus;
}

export interface PaginatedResponseBookingResponse {
  /** Whether there's a next page */
  has_next: boolean;
  /** Whether there's a previous page */
  has_prev: boolean;
  /** List of items */
  items: BookingResponse[];
  /**
   * Current page number
   * @minimum 1
   */
  page?: number;
  /**
   * Items per page
   * @minimum 1
   * @maximum 100
   */
  per_page?: number;
  /** Total number of items */
  total: number;
}

export interface PaginatedResponseInstructorProfileResponse {
  /** Whether there's a next page */
  has_next: boolean;
  /** Whether there's a previous page */
  has_prev: boolean;
  /** List of items */
  items: InstructorProfileResponse[];
  /**
   * Current page number
   * @minimum 1
   */
  page?: number;
  /**
   * Items per page
   * @minimum 1
   * @maximum 100
   */
  per_page?: number;
  /** Total number of items */
  total: number;
}

export interface PaginatedResponseUpcomingBookingResponse {
  /** Whether there's a next page */
  has_next: boolean;
  /** Whether there's a previous page */
  has_prev: boolean;
  /** List of items */
  items: UpcomingBookingResponse[];
  /**
   * Current page number
   * @minimum 1
   */
  page?: number;
  /**
   * Items per page
   * @minimum 1
   * @maximum 100
   */
  per_page?: number;
  /** Total number of items */
  total: number;
}

export interface PasswordChangeRequest {
  /** @minLength 6 */
  current_password: string;
  /** @minLength 8 */
  new_password: string;
}

export interface PasswordChangeResponse {
  message: string;
}

/**
 * Request model for confirming password reset with new password
 */
export interface PasswordResetConfirm {
  /** @minLength 8 */
  new_password: string;
  token: string;
}

/**
 * Request model for initiating password reset
 */
export interface PasswordResetRequest {
  email: string;
}

export interface PasswordResetResponse {
  message: string;
}

export interface PasswordResetVerifyResponse { [key: string]: unknown }

/**
 * Response for manually triggered payment health check.
 */
export interface PaymentHealthCheckTriggerResponse {
  /** Status message */
  message: string;
  /** Trigger status */
  status: string;
  /** Celery task ID */
  task_id: string;
  /** Trigger timestamp */
  timestamp: string;
}

/**
 * Payment metrics breakdown
 */
export type PaymentHealthResponseMetrics = {[key: string]: number};

/**
 * Minutes since last successful auth
 */
export type PaymentHealthResponseMinutesSinceLastAuth = number | null;

/**
 * Payment status counts
 */
export type PaymentHealthResponsePaymentStats = {[key: string]: number};

/**
 * Recent payment event counts
 */
export type PaymentHealthResponseRecentEvents = {[key: string]: number};

/**
 * Payment system health monitoring response.
 */
export interface PaymentHealthResponse {
  /** Current payment system alerts */
  alerts: string[];
  /** Payment metrics breakdown */
  metrics: PaymentHealthResponseMetrics;
  /** Minutes since last successful auth */
  minutes_since_last_auth?: PaymentHealthResponseMinutesSinceLastAuth;
  /** Number of overdue authorizations */
  overdue_authorizations: number;
  /** Payment status counts */
  payment_stats: PaymentHealthResponsePaymentStats;
  /** Recent payment event counts */
  recent_events: PaymentHealthResponseRecentEvents;
  /** Payment system health status (healthy/warning/critical) */
  status: string;
  /** Health check timestamp */
  timestamp: string;
}

/**
 * Response model for payment method information.
 */
export interface PaymentMethodResponse {
  /** Card brand (visa, mastercard, etc.) */
  brand: string;
  /** When the payment method was added */
  created_at: string;
  /** Payment method ID */
  id: string;
  /** Whether this is the default payment method */
  is_default: boolean;
  /** Last 4 digits of card */
  last4: string;
}

export type PaymentSummaryTipLastUpdated = string | null;

export type PaymentSummaryTipStatus = string | null;

/**
 * Student-facing payment breakdown for a booking.
 */
export interface PaymentSummary {
  credit_applied: number;
  lesson_amount: number;
  service_fee: number;
  subtotal: number;
  tip_amount: number;
  tip_last_updated?: PaymentSummaryTipLastUpdated;
  tip_paid: number;
  tip_status?: PaymentSummaryTipStatus;
  total_paid: number;
}

/**
 * Stripe connected account identifier
 */
export type PayoutScheduleResponseAccountId = string | null;

export type PayoutScheduleResponseSettingsAnyOf = { [key: string]: unknown };

/**
 * Stripe payout schedule settings that were applied
 */
export type PayoutScheduleResponseSettings = PayoutScheduleResponseSettingsAnyOf | null;

export interface PayoutScheduleResponse {
  /** Stripe connected account identifier */
  account_id?: PayoutScheduleResponseAccountId;
  /** Whether the schedule update succeeded */
  ok: boolean;
  /** Stripe payout schedule settings that were applied */
  settings?: PayoutScheduleResponseSettings;
}

/**
 * Search performance metrics.
 */
export interface PerformanceMetrics {
  /** Average results per search */
  avg_results_per_search: number;
  /** Most effective search type */
  most_effective_type: string;
  /** Percentage of searches with zero results */
  zero_result_rate: number;
}

/**
 * Cache statistics
 */
export type PerformanceMetricsResponseCache = { [key: string]: unknown };

/**
 * Database connection metrics
 */
export type PerformanceMetricsResponseDatabase = { [key: string]: unknown };

/**
 * System resource metrics
 */
export type PerformanceMetricsResponseSystem = {[key: string]: number};

/**
 * Comprehensive performance metrics response.
 */
export interface PerformanceMetricsResponse {
  /** Availability service metrics */
  availability_service: ServiceMetrics;
  /** Booking service metrics */
  booking_service: ServiceMetrics;
  /** Cache statistics */
  cache: PerformanceMetricsResponseCache;
  /** Conflict checker metrics */
  conflict_checker: ServiceMetrics;
  /** Database connection metrics */
  database: PerformanceMetricsResponseDatabase;
  /** System resource metrics */
  system: PerformanceMetricsResponseSystem;
}

/**
 * Performance optimization recommendation.
 */
export interface PerformanceRecommendation {
  /** Suggested action */
  action: string;
  /** Recommendation message */
  message: string;
  /** Severity level (info/warning) */
  severity: string;
  /** Recommendation type (database/cache/memory/requests) */
  type: string;
}

export type PlaceDetailsCity = string | null;

export type PlaceDetailsCountry = string | null;

export type PlaceDetailsPostalCode = string | null;

export type PlaceDetailsState = string | null;

export type PlaceDetailsStreetName = string | null;

export type PlaceDetailsStreetNumber = string | null;

export interface PlaceDetails {
  city?: PlaceDetailsCity;
  country?: PlaceDetailsCountry;
  formatted_address: string;
  latitude: number;
  longitude: number;
  postal_code?: PlaceDetailsPostalCode;
  provider_id: string;
  state?: PlaceDetailsState;
  street_name?: PlaceDetailsStreetName;
  street_number?: PlaceDetailsStreetNumber;
}

export interface PlaceSuggestion {
  description: string;
  place_id: string;
  provider: string;
  text: string;
  types?: string[];
}

/**
 * Popular search query data.
 */
export interface PopularSearch {
  /** Average number of results returned */
  average_results: number;
  /** Search query text */
  query: string;
  /** Number of times searched */
  search_count: number;
  /** Number of unique users who searched */
  unique_users: number;
}

/**
 * Popular searches response.
 */
export type PopularSearchesResponse = PopularSearch[];

export type PreferredPublicSpaceInLabel = string | null;

/**
 * Preferred public space input payload.
 */
export interface PreferredPublicSpaceIn {
  /**
   * @minLength 1
   * @maxLength 512
   */
  address: string;
  label?: PreferredPublicSpaceInLabel;
}

export interface PreferredPublicSpaceOut { [key: string]: unknown }

export type PreferredTeachingLocationInLabel = string | null;

/**
 * Preferred teaching location input payload.
 */
export interface PreferredTeachingLocationIn {
  /**
   * @minLength 1
   * @maxLength 512
   */
  address: string;
  label?: PreferredTeachingLocationInLabel;
}

export interface PreferredTeachingLocationOut { [key: string]: unknown }

export interface PriceFloorConfig {
  /**
   * Minimum cents for in-person private lessons
   * @minimum 0
   */
  private_in_person: number;
  /**
   * Minimum cents for remote private lessons
   * @minimum 0
   */
  private_remote: number;
}

export interface PricingConfig {
  instructor_tiers: TierConfig[];
  price_floor_cents: PriceFloorConfig;
  student_credit_cycle: StudentCreditCycle;
  /**
   * Student booking protection fee as decimal
   */
  student_fee_pct: number;
  /**
   * Rolling window for tier activity
   */
  tier_activity_window_days: number;
  /**
   * Inactivity period before full reset
   */
  tier_inactivity_reset_days: number;
  /**
   * Maximum tiers to drop per evaluation
   * @minimum 0
   */
  tier_stepdown_max: number;
}

/**
 * Alias for request payload compatibility.
 */
export interface PricingConfigPayload {
  instructor_tiers: TierConfig[];
  price_floor_cents: PriceFloorConfig;
  student_credit_cycle: StudentCreditCycle;
  /**
   * Student booking protection fee as decimal
   */
  student_fee_pct: number;
  /**
   * Rolling window for tier activity
   */
  tier_activity_window_days: number;
  /**
   * Inactivity period before full reset
   */
  tier_inactivity_reset_days: number;
  /**
   * Maximum tiers to drop per evaluation
   * @minimum 0
   */
  tier_stepdown_max: number;
}

export type PricingConfigResponseUpdatedAt = string | null;

export interface PricingConfigResponse {
  config: PricingConfig;
  updated_at?: PricingConfigResponseUpdatedAt;
}

/**
 * Privacy and retention statistics
 */
export type PrivacyStatisticsResponseStatistics = { [key: string]: unknown };

export interface PrivacyStatisticsResponse {
  /** Privacy and retention statistics */
  statistics: PrivacyStatisticsResponseStatistics;
  /** Status of the request */
  status: string;
}

/**
 * Problematic search query with low results.
 */
export interface ProblematicQuery {
  /** Average results returned */
  avg_results: number;
  /** Number of times searched */
  count: number;
  /** Search query text */
  query: string;
}

export type ProfilePictureUrlsResponseUrls = {[key: string]: string | null};

export interface ProfilePictureUrlsResponse {
  urls: ProfilePictureUrlsResponseUrls;
}

export type ProxyUploadResponseUrl = string | null;

/**
 * Response payload for proxied uploads in local development.
 */
export interface ProxyUploadResponse {
  ok: boolean;
  url?: ProxyUploadResponseUrl;
}

/**
 * Availability for a single day.
 */
export interface PublicDayAvailability {
  /** List of available time slots for booking */
  available_slots?: PublicTimeSlot[];
  /** Date in YYYY-MM-DD format */
  date: string;
  /** Whether this date is completely unavailable */
  is_blackout?: boolean;
}

export type PublicInstructorAvailabilityAvailabilityByDateAnyOf = {[key: string]: PublicDayAvailability};

/**
 * Availability indexed by date string (YYYY-MM-DD) - only in full detail
 */
export type PublicInstructorAvailabilityAvailabilityByDate = PublicInstructorAvailabilityAvailabilityByDateAnyOf | null;

export type PublicInstructorAvailabilityAvailabilitySummaryAnyOf = {[key: string]: { [key: string]: unknown }};

/**
 * Summary of availability by date - only in summary detail
 */
export type PublicInstructorAvailabilityAvailabilitySummary = PublicInstructorAvailabilityAvailabilitySummaryAnyOf | null;

/**
 * Earliest date with availability
 */
export type PublicInstructorAvailabilityEarliestAvailableDate = string | null;

/**
 * Whether any availability exists
 */
export type PublicInstructorAvailabilityHasAvailability = boolean | null;

/**
 * Instructor's first name if privacy settings allow
 */
export type PublicInstructorAvailabilityInstructorFirstName = string | null;

/**
 * Instructor's last name initial for privacy
 */
export type PublicInstructorAvailabilityInstructorLastInitial = string | null;

/**
 * Number of days with availability
 */
export type PublicInstructorAvailabilityTotalAvailableDays = number | null;

/**
 * Total number of bookable slots in the date range
 */
export type PublicInstructorAvailabilityTotalAvailableSlots = number | null;

/**
 * Public availability response for an instructor.

This is the main response schema for the public endpoint.
Provides all necessary information for students to view
availability and make booking decisions.

The detail_level field indicates what data is populated:
- "minimal": Only has_availability and earliest_available_date
- "summary": Includes availability_summary but not specific slots
- "full": Complete availability_by_date with all time slots
 */
export interface PublicInstructorAvailability {
  /** Availability indexed by date string (YYYY-MM-DD) - only in full detail */
  availability_by_date?: PublicInstructorAvailabilityAvailabilityByDate;
  /** Summary of availability by date - only in summary detail */
  availability_summary?: PublicInstructorAvailabilityAvailabilitySummary;
  /** Level of detail: minimal, summary, or full */
  detail_level: string;
  /** Earliest date with availability */
  earliest_available_date?: PublicInstructorAvailabilityEarliestAvailableDate;
  /** Whether any availability exists */
  has_availability?: PublicInstructorAvailabilityHasAvailability;
  /** Instructor's first name if privacy settings allow */
  instructor_first_name?: PublicInstructorAvailabilityInstructorFirstName;
  instructor_id: string;
  /** Instructor's last name initial for privacy */
  instructor_last_initial?: PublicInstructorAvailabilityInstructorLastInitial;
  /** Instructor's timezone */
  timezone?: string;
  /** Number of days with availability */
  total_available_days?: PublicInstructorAvailabilityTotalAvailableDays;
  /** Total number of bookable slots in the date range */
  total_available_slots?: PublicInstructorAvailabilityTotalAvailableSlots;
}

/**
 * A bookable time slot for public viewing.

Note: No slot IDs exposed - frontend should use instructor_id + date + times
for booking requests.
 */
export interface PublicTimeSlot {
  /** End time in HH:MM format */
  end_time: string;
  /** Start time in HH:MM format */
  start_time: string;
}

/**
 * Rate limit reset response.
 */
export interface RateLimitResetResponse {
  /** Number of limits reset */
  limits_reset: number;
  /** Result message */
  message: string;
  /** Pattern used for matching */
  pattern: string;
  /** Operation status */
  status: string;
}

/**
 * Breakdown by limit type
 */
export type RateLimitStatsBreakdownByType = {[key: string]: number};

export type RateLimitStatsTopLimitedClientsItem = { [key: string]: unknown };

/**
 * Rate limit statistics.
 */
export interface RateLimitStats {
  /** Breakdown by limit type */
  breakdown_by_type: RateLimitStatsBreakdownByType;
  /** Top rate-limited clients */
  top_limited_clients: RateLimitStatsTopLimitedClientsItem[];
  /** Total rate limit keys in Redis */
  total_keys: number;
}

/**
 * Rate limit test endpoint response.
 */
export interface RateLimitTestResponse {
  /** Test message */
  message: string;
  /** Rate limit information */
  note: string;
  /** Request timestamp */
  timestamp: string;
}

export type RatingsBatchItemRating = number | null;

export interface RatingsBatchItem {
  instructor_id: string;
  rating: RatingsBatchItemRating;
  review_count: number;
}

export interface RatingsBatchRequest {
  /** @minItems 1 */
  instructor_ids: string[];
}

export interface RatingsBatchResponse {
  results: RatingsBatchItem[];
}

export interface ReactionRequest {
  emoji: string;
}

/**
 * Response for recent alerts endpoint.
 */
export interface RecentAlertsResponse {
  /** List of alert details */
  alerts: AlertDetail[];
  /** Number of hours included in the query */
  hours: number;
  /** Total number of alerts in the time period */
  total: number;
}

export type RedisCeleryQueuesResponseQueues = { [key: string]: unknown };

export interface RedisCeleryQueuesResponse {
  queues: RedisCeleryQueuesResponseQueues;
}

export type RedisConnectionAuditResponseConnectionsItem = { [key: string]: unknown };

export interface RedisConnectionAuditResponse {
  connections: RedisConnectionAuditResponseConnectionsItem[];
}

export interface RedisFlushQueuesResponse {
  message: string;
  queues_flushed: string[];
}

/**
 * Error message if unhealthy
 */
export type RedisHealthResponseError = string | null;

/**
 * Response for Redis health check endpoint.
 */
export interface RedisHealthResponse {
  /** Whether Redis is connected */
  connected: boolean;
  /** Error message if unhealthy */
  error?: RedisHealthResponseError;
  /** Health status (healthy/unhealthy) */
  status: string;
}

export type RedisStatsResponseStats = { [key: string]: unknown };

export interface RedisStatsResponse {
  stats: RedisStatsResponseStats;
}

/**
 * Number of connected clients
 */
export type RedisTestResponseConnectedClients = number | null;

/**
 * Error message if failed
 */
export type RedisTestResponseError = string | null;

/**
 * Status message
 */
export type RedisTestResponseMessage = string | null;

/**
 * Ping result
 */
export type RedisTestResponsePing = boolean | null;

/**
 * Redis server version
 */
export type RedisTestResponseRedisVersion = string | null;

/**
 * Redis uptime in seconds
 */
export type RedisTestResponseUptimeSeconds = number | null;

/**
 * Response for Redis test endpoint.
 */
export interface RedisTestResponse {
  /** Number of connected clients */
  connected_clients?: RedisTestResponseConnectedClients;
  /** Error message if failed */
  error?: RedisTestResponseError;
  /** Status message */
  message?: RedisTestResponseMessage;
  /** Ping result */
  ping?: RedisTestResponsePing;
  /** Redis server version */
  redis_version?: RedisTestResponseRedisVersion;
  /** Connection status */
  status: string;
  /** Redis uptime in seconds */
  uptime_seconds?: RedisTestResponseUptimeSeconds;
}

export interface ReferralClaimRequest {
  code: string;
}

export type ReferralClaimResponseReason = string | null;

export interface ReferralClaimResponse {
  attributed: boolean;
  reason?: ReferralClaimResponseReason;
}

export interface ReferralErrorResponse {
  reason: string;
}

export interface ReferralLedgerResponse {
  code: string;
  expiry_notice_days: number[];
  pending: RewardOut[];
  redeemed: RewardOut[];
  share_url: string;
  unlocked: RewardOut[];
}

export interface ReferralResolveResponse {
  code: string;
  ok: boolean;
  redirect: string;
}

/**
 * Details for a failed referral send attempt.
 */
export interface ReferralSendError {
  email: string;
  error: string;
}

/**
 * Display name of the inviter (falls back to a generic label if omitted)
 */
export type ReferralSendRequestFromName = string | null;

/**
 * Request payload for sending referral invites.
 */
export interface ReferralSendRequest {
  /** List of recipient email addresses */
  emails: string[];
  /** Display name of the inviter (falls back to a generic label if omitted) */
  from_name?: ReferralSendRequestFromName;
  /**
   * Referral link to include in the invite
   * @minLength 1
   */
  referral_link: string;
}

export interface ReferralSendResponse {
  /** List of errors for individual recipients */
  errors?: ReferralSendError[];
  /** Number of emails that failed to send */
  failed: number;
  /** Number of emails successfully sent */
  sent: number;
  /** Operation status ('ok' if the operation ran) */
  status: string;
}

/**
 * Request processing metrics.
 */
export interface RequestMetrics {
  /** Currently active requests */
  active_count: number;
  /** Average response time in milliseconds */
  average_response_time_ms: number;
  /** Total requests processed */
  total_count: number;
}

/**
 * Minimal info about the original booking used for annotation.
 */
export interface RescheduledFromInfo {
  booking_date: string;
  id: string;
  start_time: string;
}

/**
 * Search result distribution.
 */
export interface ResultDistribution {
  /** Searches with 1-5 results */
  '1_5_results': number;
  /** Searches with 6-10 results */
  '6_10_results': number;
  /** Searches with over 10 results */
  over_10_results: number;
  /** Searches with zero results */
  zero_results: number;
}

/**
 * Statistics of retention policy application
 */
export type RetentionPolicyResponseStats = { [key: string]: unknown };

export interface RetentionPolicyResponse {
  /** Human-readable message */
  message: string;
  /** Statistics of retention policy application */
  stats: RetentionPolicyResponseStats;
  /** Status of the retention policy application */
  status: string;
}

export type ReviewItemReviewText = string | null;

export type ReviewItemReviewerDisplayName = string | null;

export interface ReviewItem {
  created_at: string;
  id: string;
  instructor_service_id: string;
  rating: number;
  review_text: ReviewItemReviewText;
  reviewer_display_name?: ReviewItemReviewerDisplayName;
}

export interface ReviewListPageResponse {
  has_next: boolean;
  has_prev: boolean;
  page: number;
  per_page: number;
  reviews: ReviewItem[];
  total: number;
}

export interface ReviewResponseModel {
  created_at: string;
  id: string;
  instructor_id: string;
  response_text: string;
  review_id: string;
}

export type ReviewSubmitRequestReviewText = string | null;

export type ReviewSubmitRequestTipAmountCents = number | null;

export interface ReviewSubmitRequest {
  booking_id: string;
  /**
   * @minimum 1
   * @maximum 5
   */
  rating: number;
  review_text?: ReviewSubmitRequestReviewText;
  tip_amount_cents?: ReviewSubmitRequestTipAmountCents;
}

export type ReviewSubmitResponseReviewText = string | null;

export type ReviewSubmitResponseReviewerDisplayName = string | null;

export type ReviewSubmitResponseTipClientSecret = string | null;

export type ReviewSubmitResponseTipStatus = string | null;

export interface ReviewSubmitResponse {
  created_at: string;
  id: string;
  instructor_service_id: string;
  rating: number;
  review_text: ReviewSubmitResponseReviewText;
  reviewer_display_name?: ReviewSubmitResponseReviewerDisplayName;
  tip_client_secret?: ReviewSubmitResponseTipClientSecret;
  tip_status?: ReviewSubmitResponseTipStatus;
}

export type RewardOutExpireTs = string | null;

export type RewardOutUnlockTs = string | null;

/**
 * Serialized reward payload.
 */
export interface RewardOut {
  amount_cents: number;
  created_at: string;
  expire_ts?: RewardOutExpireTs;
  id: string;
  side: RewardSide;
  status: RewardStatus;
  unlock_ts?: RewardOutUnlockTs;
}

/**
 * Which party receives the reward.
 */
export type RewardSide = typeof RewardSide[keyof typeof RewardSide];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RewardSide = {
  student: 'student',
  instructor: 'instructor',
} as const;

/**
 * Lifecycle of a reward.
 */
export type RewardStatus = typeof RewardStatus[keyof typeof RewardStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RewardStatus = {
  pending: 'pending',
  unlocked: 'unlocked',
  redeemed: 'redeemed',
  void: 'void',
} as const;

/**
 * Request to save a payment method for a user.
 */
export interface SavePaymentMethodRequest {
  /** Stripe payment method ID */
  payment_method_id: string;
  /** Whether to set as default payment method */
  set_as_default?: boolean;
}

/**
 * Conversion metrics
 */
export type SearchAnalyticsSummaryResponseConversions = { [key: string]: unknown };

/**
 * Breakdown by search type
 */
export type SearchAnalyticsSummaryResponseSearchTypes = {[key: string]: SearchTypeMetrics};

/**
 * Comprehensive search analytics summary.
 */
export interface SearchAnalyticsSummaryResponse {
  /** Conversion metrics */
  conversions: SearchAnalyticsSummaryResponseConversions;
  /** Date range for analytics */
  date_range: DateRange;
  /** Search performance metrics */
  performance: PerformanceMetrics;
  /** Breakdown by search type */
  search_types: SearchAnalyticsSummaryResponseSearchTypes;
  /** Search totals and metrics */
  totals: SearchTotals;
  /** User breakdown by type */
  users: UserBreakdown;
}

/**
 * Search effectiveness metrics.
 */
export interface SearchEffectiveness {
  /** Average results per search */
  avg_results_per_search: number;
  /** Median results per search */
  median_results: number;
  /** Number of searches with at least one result */
  searches_with_results: number;
  /** Percentage of searches with zero results */
  zero_result_rate: number;
}

export type SearchHistoryCreateDeviceContextAnyOf = { [key: string]: unknown };

/**
 * Device context from frontend including screen size, connection type, etc.
 */
export type SearchHistoryCreateDeviceContext = SearchHistoryCreateDeviceContextAnyOf | null;

/**
 * UUID for guest session tracking
 */
export type SearchHistoryCreateGuestSessionId = string | null;

export type SearchHistoryCreateObservabilityCandidatesAnyOfItem = { [key: string]: unknown };

/**
 * Optional top-N candidate objects for observability. Each item may include: position, service_catalog_id (or id), score, vector_score, lexical_score, source.
 */
export type SearchHistoryCreateObservabilityCandidates = SearchHistoryCreateObservabilityCandidatesAnyOfItem[] | null;

/**
 * Number of results returned
 */
export type SearchHistoryCreateResultsCount = number | null;

export type SearchHistoryCreateSearchContextAnyOf = { [key: string]: unknown };

/**
 * Additional context like page origin, viewport size, etc.
 */
export type SearchHistoryCreateSearchContext = SearchHistoryCreateSearchContextAnyOf | null;

/**
 * Schema for creating search history.
 */
export interface SearchHistoryCreate {
  /** Device context from frontend including screen size, connection type, etc. */
  device_context?: SearchHistoryCreateDeviceContext;
  /** UUID for guest session tracking */
  guest_session_id?: SearchHistoryCreateGuestSessionId;
  /** Optional top-N candidate objects for observability. Each item may include: position, service_catalog_id (or id), score, vector_score, lexical_score, source. */
  observability_candidates?: SearchHistoryCreateObservabilityCandidates;
  /** Number of results returned */
  results_count?: SearchHistoryCreateResultsCount;
  /** Additional context like page origin, viewport size, etc. */
  search_context?: SearchHistoryCreateSearchContext;
  /**
   * The search query string
   * @minLength 1
   */
  search_query: string;
  /** Type of search: natural_language, category, service_pill, filter, or search_history */
  search_type?: string;
}

/**
 * UUID for guest session tracking
 */
export type SearchHistoryResponseGuestSessionId = string | null;

/**
 * Number of results returned
 */
export type SearchHistoryResponseResultsCount = number | null;

/**
 * ID of the associated search event for tracking interactions
 */
export type SearchHistoryResponseSearchEventId = string | null;

/**
 * Schema for search history responses.
 */
export interface SearchHistoryResponse {
  /** When the search was first performed */
  first_searched_at: string;
  /** UUID for guest session tracking */
  guest_session_id?: SearchHistoryResponseGuestSessionId;
  /** Unique identifier for the search history entry */
  id: string;
  /** When the search was last performed */
  last_searched_at: string;
  /** Number of results returned */
  results_count?: SearchHistoryResponseResultsCount;
  /** Number of times this search was performed */
  search_count: number;
  /** ID of the associated search event for tracking interactions */
  search_event_id?: SearchHistoryResponseSearchEventId;
  /**
   * The search query string
   * @minLength 1
   */
  search_query: string;
  /** Type of search: natural_language, category, service_pill, filter, or search_history */
  search_type?: string;
}

/**
 * Response for recording search interaction.
 */
export interface SearchInteractionResponse {
  interaction_id: string;
  message?: string;
  status?: string;
  success: boolean;
}

export type SearchMetadataObservabilityCandidatesAnyOfItem = { [key: string]: unknown };

/**
 * Optional top-N candidates considered during search for observability/analytics (position, service_catalog_id, name, score, vector_score, lexical_score, source).
 */
export type SearchMetadataObservabilityCandidates = SearchMetadataObservabilityCandidatesAnyOfItem[] | null;

/**
 * Search metadata.
 */
export interface SearchMetadata {
  /** List of applied filters */
  applied_filters: string[];
  /** Optional top-N candidates considered during search for observability/analytics (position, service_catalog_id, name, score, vector_score, lexical_score, source). */
  observability_candidates?: SearchMetadataObservabilityCandidates;
  /** Search timestamp (ISO format) */
  timestamp: string;
  /** Whether semantic search was used */
  used_semantic_search: boolean;
}

/**
 * Search performance metrics response.
 */
export interface SearchPerformanceResponse {
  /** Search effectiveness metrics */
  effectiveness: SearchEffectiveness;
  /** Queries with poor results */
  problematic_queries: ProblematicQuery[];
  /** Distribution of search results */
  result_distribution: ResultDistribution;
}

export type SearchRatingResponsePrimaryRating = number | null;

export interface SearchRatingResponse {
  is_service_specific: boolean;
  primary_rating: SearchRatingResponsePrimaryRating;
  review_count: number;
}

/**
 * Search referrer page data.
 */
export interface SearchReferrer {
  /** Referrer page URL or path */
  page: string;
  /** Number of searches from this page */
  search_count: number;
  /** Types of searches from this page */
  search_types: string[];
  /** Number of unique sessions */
  unique_sessions: number;
}

/**
 * Search referrers response.
 */
export type SearchReferrersResponse = SearchReferrer[];

/**
 * List of region IDs served by the instructor for quick FE mapping without extra calls
 */
export type SearchResultCoverageRegionIds = string[] | null;

export type SearchResultCoverageRegionsAnyOfItem = { [key: string]: unknown };

/**
 * List of regions served with minimal fields: region_id, name, borough, coverage_type
 */
export type SearchResultCoverageRegions = SearchResultCoverageRegionsAnyOfItem[] | null;

/**
 * Service catalog information
 */
export type SearchResultService = { [key: string]: unknown };

/**
 * Individual search result.
 */
export interface SearchResult {
  /** List of region IDs served by the instructor for quick FE mapping without extra calls */
  coverage_region_ids?: SearchResultCoverageRegionIds;
  /** List of regions served with minimal fields: region_id, name, borough, coverage_type */
  coverage_regions?: SearchResultCoverageRegions;
  /** Instructor information */
  instructor: AppSchemasSearchResponsesInstructorInfo;
  /** Match score (0-100) */
  match_score: number;
  /** Service offering details */
  offering: ServiceOffering;
  /** Service catalog information */
  service: SearchResultService;
}

/**
 * Search totals and deletion metrics.
 */
export interface SearchTotals {
  /** Number of deleted searches */
  deleted_searches: number;
  /** Percentage of searches deleted */
  deletion_rate: number;
  /** Total number of searches */
  total_searches: number;
  /** Total unique users (authenticated + guests) */
  total_users: number;
  /** Unique guest sessions */
  unique_guests: number;
  /** Unique authenticated users */
  unique_users: number;
}

/**
 * Search trends over time response.
 */
export type SearchTrendsResponse = DailySearchTrend[];

/**
 * Metrics for a search type.
 */
export interface SearchTypeMetrics {
  /** Number of searches of this type */
  count: number;
  /** Percentage of total searches */
  percentage: number;
}

/**
 * Request to send a message.
 */
export interface SendMessageRequest {
  /** ID of the booking */
  booking_id: string;
  /**
   * Message content
   * @minLength 1
   * @maxLength 1000
   */
  content: string;
}

export interface SendMessageResponse {
  message: MessageResponse;
  success?: boolean;
}

/**
 * Response for sending booking reminders.
 */
export interface SendRemindersResponse {
  failed_reminders: number;
  message: string;
  reminders_sent: number;
}

export type ServiceAreaItemBorough = string | null;

export type ServiceAreaItemName = string | null;

export type ServiceAreaItemNtacode = string | null;

export interface ServiceAreaItem {
  borough?: ServiceAreaItemBorough;
  name?: ServiceAreaItemName;
  neighborhood_id: string;
  ntacode?: ServiceAreaItemNtacode;
}

export type ServiceAreaNeighborhoodBorough = string | null;

export type ServiceAreaNeighborhoodName = string | null;

export type ServiceAreaNeighborhoodNtacode = string | null;

/**
 * Normalized neighborhood metadata used in instructor service area responses.
 */
export interface ServiceAreaNeighborhood {
  borough?: ServiceAreaNeighborhoodBorough;
  name?: ServiceAreaNeighborhoodName;
  neighborhood_id: string;
  ntacode?: ServiceAreaNeighborhoodNtacode;
}

export interface ServiceAreasResponse {
  items: ServiceAreaItem[];
  total: number;
}

export interface ServiceAreasUpdateRequest {
  neighborhood_ids: string[];
}

/**
 * Age groups this service is offered to. Allowed: 'kids', 'adults'. Use both for both.
 */
export type ServiceCreateAgeGroups = string[] | null;

export type ServiceCreateDescription = string | null;

/**
 * List of equipment required (strings)
 */
export type ServiceCreateEquipmentRequired = string[] | null;

/**
 * Hourly rate in USD
 */
export type ServiceCreateHourlyRate = number | number | string;

/**
 * Levels taught. Allowed: 'beginner', 'intermediate', 'advanced'
 */
export type ServiceCreateLevelsTaught = string[] | null;

/**
 * Where lessons are offered. Allowed: 'in-person', 'online'
 */
export type ServiceCreateLocationTypes = string[] | null;

export type ServiceCreateRequirements = string | null;

/**
 * Schema for creating a new service.
 */
export interface ServiceCreate {
  /** Age groups this service is offered to. Allowed: 'kids', 'adults'. Use both for both. */
  age_groups?: ServiceCreateAgeGroups;
  description?: ServiceCreateDescription;
  /**
   * Available duration options for this service in minutes
   * @minItems 1
   */
  duration_options?: number[];
  /** List of equipment required (strings) */
  equipment_required?: ServiceCreateEquipmentRequired;
  /** Hourly rate in USD */
  hourly_rate: ServiceCreateHourlyRate;
  /** Levels taught. Allowed: 'beginner', 'intermediate', 'advanced' */
  levels_taught?: ServiceCreateLevelsTaught;
  /** Where lessons are offered. Allowed: 'in-person', 'online' */
  location_types?: ServiceCreateLocationTypes;
  requirements?: ServiceCreateRequirements;
  /** ID of the service from catalog */
  service_catalog_id: string;
}

export type ServiceInfoDescription = string | null;

/**
 * Basic service information for booking display.
 */
export interface ServiceInfo {
  description: ServiceInfoDescription;
  id: string;
  name: string;
}

/**
 * Operation counts by type
 */
export type ServiceMetricsOperations = {[key: string]: number};

/**
 * Service-level performance metrics.
 */
export interface ServiceMetrics {
  /** Cache operations performed */
  cache_operations: number;
  /** Database operations performed */
  db_operations: number;
  /** Operation counts by type */
  operations: ServiceMetricsOperations;
  /** Total operations performed */
  total_operations: number;
}

/**
 * Age groups served
 */
export type ServiceOfferingAgeGroups = string[] | null;

/**
 * Service description
 */
export type ServiceOfferingDescription = string | null;

/**
 * Required equipment
 */
export type ServiceOfferingEquipmentRequired = string[] | null;

/**
 * Experience level
 */
export type ServiceOfferingExperienceLevel = string | null;

/**
 * Levels taught
 */
export type ServiceOfferingLevelsTaught = string[] | null;

/**
 * Location types (online/in-person)
 */
export type ServiceOfferingLocationTypes = string[] | null;

/**
 * Maximum travel distance
 */
export type ServiceOfferingMaxDistanceMiles = number | null;

/**
 * Service offering details.
 */
export interface ServiceOffering {
  /** Age groups served */
  age_groups?: ServiceOfferingAgeGroups;
  /** Service description */
  description?: ServiceOfferingDescription;
  /** Available session durations in minutes */
  duration_options: number[];
  /** Required equipment */
  equipment_required?: ServiceOfferingEquipmentRequired;
  /** Experience level */
  experience_level?: ServiceOfferingExperienceLevel;
  /** Hourly rate for the service */
  hourly_rate: number;
  /** Instructor service ID */
  id: string;
  /** Levels taught */
  levels_taught?: ServiceOfferingLevelsTaught;
  /** Location types (online/in-person) */
  location_types?: ServiceOfferingLocationTypes;
  /** Maximum travel distance */
  max_distance_miles?: ServiceOfferingMaxDistanceMiles;
}

/**
 * Age groups this service is offered to. Allowed: 'kids', 'adults'. Use both for both.
 */
export type ServiceResponseAgeGroups = string[] | null;

export type ServiceResponseDescription = string | null;

/**
 * Display order hint from the catalog (nullable)
 */
export type ServiceResponseDisplayOrder = number | null;

/**
 * List of equipment required (strings)
 */
export type ServiceResponseEquipmentRequired = string[] | null;

/**
 * Whether this service is currently active for the instructor
 */
export type ServiceResponseIsActive = boolean | null;

/**
 * Levels taught. Allowed: 'beginner', 'intermediate', 'advanced'
 */
export type ServiceResponseLevelsTaught = string[] | null;

/**
 * Where lessons are offered. Allowed: 'in-person', 'online'
 */
export type ServiceResponseLocationTypes = string[] | null;

/**
 * Resolved name of the service from the catalog
 */
export type ServiceResponseName = string | null;

/**
 * Whether the catalog service supports online delivery
 */
export type ServiceResponseOnlineCapable = boolean | null;

export type ServiceResponseRequirements = string | null;

/**
 * Whether the catalog service requires certification
 */
export type ServiceResponseRequiresCertification = boolean | null;

/**
 * Schema for service responses.

Includes the service ID and catalog information.
 */
export interface ServiceResponse {
  /** Age groups this service is offered to. Allowed: 'kids', 'adults'. Use both for both. */
  age_groups?: ServiceResponseAgeGroups;
  description?: ServiceResponseDescription;
  /** Display order hint from the catalog (nullable) */
  display_order?: ServiceResponseDisplayOrder;
  /**
   * Available duration options for this service in minutes
   * @minItems 1
   */
  duration_options?: number[];
  /** List of equipment required (strings) */
  equipment_required?: ServiceResponseEquipmentRequired;
  /** Hourly rate in USD */
  hourly_rate: number;
  id: string;
  /** Whether this service is currently active for the instructor */
  is_active?: ServiceResponseIsActive;
  /** Levels taught. Allowed: 'beginner', 'intermediate', 'advanced' */
  levels_taught?: ServiceResponseLevelsTaught;
  /** Where lessons are offered. Allowed: 'in-person', 'online' */
  location_types?: ServiceResponseLocationTypes;
  /** Resolved name of the service from the catalog */
  name?: ServiceResponseName;
  /** Whether the catalog service supports online delivery */
  online_capable?: ServiceResponseOnlineCapable;
  requirements?: ServiceResponseRequirements;
  /** Whether the catalog service requires certification */
  requires_certification?: ServiceResponseRequiresCertification;
  /** ID of the service from catalog */
  service_catalog_id: string;
  /**
   * Human-readable name of the catalog service
   * @maxLength 255
   */
  service_catalog_name: string;
}

export type ServiceSearchMetadataFiltersApplied = { [key: string]: unknown };

export type ServiceSearchMetadataPagination = { [key: string]: unknown };

/**
 * Metadata describing instructor search results.
 */
export interface ServiceSearchMetadata {
  active_instructors?: number;
  filters_applied?: ServiceSearchMetadataFiltersApplied;
  pagination?: ServiceSearchMetadataPagination;
  total_matches?: number;
}

export type ServiceSearchResponseInstructorsItem = { [key: string]: unknown };

/**
 * Envelope for service-focused instructor search results.
 */
export interface ServiceSearchResponse {
  instructors?: ServiceSearchResponseInstructorsItem[];
  metadata: ServiceSearchMetadata;
  query: string;
  search_type?: 'service';
}

export type SignedUploadResponseHeaders = {[key: string]: string};

export type SignedUploadResponsePublicUrl = string | null;

/**
 * Response payload for signed upload requests.
 */
export interface SignedUploadResponse {
  expires_at: string;
  headers?: SignedUploadResponseHeaders;
  object_key: string;
  public_url?: SignedUploadResponsePublicUrl;
  upload_url: string;
}

export type SlotOperationAction = typeof SlotOperationAction[keyof typeof SlotOperationAction];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const SlotOperationAction = {
  add: 'add',
  remove: 'remove',
  update: 'update',
} as const;

export type SlotOperationDate = string | null;

export type SlotOperationEndTime = string | null;

export type SlotOperationSlotId = string | null;

export type SlotOperationStartTime = string | null;

/**
 * Schema for a single slot operation in bulk update.
 */
export interface SlotOperation {
  action: SlotOperationAction;
  date?: SlotOperationDate;
  end_time?: SlotOperationEndTime;
  slot_id?: SlotOperationSlotId;
  start_time?: SlotOperationStartTime;
}

/**
 * Slow queries response.
 */
export interface SlowQueriesResponse {
  /** List of slow queries */
  slow_queries: SlowQueryInfo[];
  /** Total number of slow queries tracked */
  total_count: number;
}

/**
 * API endpoint that triggered the query
 */
export type SlowQueryInfoEndpoint = string | null;

/**
 * Slow query information.
 */
export interface SlowQueryInfo {
  /** Query duration in milliseconds */
  duration_ms: number;
  /** API endpoint that triggered the query */
  endpoint?: SlowQueryInfoEndpoint;
  /** SQL query (truncated) */
  query: string;
  /** Query execution timestamp */
  timestamp: string;
}

/**
 * Slow request information.
 */
export interface SlowRequestInfo {
  /** Request duration in milliseconds */
  duration_ms: number;
  /** HTTP method */
  method: string;
  /** Request path */
  path: string;
  /** Response status code */
  status_code: number;
  /** Request timestamp */
  timestamp: string;
}

/**
 * Slow requests response.
 */
export interface SlowRequestsResponse {
  /** List of slow requests */
  slow_requests: SlowRequestInfo[];
  /** Total number of slow requests tracked */
  total_count: number;
}

/**
 * Schema for creating availability on a specific date.
 */
export interface SpecificDateAvailabilityCreate {
  end_time: string;
  specific_date: string;
  start_time: string;
}

export interface StudentCreditCycle {
  /**
   * Credit cents issued for $10 milestone
   * @minimum 0
   */
  cents10: number;
  /**
   * Credit cents issued for $20 milestone
   * @minimum 0
   */
  cents20: number;
  /**
   * Length of credit cycle in sessions
   */
  cycle_len: number;
  /**
   * Modulo offset for $10 credit milestone
   * @minimum 0
   */
  mod10: number;
  /**
   * Modulo offset for $20 credit milestone
   * @minimum 0
   */
  mod20: number;
}

/**
 * Basic student information for booking display.
 */
export interface StudentInfo {
  email: string;
  first_name: string;
  id: string;
  last_name: string;
}

export type SuccessResponseDataAnyOf = { [key: string]: unknown };

/**
 * Optional additional data
 */
export type SuccessResponseData = SuccessResponseDataAnyOf | null;

/**
 * Standard success response for operations.
 */
export interface SuccessResponse {
  /** Optional additional data */
  data?: SuccessResponseData;
  /** Human-readable success message */
  message: string;
  /** Operation success status */
  success?: boolean;
}

export interface TFADisableRequest {
  current_password: string;
}

export interface TFADisableResponse {
  message: string;
}

export interface TFASetupInitiateResponse {
  otpauth_url: string;
  qr_code_data_url: string;
  secret: string;
}

export interface TFASetupVerifyRequest {
  code: string;
}

export interface TFASetupVerifyResponse {
  backup_codes: string[];
  enabled: boolean;
}

export type TFAStatusResponseLastUsedAt = string | null;

export type TFAStatusResponseVerifiedAt = string | null;

export interface TFAStatusResponse {
  enabled: boolean;
  last_used_at?: TFAStatusResponseLastUsedAt;
  verified_at?: TFAStatusResponseVerifiedAt;
}

export type TFAVerifyLoginRequestBackupCode = string | null;

export type TFAVerifyLoginRequestCode = string | null;

export interface TFAVerifyLoginRequest {
  backup_code?: TFAVerifyLoginRequestBackupCode;
  code?: TFAVerifyLoginRequestCode;
  temp_token: string;
}

export interface TFAVerifyLoginResponse {
  access_token: string;
  token_type: string;
}

/**
 * Maximum sessions for this tier (inclusive); null for open-ended
 */
export type TierConfigMax = number | null;

export interface TierConfig {
  /** Maximum sessions for this tier (inclusive); null for open-ended */
  max?: TierConfigMax;
  /**
   * Minimum completed sessions for this tier
   * @minimum 0
   */
  min: number;
  /**
   * Commission percentage expressed as decimal
   */
  pct: number;
}

/**
 * Simple time range for schedule entries.
 */
export interface TimeRange {
  end_time: string;
  start_time: string;
}

/**
 * Time slot for availability.
 */
export interface TimeSlot {
  end_time: string;
  start_time: string;
}

export type TopCategoryItemIconName = string | null;

/**
 * Top services grouped under a category.
 */
export interface TopCategoryItem {
  icon_name?: TopCategoryItemIconName;
  id: string;
  name: string;
  services?: TopCategoryServiceItem[];
  slug: string;
}

export type TopCategoryServiceItemDisplayOrder = number | null;

/**
 * Minimal service representation for top-per-category capsules.
 */
export interface TopCategoryServiceItem {
  active_instructors?: number;
  demand_score?: number;
  display_order?: TopCategoryServiceItemDisplayOrder;
  id: string;
  is_trending?: boolean;
  name: string;
  slug: string;
}

export type TopReferrerOutCode = string | null;

/**
 * Top referrer metadata for admin dashboards.
 */
export interface TopReferrerOut {
  code?: TopReferrerOutCode;
  count: number;
  user_id: string;
}

/**
 * Metadata for top-per-category payloads.
 */
export interface TopServicesMetadata {
  cached_for_seconds: number;
  services_per_category: number;
  total_categories: number;
  updated_at: string;
}

/**
 * Response payload for top services per category.
 */
export interface TopServicesPerCategoryResponse {
  categories?: TopCategoryItem[];
  metadata: TopServicesMetadata;
}

/**
 * Status of the tip payment
 */
export type TransactionHistoryItemTipStatus = string | null;

/**
 * Individual transaction in payment history.
 */
export interface TransactionHistoryItem {
  /** Date of the booking */
  booking_date: string;
  /** Booking ID */
  booking_id: string;
  /** When the payment was created */
  created_at: string;
  /** Credits applied to this transaction */
  credit_applied: number;
  /** Duration in minutes */
  duration_minutes: number;
  /** End time of the booking */
  end_time: string;
  /** Hourly rate charged */
  hourly_rate: number;
  /** Payment intent ID */
  id: string;
  /** Instructor name (first name + last initial) */
  instructor_name: string;
  /** Lesson price before fees */
  lesson_amount: number;
  /** Student service fee amount */
  service_fee: number;
  /** Service name */
  service_name: string;
  /** Start time of the booking */
  start_time: string;
  /** Payment status */
  status: string;
  /** Tip amount recorded */
  tip_amount: number;
  /** Tip amount successfully charged */
  tip_paid: number;
  /** Status of the tip payment */
  tip_status?: TransactionHistoryItemTipStatus;
  /** Final amount charged including tips */
  total_paid: number;
}

export interface TypingStatusResponse {
  success?: boolean;
}

export interface UnreadCountResponse {
  unread_count: number;
  user_id: string;
}

export type UpcomingBookingResponseMeetingLocation = string | null;

/**
 * Simplified response for upcoming bookings widget.

Privacy-aware: instructor_last_name shows last initial for students,
full last name for instructors viewing their own bookings.
 */
export interface UpcomingBookingResponse {
  booking_date: string;
  end_time: string;
  id: string;
  instructor_first_name: string;
  instructor_id: string;
  instructor_last_name: string;
  meeting_location: UpcomingBookingResponseMeetingLocation;
  service_name: string;
  start_time: string;
  student_first_name: string;
  student_last_name: string;
  total_price: number;
}

/**
 * Basic user information with privacy protection.

Shows only last initial instead of full last name for privacy.
Used in student-facing endpoints to protect instructor privacy.
Email is omitted for privacy protection.
 */
export interface UserBasicPrivacy {
  first_name: string;
  id: string;
  last_initial: string;
}

/**
 * User type breakdown.
 */
export interface UserBreakdown {
  /** Number of authenticated users */
  authenticated: number;
  /** Number of guests who converted to users */
  converted_guests: number;
  /** Percentage of guests */
  guest_percentage: number;
  /** Number of guest sessions */
  guests: number;
  /** Percentage of authenticated users */
  user_percentage: number;
}

export type UserCreateGuestSessionId = string | null;

export type UserCreateIsActive = boolean | null;

export type UserCreateMetadataAnyOf = { [key: string]: unknown };

export type UserCreateMetadata = UserCreateMetadataAnyOf | null;

export type UserCreatePhone = string | null;

export type UserCreateRole = string | null;

export type UserCreateTimezone = string | null;

export interface UserCreate {
  email: string;
  /**
   * @minLength 1
   * @maxLength 50
   */
  first_name: string;
  guest_session_id?: UserCreateGuestSessionId;
  is_active?: UserCreateIsActive;
  /**
   * @minLength 1
   * @maxLength 50
   */
  last_name: string;
  metadata?: UserCreateMetadata;
  password: string;
  phone?: UserCreatePhone;
  role?: UserCreateRole;
  timezone?: UserCreateTimezone;
  /** @pattern ^\d{5}$ */
  zip_code: string;
}

/**
 * Request schema for user data deletion.
 */
export interface UserDataDeletionRequest {
  /** Whether to delete the entire account or just anonymize data */
  delete_account?: boolean;
}

/**
 * Statistics of deleted records
 */
export type UserDataDeletionResponseDeletionStats = {[key: string]: number};

export interface UserDataDeletionResponse {
  /** Whether the account was deleted */
  account_deleted: boolean;
  /** Statistics of deleted records */
  deletion_stats: UserDataDeletionResponseDeletionStats;
  /** Human-readable message */
  message: string;
  /** Status of the deletion request */
  status: string;
}

export type UserLoginGuestSessionId = string | null;

export interface UserLogin {
  email: string;
  guest_session_id?: UserLoginGuestSessionId;
  password: string;
}

export type UserUpdateFirstName = string | null;

export type UserUpdateLastName = string | null;

export type UserUpdatePhone = string | null;

export type UserUpdateTimezone = string | null;

export type UserUpdateZipCode = string | null;

export interface UserUpdate {
  first_name?: UserUpdateFirstName;
  last_name?: UserUpdateLastName;
  phone?: UserUpdatePhone;
  timezone?: UserUpdateTimezone;
  zip_code?: UserUpdateZipCode;
}

export type ValidateWeekRequestCurrentWeek = {[key: string]: TimeSlot[]};

export type ValidateWeekRequestSavedWeek = {[key: string]: TimeSlot[]};

/**
 * Request to validate week changes
 */
export interface ValidateWeekRequest {
  current_week: ValidateWeekRequestCurrentWeek;
  saved_week: ValidateWeekRequestSavedWeek;
  week_start: string;
}

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type ValidationSlotDetailConflictsWithAnyOfItem = { [key: string]: unknown };

export type ValidationSlotDetailConflictsWith = ValidationSlotDetailConflictsWithAnyOfItem[] | null;

export type ValidationSlotDetailDate = string | null;

export type ValidationSlotDetailEndTime = string | null;

export type ValidationSlotDetailReason = string | null;

export type ValidationSlotDetailSlotId = string | null;

export type ValidationSlotDetailStartTime = string | null;

/**
 * Details about a slot operation in validation
 */
export interface ValidationSlotDetail {
  action: string;
  conflicts_with?: ValidationSlotDetailConflictsWith;
  date?: ValidationSlotDetailDate;
  end_time?: ValidationSlotDetailEndTime;
  operation_index: number;
  reason?: ValidationSlotDetailReason;
  slot_id?: ValidationSlotDetailSlotId;
  start_time?: ValidationSlotDetailStartTime;
}

export type ValidationSummaryEstimatedChanges = {[key: string]: number};

export type ValidationSummaryOperationsByType = {[key: string]: number};

/**
 * Summary of validation results
 */
export interface ValidationSummary {
  estimated_changes: ValidationSummaryEstimatedChanges;
  has_conflicts: boolean;
  invalid_operations: number;
  operations_by_type: ValidationSummaryOperationsByType;
  total_operations: number;
  valid_operations: number;
}

/**
 * Additional information
 */
export type WebhookResponseMessage = string | null;

export interface WebhookResponse {
  /** Stripe event type */
  event_type: string;
  /** Additional information */
  message?: WebhookResponseMessage;
  /** Processing status (success, ignored, error) */
  status: string;
}

/**
 * Week availability mapping keyed by ISO date string.
 */
export interface WeekAvailabilityResponse {[key: string]: TimeRange[]}

export type WeekAvailabilityUpdateResponseVersion = string | null;

export type WeekAvailabilityUpdateResponseWeekVersion = string | null;

export interface WeekAvailabilityUpdateResponse {
  days_written?: number;
  edited_dates?: string[];
  message: string;
  skipped_dates?: string[];
  skipped_past_window?: number;
  version?: WeekAvailabilityUpdateResponseVersion;
  week_end: string;
  week_start: string;
  week_version?: WeekAvailabilityUpdateResponseWeekVersion;
  weeks_affected?: number;
  windows_created: number;
  windows_deleted: number;
  windows_updated: number;
}

/**
 * Client's baseline week version when saving (If-Match fallback)
 */
export type WeekSpecificScheduleCreateBaseVersion = string | null;

export type WeekSpecificScheduleCreateScheduleItem = { [key: string]: unknown };

/**
 * Deprecated alias for base_version (optimistic concurrency token)
 */
export type WeekSpecificScheduleCreateVersion = string | null;

/**
 * Optional Monday date. If not provided, inferred from schedule dates
 */
export type WeekSpecificScheduleCreateWeekStart = string | null;

/**
 * Schema for creating schedule for specific dates.
 */
export interface WeekSpecificScheduleCreate {
  /** Client's baseline week version when saving (If-Match fallback) */
  base_version?: WeekSpecificScheduleCreateBaseVersion;
  /** Whether to clear existing entries for the week before saving */
  clear_existing?: boolean;
  /** If true, bypass server-side version checks when saving */
  override?: boolean;
  schedule: WeekSpecificScheduleCreateScheduleItem[];
  /** Deprecated alias for base_version (optimistic concurrency token) */
  version?: WeekSpecificScheduleCreateVersion;
  /** Optional Monday date. If not provided, inferred from schedule dates */
  week_start?: WeekSpecificScheduleCreateWeekStart;
}

/**
 * Response for week schedule validation
 */
export interface WeekValidationResponse {
  details: ValidationSlotDetail[];
  summary: ValidationSummary;
  valid: boolean;
  warnings?: string[];
}

/**
 * Standard delete acknowledgement for address resources.
 */
export interface AppSchemasAddressResponsesDeleteResponse {
  message: string;
  success: boolean;
}

/**
 * Standard response for delete operations.
 */
export interface AppSchemasBaseResponsesDeleteResponse {
  /** Deletion timestamp */
  deleted_at?: string;
  /** Human-readable deletion message */
  message: string;
  /** Deletion success status */
  success?: boolean;
}

/**
 * Instructor information for booking display.

Privacy-aware: Only shows last initial for privacy protection.
Full last name never exposed to students.
 */
export interface AppSchemasBookingInstructorInfo {
  first_name: string;
  id: string;
  last_initial: string;
}

export interface AppSchemasPaymentSchemasDeleteResponse {
  /** Whether deletion was successful */
  success: boolean;
}

/**
 * Instructor bio
 */
export type AppSchemasSearchResponsesInstructorInfoBio = string | null;

/**
 * Summary of borough coverage (e.g., 'Manhattan, Queens')
 */
export type AppSchemasSearchResponsesInstructorInfoServiceAreaSummary = string | null;

/**
 * Years of experience
 */
export type AppSchemasSearchResponsesInstructorInfoYearsExperience = number | null;

/**
 * Instructor information in search results with privacy protection.
 */
export interface AppSchemasSearchResponsesInstructorInfo {
  /** Instructor bio */
  bio?: AppSchemasSearchResponsesInstructorInfoBio;
  /** Instructor first name */
  first_name: string;
  /** Instructor user ID */
  id: string;
  /** Instructor last name initial only */
  last_initial: string;
  /** List of borough names the instructor serves */
  service_area_boroughs?: string[];
  /** Detailed neighborhood coverage with keys: neighborhood_id, ntacode, name, borough */
  service_area_neighborhoods?: ServiceAreaNeighborhood[];
  /** Summary of borough coverage (e.g., 'Manhattan, Queens') */
  service_area_summary?: AppSchemasSearchResponsesInstructorInfoServiceAreaSummary;
  /** Years of experience */
  years_experience?: AppSchemasSearchResponsesInstructorInfoYearsExperience;
}

export type GetBulkCoverageGeojsonApiAddressesCoverageBulkGetParams = {
ids: string;
};

export type PlacesAutocompleteApiAddressesPlacesAutocompleteGetParams = {
q: string;
provider?: string | null;
scope?: string | null;
};

export type PlaceDetailsApiAddressesPlacesDetailsGetParams = {
place_id: string;
provider?: string | null;
};

export type ListNeighborhoodsApiAddressesRegionsNeighborhoodsGetParams = {
region_type?: string;
borough?: string | null;
page?: number;
per_page?: number;
};

export type IsNycZipApiAddressesZipIsNycGetParams = {
zip: string;
};

export type ExportAnalyticsApiAnalyticsExportPostParams = {
format?: string;
};

export type CandidatesCategoryTrendsApiAnalyticsSearchCandidatesCategoryTrendsGetParams = {
/**
 * @minimum 1
 * @maximum 365
 */
days?: number;
};

export type CandidateServiceQueriesApiAnalyticsSearchCandidatesQueriesGetParams = {
service_catalog_id: string;
/**
 * @minimum 1
 * @maximum 365
 */
days?: number;
/**
 * @minimum 1
 * @maximum 200
 */
limit?: number;
};

export type CandidatesScoreDistributionApiAnalyticsSearchCandidatesScoreDistributionGetParams = {
/**
 * @minimum 1
 * @maximum 365
 */
days?: number;
};

export type CandidatesSummaryApiAnalyticsSearchCandidatesSummaryGetParams = {
/**
 * @minimum 1
 * @maximum 365
 */
days?: number;
};

export type CandidatesTopServicesApiAnalyticsSearchCandidatesTopServicesGetParams = {
/**
 * @minimum 1
 * @maximum 365
 */
days?: number;
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
};

export type GetConversionMetricsApiAnalyticsSearchConversionMetricsGetParams = {
/**
 * @minimum 1
 * @maximum 365
 */
days?: number;
};

export type GetPopularSearchesApiAnalyticsSearchPopularSearchesGetParams = {
/**
 * @minimum 1
 * @maximum 365
 */
days?: number;
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
};

export type GetSearchReferrersApiAnalyticsSearchReferrersGetParams = {
/**
 * @minimum 1
 * @maximum 365
 */
days?: number;
};

export type GetSearchAnalyticsSummaryApiAnalyticsSearchSearchAnalyticsSummaryGetParams = {
/**
 * @minimum 1
 * @maximum 365
 */
days?: number;
};

export type GetSearchPerformanceApiAnalyticsSearchSearchPerformanceGetParams = {
/**
 * @minimum 1
 * @maximum 365
 */
days?: number;
};

export type GetSearchTrendsApiAnalyticsSearchSearchTrendsGetParams = {
/**
 * @minimum 1
 * @maximum 365
 */
days?: number;
};

export type GetInviteBatchProgressApiBetaInvitesSendBatchProgressGetParams = {
task_id: string;
};

export type ValidateInviteApiBetaInvitesValidateGetParams = {
code?: string | null;
invite_code?: string | null;
email?: string | null;
};

export type GetMessageHistoryApiMessagesHistoryBookingIdGetParams = {
/**
 * @minimum 1
 * @maximum 100
 */
limit?: number;
/**
 * @minimum 0
 */
offset?: number;
};

export type StreamMessagesApiMessagesStreamBookingIdGetParams = {
token?: string | null;
};

export type GetLiveAlertsApiMonitoringAlertsLiveGetParams = {
/**
 * Get alerts from last N minutes
 */
minutes?: number;
};

export type GetRecentAlertsApiMonitoringAlertsRecentGetParams = {
/**
 * Get alerts from last N hours
 */
hours?: number;
/**
 * Maximum number of alerts to return
 */
limit?: number;
/**
 * Filter by severity
 */
severity?: string | null;
};

export type GetAlertSummaryApiMonitoringAlertsSummaryGetParams = {
/**
 * Number of days to summarize
 */
days?: number;
};

export type GetSlowQueriesApiMonitoringSlowQueriesGetParams = {
limit?: number;
};

export type GetSlowRequestsApiMonitoringSlowRequestsGetParams = {
limit?: number;
};

export type StartOnboardingApiPaymentsConnectOnboardPostParams = {
return_to?: string | null;
};

export type SetPayoutScheduleApiPaymentsConnectPayoutSchedulePostParams = {
interval?: string;
weekly_anchor?: string;
};

export type GetTransactionHistoryApiPaymentsTransactionsGetParams = {
limit?: number;
offset?: number;
};

export type GetInstructorPublicAvailabilityApiPublicInstructorsInstructorIdAvailabilityGetParams = {
/**
 * Start date for availability search
 */
start_date: string;
/**
 * End date (defaults to configured days from start)
 */
end_date?: string | null;
};

export type GetNextAvailableSlotApiPublicInstructorsInstructorIdNextAvailableGetParams = {
/**
 * Required duration in minutes
 */
duration_minutes?: number;
};

export type ApplyReferralCreditApiReferralsCheckoutApplyReferralPost200 = CheckoutApplyResponse | ReferralErrorResponse;

export type ClaimReferralCodeApiReferralsClaimPost200 = ReferralClaimResponse | ReferralErrorResponse;

export type GetReviewForBookingApiReviewsBookingBookingIdGet200 = ReviewItem | null;

export type GetRecentReviewsApiReviewsInstructorInstructorIdRecentGetParams = {
instructor_service_id?: string | null;
/**
 * @minimum 1
 * @maximum 50
 */
limit?: number;
/**
 * @minimum 1
 */
page?: number;
min_rating?: number | null;
rating?: number | null;
with_text?: boolean | null;
};

export type GetSearchRatingApiReviewsInstructorInstructorIdSearchRatingGetParams = {
instructor_service_id?: string | null;
};

export type RespondToReviewApiReviewsReviewsReviewIdRespondPostParams = {
response_text: string;
};

export type GetRecentSearchesApiSearchHistoryGetParams = {
limit?: number;
};

export type TrackInteractionApiSearchHistoryInteractionPostBody = { [key: string]: unknown };

export type SearchInstructorsApiSearchInstructorsGetParams = {
/**
 * Search query
 * @minLength 1
 */
q: string;
/**
 * Maximum results to return
 */
limit?: number | null;
};

export type GetProfilePictureUrlsBatchApiUsersProfilePictureUrlsGetParams = {
/**
 * Comma-separated list of user IDs (ids=1,2,3) or repeated ids parameters.
 */
ids?: string[];
variant?: 'original' | 'display' | 'thumb' | null;
};

export type GetProfilePictureUrlApiUsersUserIdProfilePictureUrlGetParams = {
variant?: 'original' | 'display' | 'thumb' | null;
};

export type GetBookingsApiV1BookingsGetParams = {
status?: BookingStatus | null;
upcoming_only?: boolean | null;
upcoming?: boolean | null;
exclude_future_confirmed?: boolean;
include_past_confirmed?: boolean;
/**
 * @minimum 1
 */
page?: number;
/**
 * @minimum 1
 * @maximum 100
 */
per_page?: number;
};

export type GetUpcomingBookingsApiV1BookingsUpcomingGetParams = {
/**
 * @minimum 1
 * @maximum 20
 */
limit?: number;
};

export type ListInstructorBookingsApiV1InstructorBookingsGetParams = {
/**
 * Filter by booking status (COMPLETED, CONFIRMED, etc.)
 */
status?: BookingStatus | null;
/**
 * Only include upcoming confirmed bookings
 */
upcoming?: boolean;
/**
 * Page number
 * @minimum 1
 */
page?: number;
/**
 * Items per page
 * @minimum 1
 * @maximum 100
 */
per_page?: number;
include_past_confirmed?: boolean;
};

export type GetCompletedBookingsApiV1InstructorBookingsCompletedGetParams = {
/**
 * Page number
 * @minimum 1
 */
page?: number;
/**
 * Items per page
 * @minimum 1
 * @maximum 100
 */
per_page?: number;
};

export type GetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGetParams = {
/**
 * Page number
 * @minimum 1
 */
page?: number;
/**
 * Items per page
 * @minimum 1
 * @maximum 100
 */
per_page?: number;
};

export type GetUpcomingBookingsApiV1InstructorBookingsUpcomingGetParams = {
/**
 * Page number
 * @minimum 1
 */
page?: number;
/**
 * Items per page
 * @minimum 1
 * @maximum 100
 */
per_page?: number;
};

export type MarkLessonCompleteApiV1InstructorBookingsBookingIdCompletePostParams = {
notes?: string | null;
};

export type ListInstructorsApiV1InstructorsGetParams = {
/**
 * Service catalog ID (required)
 */
service_catalog_id: string;
/**
 * Minimum hourly rate
 * @minimum 0
 * @maximum 1000
 */
min_price?: number;
/**
 * Maximum hourly rate
 * @minimum 0
 * @maximum 1000
 */
max_price?: number;
/**
 * Filter by age group: 'kids' or 'adults'
 */
age_group?: string;
/**
 * Page number
 * @minimum 1
 */
page?: number;
/**
 * Items per page
 * @minimum 1
 * @maximum 100
 */
per_page?: number;
};

export type GetBookingsBookingsGetParams = {
status?: BookingStatus | null;
upcoming_only?: boolean | null;
upcoming?: boolean | null;
exclude_future_confirmed?: boolean;
include_past_confirmed?: boolean;
/**
 * @minimum 1
 */
page?: number;
/**
 * @minimum 1
 * @maximum 100
 */
per_page?: number;
};

export type GetUpcomingBookingsBookingsUpcomingGetParams = {
/**
 * @minimum 1
 * @maximum 20
 */
limit?: number;
};

export type GetAllAvailabilityInstructorsAvailabilityGetParams = {
start_date?: string | null;
end_date?: string | null;
};

export type GetWeekAvailabilityInstructorsAvailabilityWeekGetParams = {
/**
 * Monday of the week
 */
start_date: string;
};

export type SaveWeekAvailabilityInstructorsAvailabilityWeekPostParams = {
/**
 * Set to true to bypass version conflict checks when saving availability
 */
override?: boolean;
};

export type GetWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGetParams = {
/**
 * Start date (Monday) of the week
 */
start_date: string;
};

export type ListInstructorBookingsInstructorsBookingsGetParams = {
/**
 * Filter by booking status (COMPLETED, CONFIRMED, etc.)
 */
status?: BookingStatus | null;
/**
 * Only include upcoming confirmed bookings
 */
upcoming?: boolean;
/**
 * Page number
 * @minimum 1
 */
page?: number;
/**
 * Items per page
 * @minimum 1
 * @maximum 100
 */
per_page?: number;
include_past_confirmed?: boolean;
};

export type GetCompletedBookingsInstructorsBookingsCompletedGetParams = {
/**
 * Page number
 * @minimum 1
 */
page?: number;
/**
 * Items per page
 * @minimum 1
 * @maximum 100
 */
per_page?: number;
};

export type GetPendingCompletionBookingsInstructorsBookingsPendingCompletionGetParams = {
/**
 * Page number
 * @minimum 1
 */
page?: number;
/**
 * Items per page
 * @minimum 1
 * @maximum 100
 */
per_page?: number;
};

export type GetUpcomingBookingsInstructorsBookingsUpcomingGetParams = {
/**
 * Page number
 * @minimum 1
 */
page?: number;
/**
 * Items per page
 * @minimum 1
 * @maximum 100
 */
per_page?: number;
};

export type MarkLessonCompleteInstructorsBookingsBookingIdCompletePostParams = {
notes?: string | null;
};

export type DisputeCompletionInstructorsBookingsBookingIdDisputePostParams = {
reason: string;
};

export type ResetRateLimitsOpsRateLimitsResetPostParams = {
/**
 * Pattern to match (e.g., 'email_*', 'ip_192.168.*')
 */
pattern: string;
};

export type TestRateLimitOpsRateLimitsTestGetParams = {
/**
 * Number of requests to simulate
 * @minimum 1
 * @maximum 20
 */
requests?: number;
};

export type GetCatalogServicesServicesCatalogGetParams = {
/**
 * Filter by category slug
 */
category?: string | null;
};

export type GetTopServicesPerCategoryServicesCatalogTopPerCategoryGetParams = {
/**
 * Number of top services per category
 * @minimum 1
 * @maximum 20
 */
limit?: number;
};

export type SearchServicesServicesSearchGetParams = {
/**
 * Search query
 * @minLength 2
 */
q: string;
};
