/**
 * Generated by orval v8.0.3 üç∫
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  AccessGrantResponse,
  BetaMetricsSummaryResponse,
  BetaSettingsResponse,
  BetaSettingsUpdateRequest,
  GetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGetParams,
  HTTPValidationError,
  InviteBatchAsyncStartResponse,
  InviteBatchProgressResponse,
  InviteBatchSendRequest,
  InviteBatchSendResponse,
  InviteConsumeRequest,
  InviteGenerateRequest,
  InviteGenerateResponse,
  InviteSendRequest,
  InviteSendResponse,
  InviteValidateResponse,
  ValidateInviteApiV1BetaInvitesValidateGetParams,
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary Consume Invite
 */
export const getConsumeInviteApiV1BetaInvitesConsumePostUrl = () => {
  return `/api/v1/beta/invites/consume`;
};

export const consumeInviteApiV1BetaInvitesConsumePost = async (
  inviteConsumeRequest: InviteConsumeRequest,
  options?: RequestInit
): Promise<AccessGrantResponse> => {
  return customFetch<AccessGrantResponse>(getConsumeInviteApiV1BetaInvitesConsumePostUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(inviteConsumeRequest),
  });
};

export const getConsumeInviteApiV1BetaInvitesConsumePostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof consumeInviteApiV1BetaInvitesConsumePost>>,
    TError,
    { data: InviteConsumeRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof consumeInviteApiV1BetaInvitesConsumePost>>,
  TError,
  { data: InviteConsumeRequest },
  TContext
> => {
  const mutationKey = ['consumeInviteApiV1BetaInvitesConsumePost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof consumeInviteApiV1BetaInvitesConsumePost>>,
    { data: InviteConsumeRequest }
  > = (props) => {
    const { data } = props ?? {};

    return consumeInviteApiV1BetaInvitesConsumePost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ConsumeInviteApiV1BetaInvitesConsumePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof consumeInviteApiV1BetaInvitesConsumePost>>
>;
export type ConsumeInviteApiV1BetaInvitesConsumePostMutationBody = InviteConsumeRequest;
export type ConsumeInviteApiV1BetaInvitesConsumePostMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Consume Invite
 */
export const useConsumeInviteApiV1BetaInvitesConsumePost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof consumeInviteApiV1BetaInvitesConsumePost>>,
      TError,
      { data: InviteConsumeRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof consumeInviteApiV1BetaInvitesConsumePost>>,
  TError,
  { data: InviteConsumeRequest },
  TContext
> => {
  return useMutation(
    getConsumeInviteApiV1BetaInvitesConsumePostMutationOptions(options),
    queryClient
  );
};
/**
 * @summary Generate Invites
 */
export const getGenerateInvitesApiV1BetaInvitesGeneratePostUrl = () => {
  return `/api/v1/beta/invites/generate`;
};

export const generateInvitesApiV1BetaInvitesGeneratePost = async (
  inviteGenerateRequest: InviteGenerateRequest,
  options?: RequestInit
): Promise<InviteGenerateResponse> => {
  return customFetch<InviteGenerateResponse>(getGenerateInvitesApiV1BetaInvitesGeneratePostUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(inviteGenerateRequest),
  });
};

export const getGenerateInvitesApiV1BetaInvitesGeneratePostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof generateInvitesApiV1BetaInvitesGeneratePost>>,
    TError,
    { data: InviteGenerateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof generateInvitesApiV1BetaInvitesGeneratePost>>,
  TError,
  { data: InviteGenerateRequest },
  TContext
> => {
  const mutationKey = ['generateInvitesApiV1BetaInvitesGeneratePost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof generateInvitesApiV1BetaInvitesGeneratePost>>,
    { data: InviteGenerateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return generateInvitesApiV1BetaInvitesGeneratePost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type GenerateInvitesApiV1BetaInvitesGeneratePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof generateInvitesApiV1BetaInvitesGeneratePost>>
>;
export type GenerateInvitesApiV1BetaInvitesGeneratePostMutationBody = InviteGenerateRequest;
export type GenerateInvitesApiV1BetaInvitesGeneratePostMutationError =
  ErrorType<HTTPValidationError>;

/**
 * @summary Generate Invites
 */
export const useGenerateInvitesApiV1BetaInvitesGeneratePost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof generateInvitesApiV1BetaInvitesGeneratePost>>,
      TError,
      { data: InviteGenerateRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof generateInvitesApiV1BetaInvitesGeneratePost>>,
  TError,
  { data: InviteGenerateRequest },
  TContext
> => {
  return useMutation(
    getGenerateInvitesApiV1BetaInvitesGeneratePostMutationOptions(options),
    queryClient
  );
};
/**
 * @summary Send Invite
 */
export const getSendInviteApiV1BetaInvitesSendPostUrl = () => {
  return `/api/v1/beta/invites/send`;
};

export const sendInviteApiV1BetaInvitesSendPost = async (
  inviteSendRequest: InviteSendRequest,
  options?: RequestInit
): Promise<InviteSendResponse> => {
  return customFetch<InviteSendResponse>(getSendInviteApiV1BetaInvitesSendPostUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(inviteSendRequest),
  });
};

export const getSendInviteApiV1BetaInvitesSendPostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendInviteApiV1BetaInvitesSendPost>>,
    TError,
    { data: InviteSendRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendInviteApiV1BetaInvitesSendPost>>,
  TError,
  { data: InviteSendRequest },
  TContext
> => {
  const mutationKey = ['sendInviteApiV1BetaInvitesSendPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendInviteApiV1BetaInvitesSendPost>>,
    { data: InviteSendRequest }
  > = (props) => {
    const { data } = props ?? {};

    return sendInviteApiV1BetaInvitesSendPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SendInviteApiV1BetaInvitesSendPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof sendInviteApiV1BetaInvitesSendPost>>
>;
export type SendInviteApiV1BetaInvitesSendPostMutationBody = InviteSendRequest;
export type SendInviteApiV1BetaInvitesSendPostMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Send Invite
 */
export const useSendInviteApiV1BetaInvitesSendPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sendInviteApiV1BetaInvitesSendPost>>,
      TError,
      { data: InviteSendRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof sendInviteApiV1BetaInvitesSendPost>>,
  TError,
  { data: InviteSendRequest },
  TContext
> => {
  return useMutation(getSendInviteApiV1BetaInvitesSendPostMutationOptions(options), queryClient);
};
/**
 * @summary Send Invite Batch
 */
export const getSendInviteBatchApiV1BetaInvitesSendBatchPostUrl = () => {
  return `/api/v1/beta/invites/send-batch`;
};

export const sendInviteBatchApiV1BetaInvitesSendBatchPost = async (
  inviteBatchSendRequest: InviteBatchSendRequest,
  options?: RequestInit
): Promise<InviteBatchSendResponse> => {
  return customFetch<InviteBatchSendResponse>(
    getSendInviteBatchApiV1BetaInvitesSendBatchPostUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(inviteBatchSendRequest),
    }
  );
};

export const getSendInviteBatchApiV1BetaInvitesSendBatchPostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendInviteBatchApiV1BetaInvitesSendBatchPost>>,
    TError,
    { data: InviteBatchSendRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendInviteBatchApiV1BetaInvitesSendBatchPost>>,
  TError,
  { data: InviteBatchSendRequest },
  TContext
> => {
  const mutationKey = ['sendInviteBatchApiV1BetaInvitesSendBatchPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendInviteBatchApiV1BetaInvitesSendBatchPost>>,
    { data: InviteBatchSendRequest }
  > = (props) => {
    const { data } = props ?? {};

    return sendInviteBatchApiV1BetaInvitesSendBatchPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SendInviteBatchApiV1BetaInvitesSendBatchPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof sendInviteBatchApiV1BetaInvitesSendBatchPost>>
>;
export type SendInviteBatchApiV1BetaInvitesSendBatchPostMutationBody = InviteBatchSendRequest;
export type SendInviteBatchApiV1BetaInvitesSendBatchPostMutationError =
  ErrorType<HTTPValidationError>;

/**
 * @summary Send Invite Batch
 */
export const useSendInviteBatchApiV1BetaInvitesSendBatchPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sendInviteBatchApiV1BetaInvitesSendBatchPost>>,
      TError,
      { data: InviteBatchSendRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof sendInviteBatchApiV1BetaInvitesSendBatchPost>>,
  TError,
  { data: InviteBatchSendRequest },
  TContext
> => {
  return useMutation(
    getSendInviteBatchApiV1BetaInvitesSendBatchPostMutationOptions(options),
    queryClient
  );
};
/**
 * @summary Send Invite Batch Async
 */
export const getSendInviteBatchAsyncApiV1BetaInvitesSendBatchAsyncPostUrl = () => {
  return `/api/v1/beta/invites/send-batch-async`;
};

export const sendInviteBatchAsyncApiV1BetaInvitesSendBatchAsyncPost = async (
  inviteBatchSendRequest: InviteBatchSendRequest,
  options?: RequestInit
): Promise<InviteBatchAsyncStartResponse> => {
  return customFetch<InviteBatchAsyncStartResponse>(
    getSendInviteBatchAsyncApiV1BetaInvitesSendBatchAsyncPostUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(inviteBatchSendRequest),
    }
  );
};

export const getSendInviteBatchAsyncApiV1BetaInvitesSendBatchAsyncPostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendInviteBatchAsyncApiV1BetaInvitesSendBatchAsyncPost>>,
    TError,
    { data: InviteBatchSendRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendInviteBatchAsyncApiV1BetaInvitesSendBatchAsyncPost>>,
  TError,
  { data: InviteBatchSendRequest },
  TContext
> => {
  const mutationKey = ['sendInviteBatchAsyncApiV1BetaInvitesSendBatchAsyncPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendInviteBatchAsyncApiV1BetaInvitesSendBatchAsyncPost>>,
    { data: InviteBatchSendRequest }
  > = (props) => {
    const { data } = props ?? {};

    return sendInviteBatchAsyncApiV1BetaInvitesSendBatchAsyncPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SendInviteBatchAsyncApiV1BetaInvitesSendBatchAsyncPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof sendInviteBatchAsyncApiV1BetaInvitesSendBatchAsyncPost>>
>;
export type SendInviteBatchAsyncApiV1BetaInvitesSendBatchAsyncPostMutationBody =
  InviteBatchSendRequest;
export type SendInviteBatchAsyncApiV1BetaInvitesSendBatchAsyncPostMutationError =
  ErrorType<HTTPValidationError>;

/**
 * @summary Send Invite Batch Async
 */
export const useSendInviteBatchAsyncApiV1BetaInvitesSendBatchAsyncPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sendInviteBatchAsyncApiV1BetaInvitesSendBatchAsyncPost>>,
      TError,
      { data: InviteBatchSendRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof sendInviteBatchAsyncApiV1BetaInvitesSendBatchAsyncPost>>,
  TError,
  { data: InviteBatchSendRequest },
  TContext
> => {
  return useMutation(
    getSendInviteBatchAsyncApiV1BetaInvitesSendBatchAsyncPostMutationOptions(options),
    queryClient
  );
};
/**
 * @summary Get Invite Batch Progress
 */
export const getGetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGetUrl = (
  params: GetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/beta/invites/send-batch-progress?${stringifiedParams}`
    : `/api/v1/beta/invites/send-batch-progress`;
};

export const getInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet = async (
  params: GetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGetParams,
  options?: RequestInit
): Promise<InviteBatchProgressResponse> => {
  return customFetch<InviteBatchProgressResponse>(
    getGetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGetQueryKey = (
  params?: GetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGetParams
) => {
  return [`/api/v1/beta/invites/send-batch-progress`, ...(params ? [params] : [])] as const;
};

export const getGetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet>>
  > = ({ signal }) =>
    getInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet(params, {
      signal,
      ...requestOptions,
    });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet>>
>;
export type GetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGetQueryError =
  ErrorType<HTTPValidationError>;

export function useGetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet<
  TData = Awaited<ReturnType<typeof getInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet>>,
          TError,
          Awaited<ReturnType<typeof getInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet<
  TData = Awaited<ReturnType<typeof getInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet>>,
          TError,
          Awaited<ReturnType<typeof getInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet<
  TData = Awaited<ReturnType<typeof getInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Invite Batch Progress
 */

export function useGetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet<
  TData = Awaited<ReturnType<typeof getInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInviteBatchProgressApiV1BetaInvitesSendBatchProgressGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInviteBatchProgressApiV1BetaInvitesSendBatchProgressGetQueryOptions(
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Validate Invite
 */
export const getValidateInviteApiV1BetaInvitesValidateGetUrl = (
  params?: ValidateInviteApiV1BetaInvitesValidateGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/beta/invites/validate?${stringifiedParams}`
    : `/api/v1/beta/invites/validate`;
};

export const validateInviteApiV1BetaInvitesValidateGet = async (
  params?: ValidateInviteApiV1BetaInvitesValidateGetParams,
  options?: RequestInit
): Promise<InviteValidateResponse> => {
  return customFetch<InviteValidateResponse>(
    getValidateInviteApiV1BetaInvitesValidateGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getValidateInviteApiV1BetaInvitesValidateGetQueryKey = (
  params?: ValidateInviteApiV1BetaInvitesValidateGetParams
) => {
  return [`/api/v1/beta/invites/validate`, ...(params ? [params] : [])] as const;
};

export const getValidateInviteApiV1BetaInvitesValidateGetQueryOptions = <
  TData = Awaited<ReturnType<typeof validateInviteApiV1BetaInvitesValidateGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: ValidateInviteApiV1BetaInvitesValidateGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof validateInviteApiV1BetaInvitesValidateGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getValidateInviteApiV1BetaInvitesValidateGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof validateInviteApiV1BetaInvitesValidateGet>>
  > = ({ signal }) =>
    validateInviteApiV1BetaInvitesValidateGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof validateInviteApiV1BetaInvitesValidateGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ValidateInviteApiV1BetaInvitesValidateGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof validateInviteApiV1BetaInvitesValidateGet>>
>;
export type ValidateInviteApiV1BetaInvitesValidateGetQueryError = ErrorType<HTTPValidationError>;

export function useValidateInviteApiV1BetaInvitesValidateGet<
  TData = Awaited<ReturnType<typeof validateInviteApiV1BetaInvitesValidateGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: undefined | ValidateInviteApiV1BetaInvitesValidateGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof validateInviteApiV1BetaInvitesValidateGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateInviteApiV1BetaInvitesValidateGet>>,
          TError,
          Awaited<ReturnType<typeof validateInviteApiV1BetaInvitesValidateGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useValidateInviteApiV1BetaInvitesValidateGet<
  TData = Awaited<ReturnType<typeof validateInviteApiV1BetaInvitesValidateGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: ValidateInviteApiV1BetaInvitesValidateGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof validateInviteApiV1BetaInvitesValidateGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateInviteApiV1BetaInvitesValidateGet>>,
          TError,
          Awaited<ReturnType<typeof validateInviteApiV1BetaInvitesValidateGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useValidateInviteApiV1BetaInvitesValidateGet<
  TData = Awaited<ReturnType<typeof validateInviteApiV1BetaInvitesValidateGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: ValidateInviteApiV1BetaInvitesValidateGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof validateInviteApiV1BetaInvitesValidateGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Validate Invite
 */

export function useValidateInviteApiV1BetaInvitesValidateGet<
  TData = Awaited<ReturnType<typeof validateInviteApiV1BetaInvitesValidateGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: ValidateInviteApiV1BetaInvitesValidateGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof validateInviteApiV1BetaInvitesValidateGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getValidateInviteApiV1BetaInvitesValidateGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Invite Verified
 */
export const getInviteVerifiedApiV1BetaInvitesVerifiedGetUrl = () => {
  return `/api/v1/beta/invites/verified`;
};

export const inviteVerifiedApiV1BetaInvitesVerifiedGet = async (
  options?: RequestInit
): Promise<void> => {
  return customFetch<void>(getInviteVerifiedApiV1BetaInvitesVerifiedGetUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getInviteVerifiedApiV1BetaInvitesVerifiedGetQueryKey = () => {
  return [`/api/v1/beta/invites/verified`] as const;
};

export const getInviteVerifiedApiV1BetaInvitesVerifiedGetQueryOptions = <
  TData = Awaited<ReturnType<typeof inviteVerifiedApiV1BetaInvitesVerifiedGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof inviteVerifiedApiV1BetaInvitesVerifiedGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getInviteVerifiedApiV1BetaInvitesVerifiedGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof inviteVerifiedApiV1BetaInvitesVerifiedGet>>
  > = ({ signal }) => inviteVerifiedApiV1BetaInvitesVerifiedGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof inviteVerifiedApiV1BetaInvitesVerifiedGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type InviteVerifiedApiV1BetaInvitesVerifiedGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof inviteVerifiedApiV1BetaInvitesVerifiedGet>>
>;
export type InviteVerifiedApiV1BetaInvitesVerifiedGetQueryError = ErrorType<unknown>;

export function useInviteVerifiedApiV1BetaInvitesVerifiedGet<
  TData = Awaited<ReturnType<typeof inviteVerifiedApiV1BetaInvitesVerifiedGet>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof inviteVerifiedApiV1BetaInvitesVerifiedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof inviteVerifiedApiV1BetaInvitesVerifiedGet>>,
          TError,
          Awaited<ReturnType<typeof inviteVerifiedApiV1BetaInvitesVerifiedGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useInviteVerifiedApiV1BetaInvitesVerifiedGet<
  TData = Awaited<ReturnType<typeof inviteVerifiedApiV1BetaInvitesVerifiedGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof inviteVerifiedApiV1BetaInvitesVerifiedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof inviteVerifiedApiV1BetaInvitesVerifiedGet>>,
          TError,
          Awaited<ReturnType<typeof inviteVerifiedApiV1BetaInvitesVerifiedGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useInviteVerifiedApiV1BetaInvitesVerifiedGet<
  TData = Awaited<ReturnType<typeof inviteVerifiedApiV1BetaInvitesVerifiedGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof inviteVerifiedApiV1BetaInvitesVerifiedGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Invite Verified
 */

export function useInviteVerifiedApiV1BetaInvitesVerifiedGet<
  TData = Awaited<ReturnType<typeof inviteVerifiedApiV1BetaInvitesVerifiedGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof inviteVerifiedApiV1BetaInvitesVerifiedGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getInviteVerifiedApiV1BetaInvitesVerifiedGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Lightweight summary derived from in-process counters.

Note: Without Prometheus remote-read, we return cumulative counts observed since process start.
 * @summary Get Beta Metrics Summary
 */
export const getGetBetaMetricsSummaryApiV1BetaMetricsSummaryGetUrl = () => {
  return `/api/v1/beta/metrics/summary`;
};

export const getBetaMetricsSummaryApiV1BetaMetricsSummaryGet = async (
  options?: RequestInit
): Promise<BetaMetricsSummaryResponse> => {
  return customFetch<BetaMetricsSummaryResponse>(
    getGetBetaMetricsSummaryApiV1BetaMetricsSummaryGetUrl(),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetBetaMetricsSummaryApiV1BetaMetricsSummaryGetQueryKey = () => {
  return [`/api/v1/beta/metrics/summary`] as const;
};

export const getGetBetaMetricsSummaryApiV1BetaMetricsSummaryGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBetaMetricsSummaryApiV1BetaMetricsSummaryGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getBetaMetricsSummaryApiV1BetaMetricsSummaryGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetBetaMetricsSummaryApiV1BetaMetricsSummaryGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getBetaMetricsSummaryApiV1BetaMetricsSummaryGet>>
  > = ({ signal }) =>
    getBetaMetricsSummaryApiV1BetaMetricsSummaryGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBetaMetricsSummaryApiV1BetaMetricsSummaryGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBetaMetricsSummaryApiV1BetaMetricsSummaryGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBetaMetricsSummaryApiV1BetaMetricsSummaryGet>>
>;
export type GetBetaMetricsSummaryApiV1BetaMetricsSummaryGetQueryError = ErrorType<unknown>;

export function useGetBetaMetricsSummaryApiV1BetaMetricsSummaryGet<
  TData = Awaited<ReturnType<typeof getBetaMetricsSummaryApiV1BetaMetricsSummaryGet>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBetaMetricsSummaryApiV1BetaMetricsSummaryGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBetaMetricsSummaryApiV1BetaMetricsSummaryGet>>,
          TError,
          Awaited<ReturnType<typeof getBetaMetricsSummaryApiV1BetaMetricsSummaryGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBetaMetricsSummaryApiV1BetaMetricsSummaryGet<
  TData = Awaited<ReturnType<typeof getBetaMetricsSummaryApiV1BetaMetricsSummaryGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBetaMetricsSummaryApiV1BetaMetricsSummaryGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBetaMetricsSummaryApiV1BetaMetricsSummaryGet>>,
          TError,
          Awaited<ReturnType<typeof getBetaMetricsSummaryApiV1BetaMetricsSummaryGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBetaMetricsSummaryApiV1BetaMetricsSummaryGet<
  TData = Awaited<ReturnType<typeof getBetaMetricsSummaryApiV1BetaMetricsSummaryGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBetaMetricsSummaryApiV1BetaMetricsSummaryGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Beta Metrics Summary
 */

export function useGetBetaMetricsSummaryApiV1BetaMetricsSummaryGet<
  TData = Awaited<ReturnType<typeof getBetaMetricsSummaryApiV1BetaMetricsSummaryGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBetaMetricsSummaryApiV1BetaMetricsSummaryGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBetaMetricsSummaryApiV1BetaMetricsSummaryGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Get Beta Settings
 */
export const getGetBetaSettingsApiV1BetaSettingsGetUrl = () => {
  return `/api/v1/beta/settings`;
};

export const getBetaSettingsApiV1BetaSettingsGet = async (
  options?: RequestInit
): Promise<BetaSettingsResponse> => {
  return customFetch<BetaSettingsResponse>(getGetBetaSettingsApiV1BetaSettingsGetUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getGetBetaSettingsApiV1BetaSettingsGetQueryKey = () => {
  return [`/api/v1/beta/settings`] as const;
};

export const getGetBetaSettingsApiV1BetaSettingsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBetaSettingsApiV1BetaSettingsGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getBetaSettingsApiV1BetaSettingsGet>>, TError, TData>
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBetaSettingsApiV1BetaSettingsGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBetaSettingsApiV1BetaSettingsGet>>> = ({
    signal,
  }) => getBetaSettingsApiV1BetaSettingsGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBetaSettingsApiV1BetaSettingsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBetaSettingsApiV1BetaSettingsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBetaSettingsApiV1BetaSettingsGet>>
>;
export type GetBetaSettingsApiV1BetaSettingsGetQueryError = ErrorType<unknown>;

export function useGetBetaSettingsApiV1BetaSettingsGet<
  TData = Awaited<ReturnType<typeof getBetaSettingsApiV1BetaSettingsGet>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBetaSettingsApiV1BetaSettingsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBetaSettingsApiV1BetaSettingsGet>>,
          TError,
          Awaited<ReturnType<typeof getBetaSettingsApiV1BetaSettingsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBetaSettingsApiV1BetaSettingsGet<
  TData = Awaited<ReturnType<typeof getBetaSettingsApiV1BetaSettingsGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBetaSettingsApiV1BetaSettingsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBetaSettingsApiV1BetaSettingsGet>>,
          TError,
          Awaited<ReturnType<typeof getBetaSettingsApiV1BetaSettingsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBetaSettingsApiV1BetaSettingsGet<
  TData = Awaited<ReturnType<typeof getBetaSettingsApiV1BetaSettingsGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBetaSettingsApiV1BetaSettingsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Beta Settings
 */

export function useGetBetaSettingsApiV1BetaSettingsGet<
  TData = Awaited<ReturnType<typeof getBetaSettingsApiV1BetaSettingsGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBetaSettingsApiV1BetaSettingsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBetaSettingsApiV1BetaSettingsGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Update Beta Settings
 */
export const getUpdateBetaSettingsApiV1BetaSettingsPutUrl = () => {
  return `/api/v1/beta/settings`;
};

export const updateBetaSettingsApiV1BetaSettingsPut = async (
  betaSettingsUpdateRequest: BetaSettingsUpdateRequest,
  options?: RequestInit
): Promise<BetaSettingsResponse> => {
  return customFetch<BetaSettingsResponse>(getUpdateBetaSettingsApiV1BetaSettingsPutUrl(), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(betaSettingsUpdateRequest),
  });
};

export const getUpdateBetaSettingsApiV1BetaSettingsPutMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateBetaSettingsApiV1BetaSettingsPut>>,
    TError,
    { data: BetaSettingsUpdateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateBetaSettingsApiV1BetaSettingsPut>>,
  TError,
  { data: BetaSettingsUpdateRequest },
  TContext
> => {
  const mutationKey = ['updateBetaSettingsApiV1BetaSettingsPut'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateBetaSettingsApiV1BetaSettingsPut>>,
    { data: BetaSettingsUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return updateBetaSettingsApiV1BetaSettingsPut(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateBetaSettingsApiV1BetaSettingsPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateBetaSettingsApiV1BetaSettingsPut>>
>;
export type UpdateBetaSettingsApiV1BetaSettingsPutMutationBody = BetaSettingsUpdateRequest;
export type UpdateBetaSettingsApiV1BetaSettingsPutMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Update Beta Settings
 */
export const useUpdateBetaSettingsApiV1BetaSettingsPut = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateBetaSettingsApiV1BetaSettingsPut>>,
      TError,
      { data: BetaSettingsUpdateRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateBetaSettingsApiV1BetaSettingsPut>>,
  TError,
  { data: BetaSettingsUpdateRequest },
  TContext
> => {
  return useMutation(
    getUpdateBetaSettingsApiV1BetaSettingsPutMutationOptions(options),
    queryClient
  );
};
