/**
 * Generated by orval v7.16.1 ðŸº
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  DeleteMessageResponse,
  EditMessageRequest,
  HTTPValidationError,
  MarkMessagesReadRequest,
  MarkMessagesReadResponse,
  MessageConfigResponse,
  ReactionRequest,
  StreamUserMessagesApiV1MessagesStreamGetParams,
  UnreadCountResponse,
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';

/**
 * Get public configuration values for the messaging UI.

Returns:
    MessageConfigResponse with edit_window_minutes and other config values.
 * @summary Get Message Config
 */
export const getMessageConfigApiV1MessagesConfigGet = (signal?: AbortSignal) => {
  return customFetch<MessageConfigResponse>({
    url: `/api/v1/messages/config`,
    method: 'GET',
    signal,
  });
};

export const getGetMessageConfigApiV1MessagesConfigGetQueryKey = () => {
  return [`/api/v1/messages/config`] as const;
};

export const getGetMessageConfigApiV1MessagesConfigGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMessageConfigApiV1MessagesConfigGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>
  > = ({ signal }) => getMessageConfigApiV1MessagesConfigGet(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMessageConfigApiV1MessagesConfigGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>
>;
export type GetMessageConfigApiV1MessagesConfigGetQueryError = ErrorType<unknown>;

export function useGetMessageConfigApiV1MessagesConfigGet<
  TData = Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
          TError,
          Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMessageConfigApiV1MessagesConfigGet<
  TData = Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
          TError,
          Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMessageConfigApiV1MessagesConfigGet<
  TData = Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Message Config
 */

export function useGetMessageConfigApiV1MessagesConfigGet<
  TData = Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMessageConfigApiV1MessagesConfigGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Mark messages as read.

Can mark specific messages or all messages in a conversation.
Requires VIEW_MESSAGES permission.
 * @summary Mark Messages As Read
 */
export const markMessagesAsReadApiV1MessagesMarkReadPost = (
  markMessagesReadRequest: MarkMessagesReadRequest,
  signal?: AbortSignal
) => {
  return customFetch<MarkMessagesReadResponse>({
    url: `/api/v1/messages/mark-read`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: markMessagesReadRequest,
    signal,
  });
};

export const getMarkMessagesAsReadApiV1MessagesMarkReadPostMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof markMessagesAsReadApiV1MessagesMarkReadPost>>,
    TError,
    { data: MarkMessagesReadRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof markMessagesAsReadApiV1MessagesMarkReadPost>>,
  TError,
  { data: MarkMessagesReadRequest },
  TContext
> => {
  const mutationKey = ['markMessagesAsReadApiV1MessagesMarkReadPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof markMessagesAsReadApiV1MessagesMarkReadPost>>,
    { data: MarkMessagesReadRequest }
  > = (props) => {
    const { data } = props ?? {};

    return markMessagesAsReadApiV1MessagesMarkReadPost(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type MarkMessagesAsReadApiV1MessagesMarkReadPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof markMessagesAsReadApiV1MessagesMarkReadPost>>
>;
export type MarkMessagesAsReadApiV1MessagesMarkReadPostMutationBody = MarkMessagesReadRequest;
export type MarkMessagesAsReadApiV1MessagesMarkReadPostMutationError = ErrorType<void>;

/**
 * @summary Mark Messages As Read
 */
export const useMarkMessagesAsReadApiV1MessagesMarkReadPost = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof markMessagesAsReadApiV1MessagesMarkReadPost>>,
      TError,
      { data: MarkMessagesReadRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof markMessagesAsReadApiV1MessagesMarkReadPost>>,
  TError,
  { data: MarkMessagesReadRequest },
  TContext
> => {
  const mutationOptions = getMarkMessagesAsReadApiV1MessagesMarkReadPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * SSE endpoint for real-time message streaming - per-user inbox (v4.0).

Establishes a Server-Sent Events connection for receiving
real-time messages across ALL user's conversations.

Architecture (v4.0 with Broadcaster):
- Single Redis PubSub connection shared across all SSE clients per worker
- Enables 500+ concurrent SSE users instead of ~30 with per-connection pattern
- Proper async waiting (no busy-wait polling)

Features:
- Redis Pub/Sub via Broadcaster (fan-out multiplexer)
- Last-Event-ID support for automatic catch-up on reconnect
- new_message events include SSE id: field
- Heartbeat every 10 seconds
- DB session explicitly closed before streaming (prevents idle_in_transaction)

Supports Last-Event-ID header - when reconnecting, the client
automatically sends the last received message ID, and the server
sends any missed messages from the database.

Requires VIEW_MESSAGES permission.
 * @summary Stream User Messages
 */
export const streamUserMessagesApiV1MessagesStreamGet = (
  params?: StreamUserMessagesApiV1MessagesStreamGetParams,
  signal?: AbortSignal
) => {
  return customFetch<unknown>({ url: `/api/v1/messages/stream`, method: 'GET', params, signal });
};

export const getStreamUserMessagesApiV1MessagesStreamGetQueryKey = (
  params?: StreamUserMessagesApiV1MessagesStreamGetParams
) => {
  return [`/api/v1/messages/stream`, ...(params ? [params] : [])] as const;
};

export const getStreamUserMessagesApiV1MessagesStreamGetQueryOptions = <
  TData = Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params?: StreamUserMessagesApiV1MessagesStreamGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStreamUserMessagesApiV1MessagesStreamGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>
  > = ({ signal }) => streamUserMessagesApiV1MessagesStreamGet(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StreamUserMessagesApiV1MessagesStreamGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>
>;
export type StreamUserMessagesApiV1MessagesStreamGetQueryError =
  ErrorType<void | HTTPValidationError>;

export function useStreamUserMessagesApiV1MessagesStreamGet<
  TData = Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params: undefined | StreamUserMessagesApiV1MessagesStreamGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
          TError,
          Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useStreamUserMessagesApiV1MessagesStreamGet<
  TData = Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params?: StreamUserMessagesApiV1MessagesStreamGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
          TError,
          Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useStreamUserMessagesApiV1MessagesStreamGet<
  TData = Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params?: StreamUserMessagesApiV1MessagesStreamGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Stream User Messages
 */

export function useStreamUserMessagesApiV1MessagesStreamGet<
  TData = Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params?: StreamUserMessagesApiV1MessagesStreamGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getStreamUserMessagesApiV1MessagesStreamGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get total unread message count for current user.

Requires VIEW_MESSAGES permission.
 * @summary Get Unread Count
 */
export const getUnreadCountApiV1MessagesUnreadCountGet = (signal?: AbortSignal) => {
  return customFetch<UnreadCountResponse>({
    url: `/api/v1/messages/unread-count`,
    method: 'GET',
    signal,
  });
};

export const getGetUnreadCountApiV1MessagesUnreadCountGetQueryKey = () => {
  return [`/api/v1/messages/unread-count`] as const;
};

export const getGetUnreadCountApiV1MessagesUnreadCountGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
      TError,
      TData
    >
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUnreadCountApiV1MessagesUnreadCountGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>
  > = ({ signal }) => getUnreadCountApiV1MessagesUnreadCountGet(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUnreadCountApiV1MessagesUnreadCountGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>
>;
export type GetUnreadCountApiV1MessagesUnreadCountGetQueryError = ErrorType<void>;

export function useGetUnreadCountApiV1MessagesUnreadCountGet<
  TData = Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
          TError,
          Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUnreadCountApiV1MessagesUnreadCountGet<
  TData = Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
          TError,
          Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUnreadCountApiV1MessagesUnreadCountGet<
  TData = Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Unread Count
 */

export function useGetUnreadCountApiV1MessagesUnreadCountGet<
  TData = Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUnreadCountApiV1MessagesUnreadCountGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Soft delete a message.

Only the sender can delete their own messages.
Requires SEND_MESSAGES permission.
 * @summary Delete Message
 */
export const deleteMessageApiV1MessagesMessageIdDelete = (messageId: string) => {
  return customFetch<DeleteMessageResponse>({
    url: `/api/v1/messages/${messageId}`,
    method: 'DELETE',
  });
};

export const getDeleteMessageApiV1MessagesMessageIdDeleteMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteMessageApiV1MessagesMessageIdDelete>>,
    TError,
    { messageId: string },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteMessageApiV1MessagesMessageIdDelete>>,
  TError,
  { messageId: string },
  TContext
> => {
  const mutationKey = ['deleteMessageApiV1MessagesMessageIdDelete'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteMessageApiV1MessagesMessageIdDelete>>,
    { messageId: string }
  > = (props) => {
    const { messageId } = props ?? {};

    return deleteMessageApiV1MessagesMessageIdDelete(messageId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteMessageApiV1MessagesMessageIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteMessageApiV1MessagesMessageIdDelete>>
>;

export type DeleteMessageApiV1MessagesMessageIdDeleteMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Delete Message
 */
export const useDeleteMessageApiV1MessagesMessageIdDelete = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteMessageApiV1MessagesMessageIdDelete>>,
      TError,
      { messageId: string },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteMessageApiV1MessagesMessageIdDelete>>,
  TError,
  { messageId: string },
  TContext
> => {
  const mutationOptions = getDeleteMessageApiV1MessagesMessageIdDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Edit a message.

Only the sender can edit their own messages within the edit window.
Requires SEND_MESSAGES permission.
 * @summary Edit Message
 */
export const editMessageApiV1MessagesMessageIdPatch = (
  messageId: string,
  editMessageRequest: EditMessageRequest
) => {
  return customFetch<void>({
    url: `/api/v1/messages/${messageId}`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: editMessageRequest,
  });
};

export const getEditMessageApiV1MessagesMessageIdPatchMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof editMessageApiV1MessagesMessageIdPatch>>,
    TError,
    { messageId: string; data: EditMessageRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof editMessageApiV1MessagesMessageIdPatch>>,
  TError,
  { messageId: string; data: EditMessageRequest },
  TContext
> => {
  const mutationKey = ['editMessageApiV1MessagesMessageIdPatch'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof editMessageApiV1MessagesMessageIdPatch>>,
    { messageId: string; data: EditMessageRequest }
  > = (props) => {
    const { messageId, data } = props ?? {};

    return editMessageApiV1MessagesMessageIdPatch(messageId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type EditMessageApiV1MessagesMessageIdPatchMutationResult = NonNullable<
  Awaited<ReturnType<typeof editMessageApiV1MessagesMessageIdPatch>>
>;
export type EditMessageApiV1MessagesMessageIdPatchMutationBody = EditMessageRequest;
export type EditMessageApiV1MessagesMessageIdPatchMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Edit Message
 */
export const useEditMessageApiV1MessagesMessageIdPatch = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof editMessageApiV1MessagesMessageIdPatch>>,
      TError,
      { messageId: string; data: EditMessageRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof editMessageApiV1MessagesMessageIdPatch>>,
  TError,
  { messageId: string; data: EditMessageRequest },
  TContext
> => {
  const mutationOptions = getEditMessageApiV1MessagesMessageIdPatchMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Remove an emoji reaction from a message.

Requires SEND_MESSAGES permission.
Rate limited to 10 per minute.
 * @summary Remove Reaction
 */
export const removeReactionApiV1MessagesMessageIdReactionsDelete = (
  messageId: string,
  reactionRequest: ReactionRequest
) => {
  return customFetch<void>({
    url: `/api/v1/messages/${messageId}/reactions`,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json' },
    data: reactionRequest,
  });
};

export const getRemoveReactionApiV1MessagesMessageIdReactionsDeleteMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeReactionApiV1MessagesMessageIdReactionsDelete>>,
    TError,
    { messageId: string; data: ReactionRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeReactionApiV1MessagesMessageIdReactionsDelete>>,
  TError,
  { messageId: string; data: ReactionRequest },
  TContext
> => {
  const mutationKey = ['removeReactionApiV1MessagesMessageIdReactionsDelete'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeReactionApiV1MessagesMessageIdReactionsDelete>>,
    { messageId: string; data: ReactionRequest }
  > = (props) => {
    const { messageId, data } = props ?? {};

    return removeReactionApiV1MessagesMessageIdReactionsDelete(messageId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveReactionApiV1MessagesMessageIdReactionsDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeReactionApiV1MessagesMessageIdReactionsDelete>>
>;
export type RemoveReactionApiV1MessagesMessageIdReactionsDeleteMutationBody = ReactionRequest;
export type RemoveReactionApiV1MessagesMessageIdReactionsDeleteMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Remove Reaction
 */
export const useRemoveReactionApiV1MessagesMessageIdReactionsDelete = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeReactionApiV1MessagesMessageIdReactionsDelete>>,
      TError,
      { messageId: string; data: ReactionRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof removeReactionApiV1MessagesMessageIdReactionsDelete>>,
  TError,
  { messageId: string; data: ReactionRequest },
  TContext
> => {
  const mutationOptions =
    getRemoveReactionApiV1MessagesMessageIdReactionsDeleteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Add an emoji reaction to a message.

Requires SEND_MESSAGES permission.
Rate limited to 10 per minute.
 * @summary Add Reaction
 */
export const addReactionApiV1MessagesMessageIdReactionsPost = (
  messageId: string,
  reactionRequest: ReactionRequest,
  signal?: AbortSignal
) => {
  return customFetch<void>({
    url: `/api/v1/messages/${messageId}/reactions`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: reactionRequest,
    signal,
  });
};

export const getAddReactionApiV1MessagesMessageIdReactionsPostMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addReactionApiV1MessagesMessageIdReactionsPost>>,
    TError,
    { messageId: string; data: ReactionRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addReactionApiV1MessagesMessageIdReactionsPost>>,
  TError,
  { messageId: string; data: ReactionRequest },
  TContext
> => {
  const mutationKey = ['addReactionApiV1MessagesMessageIdReactionsPost'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addReactionApiV1MessagesMessageIdReactionsPost>>,
    { messageId: string; data: ReactionRequest }
  > = (props) => {
    const { messageId, data } = props ?? {};

    return addReactionApiV1MessagesMessageIdReactionsPost(messageId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddReactionApiV1MessagesMessageIdReactionsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof addReactionApiV1MessagesMessageIdReactionsPost>>
>;
export type AddReactionApiV1MessagesMessageIdReactionsPostMutationBody = ReactionRequest;
export type AddReactionApiV1MessagesMessageIdReactionsPostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Add Reaction
 */
export const useAddReactionApiV1MessagesMessageIdReactionsPost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addReactionApiV1MessagesMessageIdReactionsPost>>,
      TError,
      { messageId: string; data: ReactionRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof addReactionApiV1MessagesMessageIdReactionsPost>>,
  TError,
  { messageId: string; data: ReactionRequest },
  TContext
> => {
  const mutationOptions = getAddReactionApiV1MessagesMessageIdReactionsPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
