/**
 * Generated by orval v8.0.3 üç∫
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  DeleteMessageResponse,
  EditMessageRequest,
  HTTPValidationError,
  MarkMessagesReadRequest,
  MarkMessagesReadResponse,
  MessageConfigResponse,
  ReactionRequest,
  StreamUserMessagesApiV1MessagesStreamGetParams,
  UnreadCountResponse,
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Get public configuration values for the messaging UI.

Returns:
    MessageConfigResponse with edit_window_minutes and other config values.
 * @summary Get Message Config
 */
export const getGetMessageConfigApiV1MessagesConfigGetUrl = () => {
  return `/api/v1/messages/config`;
};

export const getMessageConfigApiV1MessagesConfigGet = async (
  options?: RequestInit
): Promise<MessageConfigResponse> => {
  return customFetch<MessageConfigResponse>(getGetMessageConfigApiV1MessagesConfigGetUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getGetMessageConfigApiV1MessagesConfigGetQueryKey = () => {
  return [`/api/v1/messages/config`] as const;
};

export const getGetMessageConfigApiV1MessagesConfigGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMessageConfigApiV1MessagesConfigGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>
  > = ({ signal }) => getMessageConfigApiV1MessagesConfigGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMessageConfigApiV1MessagesConfigGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>
>;
export type GetMessageConfigApiV1MessagesConfigGetQueryError = ErrorType<unknown>;

export function useGetMessageConfigApiV1MessagesConfigGet<
  TData = Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
          TError,
          Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMessageConfigApiV1MessagesConfigGet<
  TData = Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
          TError,
          Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMessageConfigApiV1MessagesConfigGet<
  TData = Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Message Config
 */

export function useGetMessageConfigApiV1MessagesConfigGet<
  TData = Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMessageConfigApiV1MessagesConfigGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Mark messages as read.

Can mark specific messages or all messages in a conversation.
Requires VIEW_MESSAGES permission.
 * @summary Mark Messages As Read
 */
export const getMarkMessagesAsReadApiV1MessagesMarkReadPostUrl = () => {
  return `/api/v1/messages/mark-read`;
};

export const markMessagesAsReadApiV1MessagesMarkReadPost = async (
  markMessagesReadRequest: MarkMessagesReadRequest,
  options?: RequestInit
): Promise<MarkMessagesReadResponse> => {
  return customFetch<MarkMessagesReadResponse>(
    getMarkMessagesAsReadApiV1MessagesMarkReadPostUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(markMessagesReadRequest),
    }
  );
};

export const getMarkMessagesAsReadApiV1MessagesMarkReadPostMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof markMessagesAsReadApiV1MessagesMarkReadPost>>,
    TError,
    { data: MarkMessagesReadRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof markMessagesAsReadApiV1MessagesMarkReadPost>>,
  TError,
  { data: MarkMessagesReadRequest },
  TContext
> => {
  const mutationKey = ['markMessagesAsReadApiV1MessagesMarkReadPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof markMessagesAsReadApiV1MessagesMarkReadPost>>,
    { data: MarkMessagesReadRequest }
  > = (props) => {
    const { data } = props ?? {};

    return markMessagesAsReadApiV1MessagesMarkReadPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MarkMessagesAsReadApiV1MessagesMarkReadPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof markMessagesAsReadApiV1MessagesMarkReadPost>>
>;
export type MarkMessagesAsReadApiV1MessagesMarkReadPostMutationBody = MarkMessagesReadRequest;
export type MarkMessagesAsReadApiV1MessagesMarkReadPostMutationError = ErrorType<void>;

/**
 * @summary Mark Messages As Read
 */
export const useMarkMessagesAsReadApiV1MessagesMarkReadPost = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof markMessagesAsReadApiV1MessagesMarkReadPost>>,
      TError,
      { data: MarkMessagesReadRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof markMessagesAsReadApiV1MessagesMarkReadPost>>,
  TError,
  { data: MarkMessagesReadRequest },
  TContext
> => {
  return useMutation(
    getMarkMessagesAsReadApiV1MessagesMarkReadPostMutationOptions(options),
    queryClient
  );
};
/**
 * SSE endpoint for real-time message streaming - per-user inbox (v4.0).

Establishes a Server-Sent Events connection for receiving
real-time messages across ALL user's conversations.

Architecture (v4.0 with Broadcaster):
- Single Redis PubSub connection shared across all SSE clients per worker
- Enables 500+ concurrent SSE users instead of ~30 with per-connection pattern
- Proper async waiting (no busy-wait polling)

Features:
- Redis Pub/Sub via Broadcaster (fan-out multiplexer)
- Last-Event-ID support for automatic catch-up on reconnect
- new_message events include SSE id: field
- Heartbeat every 10 seconds
- DB session explicitly closed before streaming (prevents idle_in_transaction)

Supports Last-Event-ID header - when reconnecting, the client
automatically sends the last received message ID, and the server
sends any missed messages from the database.

Requires VIEW_MESSAGES permission.
 * @summary Stream User Messages
 */
export const getStreamUserMessagesApiV1MessagesStreamGetUrl = (
  params?: StreamUserMessagesApiV1MessagesStreamGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/messages/stream?${stringifiedParams}`
    : `/api/v1/messages/stream`;
};

export const streamUserMessagesApiV1MessagesStreamGet = async (
  params?: StreamUserMessagesApiV1MessagesStreamGetParams,
  options?: RequestInit
): Promise<unknown> => {
  return customFetch<unknown>(getStreamUserMessagesApiV1MessagesStreamGetUrl(params), {
    ...options,
    method: 'GET',
  });
};

export const getStreamUserMessagesApiV1MessagesStreamGetQueryKey = (
  params?: StreamUserMessagesApiV1MessagesStreamGetParams
) => {
  return [`/api/v1/messages/stream`, ...(params ? [params] : [])] as const;
};

export const getStreamUserMessagesApiV1MessagesStreamGetQueryOptions = <
  TData = Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params?: StreamUserMessagesApiV1MessagesStreamGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getStreamUserMessagesApiV1MessagesStreamGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>
  > = ({ signal }) =>
    streamUserMessagesApiV1MessagesStreamGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StreamUserMessagesApiV1MessagesStreamGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>
>;
export type StreamUserMessagesApiV1MessagesStreamGetQueryError =
  ErrorType<void | HTTPValidationError>;

export function useStreamUserMessagesApiV1MessagesStreamGet<
  TData = Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params: undefined | StreamUserMessagesApiV1MessagesStreamGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
          TError,
          Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useStreamUserMessagesApiV1MessagesStreamGet<
  TData = Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params?: StreamUserMessagesApiV1MessagesStreamGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
          TError,
          Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useStreamUserMessagesApiV1MessagesStreamGet<
  TData = Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params?: StreamUserMessagesApiV1MessagesStreamGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Stream User Messages
 */

export function useStreamUserMessagesApiV1MessagesStreamGet<
  TData = Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params?: StreamUserMessagesApiV1MessagesStreamGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof streamUserMessagesApiV1MessagesStreamGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getStreamUserMessagesApiV1MessagesStreamGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get total unread message count for current user.

Requires VIEW_MESSAGES permission.
 * @summary Get Unread Count
 */
export const getGetUnreadCountApiV1MessagesUnreadCountGetUrl = () => {
  return `/api/v1/messages/unread-count`;
};

export const getUnreadCountApiV1MessagesUnreadCountGet = async (
  options?: RequestInit
): Promise<UnreadCountResponse> => {
  return customFetch<UnreadCountResponse>(getGetUnreadCountApiV1MessagesUnreadCountGetUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getGetUnreadCountApiV1MessagesUnreadCountGetQueryKey = () => {
  return [`/api/v1/messages/unread-count`] as const;
};

export const getGetUnreadCountApiV1MessagesUnreadCountGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUnreadCountApiV1MessagesUnreadCountGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>
  > = ({ signal }) => getUnreadCountApiV1MessagesUnreadCountGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUnreadCountApiV1MessagesUnreadCountGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>
>;
export type GetUnreadCountApiV1MessagesUnreadCountGetQueryError = ErrorType<void>;

export function useGetUnreadCountApiV1MessagesUnreadCountGet<
  TData = Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
          TError,
          Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUnreadCountApiV1MessagesUnreadCountGet<
  TData = Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
          TError,
          Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUnreadCountApiV1MessagesUnreadCountGet<
  TData = Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Unread Count
 */

export function useGetUnreadCountApiV1MessagesUnreadCountGet<
  TData = Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUnreadCountApiV1MessagesUnreadCountGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Soft delete a message.

Only the sender can delete their own messages.
Requires SEND_MESSAGES permission.
 * @summary Delete Message
 */
export const getDeleteMessageApiV1MessagesMessageIdDeleteUrl = (messageId: string) => {
  return `/api/v1/messages/${messageId}`;
};

export const deleteMessageApiV1MessagesMessageIdDelete = async (
  messageId: string,
  options?: RequestInit
): Promise<DeleteMessageResponse> => {
  return customFetch<DeleteMessageResponse>(
    getDeleteMessageApiV1MessagesMessageIdDeleteUrl(messageId),
    {
      ...options,
      method: 'DELETE',
    }
  );
};

export const getDeleteMessageApiV1MessagesMessageIdDeleteMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteMessageApiV1MessagesMessageIdDelete>>,
    TError,
    { messageId: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteMessageApiV1MessagesMessageIdDelete>>,
  TError,
  { messageId: string },
  TContext
> => {
  const mutationKey = ['deleteMessageApiV1MessagesMessageIdDelete'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteMessageApiV1MessagesMessageIdDelete>>,
    { messageId: string }
  > = (props) => {
    const { messageId } = props ?? {};

    return deleteMessageApiV1MessagesMessageIdDelete(messageId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteMessageApiV1MessagesMessageIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteMessageApiV1MessagesMessageIdDelete>>
>;

export type DeleteMessageApiV1MessagesMessageIdDeleteMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Delete Message
 */
export const useDeleteMessageApiV1MessagesMessageIdDelete = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteMessageApiV1MessagesMessageIdDelete>>,
      TError,
      { messageId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteMessageApiV1MessagesMessageIdDelete>>,
  TError,
  { messageId: string },
  TContext
> => {
  return useMutation(
    getDeleteMessageApiV1MessagesMessageIdDeleteMutationOptions(options),
    queryClient
  );
};
/**
 * Edit a message.

Only the sender can edit their own messages within the edit window.
Requires SEND_MESSAGES permission.
 * @summary Edit Message
 */
export const getEditMessageApiV1MessagesMessageIdPatchUrl = (messageId: string) => {
  return `/api/v1/messages/${messageId}`;
};

export const editMessageApiV1MessagesMessageIdPatch = async (
  messageId: string,
  editMessageRequest: EditMessageRequest,
  options?: RequestInit
): Promise<void> => {
  return customFetch<void>(getEditMessageApiV1MessagesMessageIdPatchUrl(messageId), {
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(editMessageRequest),
  });
};

export const getEditMessageApiV1MessagesMessageIdPatchMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof editMessageApiV1MessagesMessageIdPatch>>,
    TError,
    { messageId: string; data: EditMessageRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof editMessageApiV1MessagesMessageIdPatch>>,
  TError,
  { messageId: string; data: EditMessageRequest },
  TContext
> => {
  const mutationKey = ['editMessageApiV1MessagesMessageIdPatch'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof editMessageApiV1MessagesMessageIdPatch>>,
    { messageId: string; data: EditMessageRequest }
  > = (props) => {
    const { messageId, data } = props ?? {};

    return editMessageApiV1MessagesMessageIdPatch(messageId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type EditMessageApiV1MessagesMessageIdPatchMutationResult = NonNullable<
  Awaited<ReturnType<typeof editMessageApiV1MessagesMessageIdPatch>>
>;
export type EditMessageApiV1MessagesMessageIdPatchMutationBody = EditMessageRequest;
export type EditMessageApiV1MessagesMessageIdPatchMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Edit Message
 */
export const useEditMessageApiV1MessagesMessageIdPatch = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof editMessageApiV1MessagesMessageIdPatch>>,
      TError,
      { messageId: string; data: EditMessageRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof editMessageApiV1MessagesMessageIdPatch>>,
  TError,
  { messageId: string; data: EditMessageRequest },
  TContext
> => {
  return useMutation(
    getEditMessageApiV1MessagesMessageIdPatchMutationOptions(options),
    queryClient
  );
};
/**
 * Remove an emoji reaction from a message.

Requires SEND_MESSAGES permission.
Rate limited to 10 per minute.
 * @summary Remove Reaction
 */
export const getRemoveReactionApiV1MessagesMessageIdReactionsDeleteUrl = (messageId: string) => {
  return `/api/v1/messages/${messageId}/reactions`;
};

export const removeReactionApiV1MessagesMessageIdReactionsDelete = async (
  messageId: string,
  reactionRequest: ReactionRequest,
  options?: RequestInit
): Promise<void> => {
  return customFetch<void>(getRemoveReactionApiV1MessagesMessageIdReactionsDeleteUrl(messageId), {
    ...options,
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(reactionRequest),
  });
};

export const getRemoveReactionApiV1MessagesMessageIdReactionsDeleteMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeReactionApiV1MessagesMessageIdReactionsDelete>>,
    TError,
    { messageId: string; data: ReactionRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeReactionApiV1MessagesMessageIdReactionsDelete>>,
  TError,
  { messageId: string; data: ReactionRequest },
  TContext
> => {
  const mutationKey = ['removeReactionApiV1MessagesMessageIdReactionsDelete'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeReactionApiV1MessagesMessageIdReactionsDelete>>,
    { messageId: string; data: ReactionRequest }
  > = (props) => {
    const { messageId, data } = props ?? {};

    return removeReactionApiV1MessagesMessageIdReactionsDelete(messageId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveReactionApiV1MessagesMessageIdReactionsDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeReactionApiV1MessagesMessageIdReactionsDelete>>
>;
export type RemoveReactionApiV1MessagesMessageIdReactionsDeleteMutationBody = ReactionRequest;
export type RemoveReactionApiV1MessagesMessageIdReactionsDeleteMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Remove Reaction
 */
export const useRemoveReactionApiV1MessagesMessageIdReactionsDelete = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeReactionApiV1MessagesMessageIdReactionsDelete>>,
      TError,
      { messageId: string; data: ReactionRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof removeReactionApiV1MessagesMessageIdReactionsDelete>>,
  TError,
  { messageId: string; data: ReactionRequest },
  TContext
> => {
  return useMutation(
    getRemoveReactionApiV1MessagesMessageIdReactionsDeleteMutationOptions(options),
    queryClient
  );
};
/**
 * Add an emoji reaction to a message.

Requires SEND_MESSAGES permission.
Rate limited to 10 per minute.
 * @summary Add Reaction
 */
export const getAddReactionApiV1MessagesMessageIdReactionsPostUrl = (messageId: string) => {
  return `/api/v1/messages/${messageId}/reactions`;
};

export const addReactionApiV1MessagesMessageIdReactionsPost = async (
  messageId: string,
  reactionRequest: ReactionRequest,
  options?: RequestInit
): Promise<void> => {
  return customFetch<void>(getAddReactionApiV1MessagesMessageIdReactionsPostUrl(messageId), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(reactionRequest),
  });
};

export const getAddReactionApiV1MessagesMessageIdReactionsPostMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addReactionApiV1MessagesMessageIdReactionsPost>>,
    TError,
    { messageId: string; data: ReactionRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addReactionApiV1MessagesMessageIdReactionsPost>>,
  TError,
  { messageId: string; data: ReactionRequest },
  TContext
> => {
  const mutationKey = ['addReactionApiV1MessagesMessageIdReactionsPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addReactionApiV1MessagesMessageIdReactionsPost>>,
    { messageId: string; data: ReactionRequest }
  > = (props) => {
    const { messageId, data } = props ?? {};

    return addReactionApiV1MessagesMessageIdReactionsPost(messageId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddReactionApiV1MessagesMessageIdReactionsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof addReactionApiV1MessagesMessageIdReactionsPost>>
>;
export type AddReactionApiV1MessagesMessageIdReactionsPostMutationBody = ReactionRequest;
export type AddReactionApiV1MessagesMessageIdReactionsPostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Add Reaction
 */
export const useAddReactionApiV1MessagesMessageIdReactionsPost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addReactionApiV1MessagesMessageIdReactionsPost>>,
      TError,
      { messageId: string; data: ReactionRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof addReactionApiV1MessagesMessageIdReactionsPost>>,
  TError,
  { messageId: string; data: ReactionRequest },
  TContext
> => {
  return useMutation(
    getAddReactionApiV1MessagesMessageIdReactionsPostMutationOptions(options),
    queryClient
  );
};
