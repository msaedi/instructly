/**
 * Generated by orval v7.16.1 ðŸº
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  DeleteMessageResponse,
  EditMessageRequest,
  GetMessageHistoryApiV1MessagesHistoryBookingIdGetParams,
  HTTPValidationError,
  MarkMessagesReadRequest,
  MarkMessagesReadResponse,
  MessageConfigResponse,
  MessagesHistoryResponse,
  ReactionRequest,
  SendMessageRequest,
  SendMessageResponse,
  StreamMessagesApiV1MessagesStreamBookingIdGetParams,
  TypingStatusResponse,
  UnreadCountResponse
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';




/**
 * Get public configuration values for the messaging UI.

Returns:
    MessageConfigResponse with edit_window_minutes and other config values.
 * @summary Get Message Config
 */
export const getMessageConfigApiV1MessagesConfigGet = (

 signal?: AbortSignal
) => {


      return customFetch<MessageConfigResponse>(
      {url: `/api/v1/messages/config`, method: 'GET', signal
    },
      );
    }




export const getGetMessageConfigApiV1MessagesConfigGetQueryKey = () => {
    return [
    `/api/v1/messages/config`
    ] as const;
    }


export const getGetMessageConfigApiV1MessagesConfigGetQueryOptions = <TData = Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMessageConfigApiV1MessagesConfigGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>> = ({ signal }) => getMessageConfigApiV1MessagesConfigGet(signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMessageConfigApiV1MessagesConfigGetQueryResult = NonNullable<Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>>
export type GetMessageConfigApiV1MessagesConfigGetQueryError = ErrorType<unknown>


export function useGetMessageConfigApiV1MessagesConfigGet<TData = Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
          TError,
          Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMessageConfigApiV1MessagesConfigGet<TData = Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>,
          TError,
          Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMessageConfigApiV1MessagesConfigGet<TData = Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Message Config
 */

export function useGetMessageConfigApiV1MessagesConfigGet<TData = Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageConfigApiV1MessagesConfigGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMessageConfigApiV1MessagesConfigGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get message history for a booking.

Returns paginated list of messages in chronological order.
Requires VIEW_MESSAGES permission.
 * @summary Get Message History
 */
export const getMessageHistoryApiV1MessagesHistoryBookingIdGet = (
    bookingId: string,
    params?: GetMessageHistoryApiV1MessagesHistoryBookingIdGetParams,
 signal?: AbortSignal
) => {


      return customFetch<MessagesHistoryResponse>(
      {url: `/api/v1/messages/history/${bookingId}`, method: 'GET',
        params, signal
    },
      );
    }




export const getGetMessageHistoryApiV1MessagesHistoryBookingIdGetQueryKey = (bookingId?: string,
    params?: GetMessageHistoryApiV1MessagesHistoryBookingIdGetParams,) => {
    return [
    `/api/v1/messages/history/${bookingId}`, ...(params ? [params]: [])
    ] as const;
    }


export const getGetMessageHistoryApiV1MessagesHistoryBookingIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getMessageHistoryApiV1MessagesHistoryBookingIdGet>>, TError = ErrorType<void | HTTPValidationError>>(bookingId: string,
    params?: GetMessageHistoryApiV1MessagesHistoryBookingIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageHistoryApiV1MessagesHistoryBookingIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMessageHistoryApiV1MessagesHistoryBookingIdGetQueryKey(bookingId,params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMessageHistoryApiV1MessagesHistoryBookingIdGet>>> = ({ signal }) => getMessageHistoryApiV1MessagesHistoryBookingIdGet(bookingId,params, signal);





   return  { queryKey, queryFn, enabled: !!(bookingId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMessageHistoryApiV1MessagesHistoryBookingIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMessageHistoryApiV1MessagesHistoryBookingIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getMessageHistoryApiV1MessagesHistoryBookingIdGet>>>
export type GetMessageHistoryApiV1MessagesHistoryBookingIdGetQueryError = ErrorType<void | HTTPValidationError>


export function useGetMessageHistoryApiV1MessagesHistoryBookingIdGet<TData = Awaited<ReturnType<typeof getMessageHistoryApiV1MessagesHistoryBookingIdGet>>, TError = ErrorType<void | HTTPValidationError>>(
 bookingId: string,
    params: undefined |  GetMessageHistoryApiV1MessagesHistoryBookingIdGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageHistoryApiV1MessagesHistoryBookingIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMessageHistoryApiV1MessagesHistoryBookingIdGet>>,
          TError,
          Awaited<ReturnType<typeof getMessageHistoryApiV1MessagesHistoryBookingIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMessageHistoryApiV1MessagesHistoryBookingIdGet<TData = Awaited<ReturnType<typeof getMessageHistoryApiV1MessagesHistoryBookingIdGet>>, TError = ErrorType<void | HTTPValidationError>>(
 bookingId: string,
    params?: GetMessageHistoryApiV1MessagesHistoryBookingIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageHistoryApiV1MessagesHistoryBookingIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMessageHistoryApiV1MessagesHistoryBookingIdGet>>,
          TError,
          Awaited<ReturnType<typeof getMessageHistoryApiV1MessagesHistoryBookingIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMessageHistoryApiV1MessagesHistoryBookingIdGet<TData = Awaited<ReturnType<typeof getMessageHistoryApiV1MessagesHistoryBookingIdGet>>, TError = ErrorType<void | HTTPValidationError>>(
 bookingId: string,
    params?: GetMessageHistoryApiV1MessagesHistoryBookingIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageHistoryApiV1MessagesHistoryBookingIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Message History
 */

export function useGetMessageHistoryApiV1MessagesHistoryBookingIdGet<TData = Awaited<ReturnType<typeof getMessageHistoryApiV1MessagesHistoryBookingIdGet>>, TError = ErrorType<void | HTTPValidationError>>(
 bookingId: string,
    params?: GetMessageHistoryApiV1MessagesHistoryBookingIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageHistoryApiV1MessagesHistoryBookingIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMessageHistoryApiV1MessagesHistoryBookingIdGetQueryOptions(bookingId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Mark messages as read.

Can mark specific messages or all messages in a booking.
Requires VIEW_MESSAGES permission.
 * @summary Mark Messages As Read
 */
export const markMessagesAsReadApiV1MessagesMarkReadPost = (
    markMessagesReadRequest: MarkMessagesReadRequest,
 signal?: AbortSignal
) => {


      return customFetch<MarkMessagesReadResponse>(
      {url: `/api/v1/messages/mark-read`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: markMessagesReadRequest, signal
    },
      );
    }



export const getMarkMessagesAsReadApiV1MessagesMarkReadPostMutationOptions = <TError = ErrorType<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof markMessagesAsReadApiV1MessagesMarkReadPost>>, TError,{data: MarkMessagesReadRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof markMessagesAsReadApiV1MessagesMarkReadPost>>, TError,{data: MarkMessagesReadRequest}, TContext> => {

const mutationKey = ['markMessagesAsReadApiV1MessagesMarkReadPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof markMessagesAsReadApiV1MessagesMarkReadPost>>, {data: MarkMessagesReadRequest}> = (props) => {
          const {data} = props ?? {};

          return  markMessagesAsReadApiV1MessagesMarkReadPost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type MarkMessagesAsReadApiV1MessagesMarkReadPostMutationResult = NonNullable<Awaited<ReturnType<typeof markMessagesAsReadApiV1MessagesMarkReadPost>>>
    export type MarkMessagesAsReadApiV1MessagesMarkReadPostMutationBody = MarkMessagesReadRequest
    export type MarkMessagesAsReadApiV1MessagesMarkReadPostMutationError = ErrorType<void | HTTPValidationError>

    /**
 * @summary Mark Messages As Read
 */
export const useMarkMessagesAsReadApiV1MessagesMarkReadPost = <TError = ErrorType<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof markMessagesAsReadApiV1MessagesMarkReadPost>>, TError,{data: MarkMessagesReadRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof markMessagesAsReadApiV1MessagesMarkReadPost>>,
        TError,
        {data: MarkMessagesReadRequest},
        TContext
      > => {

      const mutationOptions = getMarkMessagesAsReadApiV1MessagesMarkReadPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Send a message in a booking chat.

Requires SEND_MESSAGES permission.
Rate limited to 10 messages per minute.
 * @summary Send Message
 */
export const sendMessageApiV1MessagesSendPost = (
    sendMessageRequest: SendMessageRequest,
 signal?: AbortSignal
) => {


      return customFetch<SendMessageResponse>(
      {url: `/api/v1/messages/send`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sendMessageRequest, signal
    },
      );
    }



export const getSendMessageApiV1MessagesSendPostMutationOptions = <TError = ErrorType<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendMessageApiV1MessagesSendPost>>, TError,{data: SendMessageRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sendMessageApiV1MessagesSendPost>>, TError,{data: SendMessageRequest}, TContext> => {

const mutationKey = ['sendMessageApiV1MessagesSendPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendMessageApiV1MessagesSendPost>>, {data: SendMessageRequest}> = (props) => {
          const {data} = props ?? {};

          return  sendMessageApiV1MessagesSendPost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type SendMessageApiV1MessagesSendPostMutationResult = NonNullable<Awaited<ReturnType<typeof sendMessageApiV1MessagesSendPost>>>
    export type SendMessageApiV1MessagesSendPostMutationBody = SendMessageRequest
    export type SendMessageApiV1MessagesSendPostMutationError = ErrorType<void | HTTPValidationError>

    /**
 * @summary Send Message
 */
export const useSendMessageApiV1MessagesSendPost = <TError = ErrorType<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendMessageApiV1MessagesSendPost>>, TError,{data: SendMessageRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sendMessageApiV1MessagesSendPost>>,
        TError,
        {data: SendMessageRequest},
        TContext
      > => {

      const mutationOptions = getSendMessageApiV1MessagesSendPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * SSE endpoint for real-time message streaming.

Establishes a Server-Sent Events connection for receiving
real-time messages for a specific booking.

Requires VIEW_MESSAGES permission.
Note: Permission check is done manually since SSE endpoints
can't use regular FastAPI dependencies with EventSource.
 * @summary Stream Messages
 */
export const streamMessagesApiV1MessagesStreamBookingIdGet = (
    bookingId: string,
    params?: StreamMessagesApiV1MessagesStreamBookingIdGetParams,
 signal?: AbortSignal
) => {


      return customFetch<unknown>(
      {url: `/api/v1/messages/stream/${bookingId}`, method: 'GET',
        params, signal
    },
      );
    }




export const getStreamMessagesApiV1MessagesStreamBookingIdGetQueryKey = (bookingId?: string,
    params?: StreamMessagesApiV1MessagesStreamBookingIdGetParams,) => {
    return [
    `/api/v1/messages/stream/${bookingId}`, ...(params ? [params]: [])
    ] as const;
    }


export const getStreamMessagesApiV1MessagesStreamBookingIdGetQueryOptions = <TData = Awaited<ReturnType<typeof streamMessagesApiV1MessagesStreamBookingIdGet>>, TError = ErrorType<void | HTTPValidationError>>(bookingId: string,
    params?: StreamMessagesApiV1MessagesStreamBookingIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamMessagesApiV1MessagesStreamBookingIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStreamMessagesApiV1MessagesStreamBookingIdGetQueryKey(bookingId,params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof streamMessagesApiV1MessagesStreamBookingIdGet>>> = ({ signal }) => streamMessagesApiV1MessagesStreamBookingIdGet(bookingId,params, signal);





   return  { queryKey, queryFn, enabled: !!(bookingId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof streamMessagesApiV1MessagesStreamBookingIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StreamMessagesApiV1MessagesStreamBookingIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof streamMessagesApiV1MessagesStreamBookingIdGet>>>
export type StreamMessagesApiV1MessagesStreamBookingIdGetQueryError = ErrorType<void | HTTPValidationError>


export function useStreamMessagesApiV1MessagesStreamBookingIdGet<TData = Awaited<ReturnType<typeof streamMessagesApiV1MessagesStreamBookingIdGet>>, TError = ErrorType<void | HTTPValidationError>>(
 bookingId: string,
    params: undefined |  StreamMessagesApiV1MessagesStreamBookingIdGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamMessagesApiV1MessagesStreamBookingIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamMessagesApiV1MessagesStreamBookingIdGet>>,
          TError,
          Awaited<ReturnType<typeof streamMessagesApiV1MessagesStreamBookingIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamMessagesApiV1MessagesStreamBookingIdGet<TData = Awaited<ReturnType<typeof streamMessagesApiV1MessagesStreamBookingIdGet>>, TError = ErrorType<void | HTTPValidationError>>(
 bookingId: string,
    params?: StreamMessagesApiV1MessagesStreamBookingIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamMessagesApiV1MessagesStreamBookingIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamMessagesApiV1MessagesStreamBookingIdGet>>,
          TError,
          Awaited<ReturnType<typeof streamMessagesApiV1MessagesStreamBookingIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamMessagesApiV1MessagesStreamBookingIdGet<TData = Awaited<ReturnType<typeof streamMessagesApiV1MessagesStreamBookingIdGet>>, TError = ErrorType<void | HTTPValidationError>>(
 bookingId: string,
    params?: StreamMessagesApiV1MessagesStreamBookingIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamMessagesApiV1MessagesStreamBookingIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Stream Messages
 */

export function useStreamMessagesApiV1MessagesStreamBookingIdGet<TData = Awaited<ReturnType<typeof streamMessagesApiV1MessagesStreamBookingIdGet>>, TError = ErrorType<void | HTTPValidationError>>(
 bookingId: string,
    params?: StreamMessagesApiV1MessagesStreamBookingIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamMessagesApiV1MessagesStreamBookingIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStreamMessagesApiV1MessagesStreamBookingIdGetQueryOptions(bookingId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Send a typing indicator for a booking chat (ephemeral, no DB writes).

Broadcasts a NOTIFY with type=typing_status.
Rate limited to 1 per second.
 * @summary Send Typing Indicator
 */
export const sendTypingIndicatorApiV1MessagesTypingBookingIdPost = (
    bookingId: string,
 signal?: AbortSignal
) => {


      return customFetch<TypingStatusResponse>(
      {url: `/api/v1/messages/typing/${bookingId}`, method: 'POST', signal
    },
      );
    }



export const getSendTypingIndicatorApiV1MessagesTypingBookingIdPostMutationOptions = <TError = ErrorType<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendTypingIndicatorApiV1MessagesTypingBookingIdPost>>, TError,{bookingId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sendTypingIndicatorApiV1MessagesTypingBookingIdPost>>, TError,{bookingId: string}, TContext> => {

const mutationKey = ['sendTypingIndicatorApiV1MessagesTypingBookingIdPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendTypingIndicatorApiV1MessagesTypingBookingIdPost>>, {bookingId: string}> = (props) => {
          const {bookingId} = props ?? {};

          return  sendTypingIndicatorApiV1MessagesTypingBookingIdPost(bookingId,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type SendTypingIndicatorApiV1MessagesTypingBookingIdPostMutationResult = NonNullable<Awaited<ReturnType<typeof sendTypingIndicatorApiV1MessagesTypingBookingIdPost>>>

    export type SendTypingIndicatorApiV1MessagesTypingBookingIdPostMutationError = ErrorType<void | HTTPValidationError>

    /**
 * @summary Send Typing Indicator
 */
export const useSendTypingIndicatorApiV1MessagesTypingBookingIdPost = <TError = ErrorType<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendTypingIndicatorApiV1MessagesTypingBookingIdPost>>, TError,{bookingId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sendTypingIndicatorApiV1MessagesTypingBookingIdPost>>,
        TError,
        {bookingId: string},
        TContext
      > => {

      const mutationOptions = getSendTypingIndicatorApiV1MessagesTypingBookingIdPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get total unread message count for current user.

Requires VIEW_MESSAGES permission.
 * @summary Get Unread Count
 */
export const getUnreadCountApiV1MessagesUnreadCountGet = (

 signal?: AbortSignal
) => {


      return customFetch<UnreadCountResponse>(
      {url: `/api/v1/messages/unread-count`, method: 'GET', signal
    },
      );
    }




export const getGetUnreadCountApiV1MessagesUnreadCountGetQueryKey = () => {
    return [
    `/api/v1/messages/unread-count`
    ] as const;
    }


export const getGetUnreadCountApiV1MessagesUnreadCountGetQueryOptions = <TData = Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>, TError = ErrorType<void>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUnreadCountApiV1MessagesUnreadCountGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>> = ({ signal }) => getUnreadCountApiV1MessagesUnreadCountGet(signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUnreadCountApiV1MessagesUnreadCountGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>>
export type GetUnreadCountApiV1MessagesUnreadCountGetQueryError = ErrorType<void>


export function useGetUnreadCountApiV1MessagesUnreadCountGet<TData = Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>, TError = ErrorType<void>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
          TError,
          Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUnreadCountApiV1MessagesUnreadCountGet<TData = Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>,
          TError,
          Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUnreadCountApiV1MessagesUnreadCountGet<TData = Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Unread Count
 */

export function useGetUnreadCountApiV1MessagesUnreadCountGet<TData = Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>, TError = ErrorType<void>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCountApiV1MessagesUnreadCountGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUnreadCountApiV1MessagesUnreadCountGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Soft delete a message.

Only the sender can delete their own messages.
Requires SEND_MESSAGES permission.
 * @summary Delete Message
 */
export const deleteMessageApiV1MessagesMessageIdDelete = (
    messageId: string,
 ) => {


      return customFetch<DeleteMessageResponse>(
      {url: `/api/v1/messages/${messageId}`, method: 'DELETE'
    },
      );
    }



export const getDeleteMessageApiV1MessagesMessageIdDeleteMutationOptions = <TError = ErrorType<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMessageApiV1MessagesMessageIdDelete>>, TError,{messageId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteMessageApiV1MessagesMessageIdDelete>>, TError,{messageId: string}, TContext> => {

const mutationKey = ['deleteMessageApiV1MessagesMessageIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMessageApiV1MessagesMessageIdDelete>>, {messageId: string}> = (props) => {
          const {messageId} = props ?? {};

          return  deleteMessageApiV1MessagesMessageIdDelete(messageId,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type DeleteMessageApiV1MessagesMessageIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMessageApiV1MessagesMessageIdDelete>>>

    export type DeleteMessageApiV1MessagesMessageIdDeleteMutationError = ErrorType<void | HTTPValidationError>

    /**
 * @summary Delete Message
 */
export const useDeleteMessageApiV1MessagesMessageIdDelete = <TError = ErrorType<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMessageApiV1MessagesMessageIdDelete>>, TError,{messageId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteMessageApiV1MessagesMessageIdDelete>>,
        TError,
        {messageId: string},
        TContext
      > => {

      const mutationOptions = getDeleteMessageApiV1MessagesMessageIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Edit a message.

Only the sender can edit their own messages within the edit window.
Requires SEND_MESSAGES permission.
 * @summary Edit Message
 */
export const editMessageApiV1MessagesMessageIdPatch = (
    messageId: string,
    editMessageRequest: EditMessageRequest,
 ) => {


      return customFetch<void>(
      {url: `/api/v1/messages/${messageId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: editMessageRequest
    },
      );
    }



export const getEditMessageApiV1MessagesMessageIdPatchMutationOptions = <TError = ErrorType<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof editMessageApiV1MessagesMessageIdPatch>>, TError,{messageId: string;data: EditMessageRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof editMessageApiV1MessagesMessageIdPatch>>, TError,{messageId: string;data: EditMessageRequest}, TContext> => {

const mutationKey = ['editMessageApiV1MessagesMessageIdPatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof editMessageApiV1MessagesMessageIdPatch>>, {messageId: string;data: EditMessageRequest}> = (props) => {
          const {messageId,data} = props ?? {};

          return  editMessageApiV1MessagesMessageIdPatch(messageId,data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type EditMessageApiV1MessagesMessageIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof editMessageApiV1MessagesMessageIdPatch>>>
    export type EditMessageApiV1MessagesMessageIdPatchMutationBody = EditMessageRequest
    export type EditMessageApiV1MessagesMessageIdPatchMutationError = ErrorType<void | HTTPValidationError>

    /**
 * @summary Edit Message
 */
export const useEditMessageApiV1MessagesMessageIdPatch = <TError = ErrorType<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof editMessageApiV1MessagesMessageIdPatch>>, TError,{messageId: string;data: EditMessageRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof editMessageApiV1MessagesMessageIdPatch>>,
        TError,
        {messageId: string;data: EditMessageRequest},
        TContext
      > => {

      const mutationOptions = getEditMessageApiV1MessagesMessageIdPatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Remove an emoji reaction from a message.

Requires SEND_MESSAGES permission.
Rate limited to 10 per minute.
 * @summary Remove Reaction
 */
export const removeReactionApiV1MessagesMessageIdReactionsDelete = (
    messageId: string,
    reactionRequest: ReactionRequest,
 ) => {


      return customFetch<void>(
      {url: `/api/v1/messages/${messageId}/reactions`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: reactionRequest
    },
      );
    }



export const getRemoveReactionApiV1MessagesMessageIdReactionsDeleteMutationOptions = <TError = ErrorType<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeReactionApiV1MessagesMessageIdReactionsDelete>>, TError,{messageId: string;data: ReactionRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof removeReactionApiV1MessagesMessageIdReactionsDelete>>, TError,{messageId: string;data: ReactionRequest}, TContext> => {

const mutationKey = ['removeReactionApiV1MessagesMessageIdReactionsDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeReactionApiV1MessagesMessageIdReactionsDelete>>, {messageId: string;data: ReactionRequest}> = (props) => {
          const {messageId,data} = props ?? {};

          return  removeReactionApiV1MessagesMessageIdReactionsDelete(messageId,data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type RemoveReactionApiV1MessagesMessageIdReactionsDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof removeReactionApiV1MessagesMessageIdReactionsDelete>>>
    export type RemoveReactionApiV1MessagesMessageIdReactionsDeleteMutationBody = ReactionRequest
    export type RemoveReactionApiV1MessagesMessageIdReactionsDeleteMutationError = ErrorType<void | HTTPValidationError>

    /**
 * @summary Remove Reaction
 */
export const useRemoveReactionApiV1MessagesMessageIdReactionsDelete = <TError = ErrorType<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeReactionApiV1MessagesMessageIdReactionsDelete>>, TError,{messageId: string;data: ReactionRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeReactionApiV1MessagesMessageIdReactionsDelete>>,
        TError,
        {messageId: string;data: ReactionRequest},
        TContext
      > => {

      const mutationOptions = getRemoveReactionApiV1MessagesMessageIdReactionsDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Add an emoji reaction to a message.

Requires SEND_MESSAGES permission.
Rate limited to 10 per minute.
 * @summary Add Reaction
 */
export const addReactionApiV1MessagesMessageIdReactionsPost = (
    messageId: string,
    reactionRequest: ReactionRequest,
 signal?: AbortSignal
) => {


      return customFetch<void>(
      {url: `/api/v1/messages/${messageId}/reactions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: reactionRequest, signal
    },
      );
    }



export const getAddReactionApiV1MessagesMessageIdReactionsPostMutationOptions = <TError = ErrorType<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addReactionApiV1MessagesMessageIdReactionsPost>>, TError,{messageId: string;data: ReactionRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof addReactionApiV1MessagesMessageIdReactionsPost>>, TError,{messageId: string;data: ReactionRequest}, TContext> => {

const mutationKey = ['addReactionApiV1MessagesMessageIdReactionsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addReactionApiV1MessagesMessageIdReactionsPost>>, {messageId: string;data: ReactionRequest}> = (props) => {
          const {messageId,data} = props ?? {};

          return  addReactionApiV1MessagesMessageIdReactionsPost(messageId,data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type AddReactionApiV1MessagesMessageIdReactionsPostMutationResult = NonNullable<Awaited<ReturnType<typeof addReactionApiV1MessagesMessageIdReactionsPost>>>
    export type AddReactionApiV1MessagesMessageIdReactionsPostMutationBody = ReactionRequest
    export type AddReactionApiV1MessagesMessageIdReactionsPostMutationError = ErrorType<void | HTTPValidationError>

    /**
 * @summary Add Reaction
 */
export const useAddReactionApiV1MessagesMessageIdReactionsPost = <TError = ErrorType<void | HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addReactionApiV1MessagesMessageIdReactionsPost>>, TError,{messageId: string;data: ReactionRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addReactionApiV1MessagesMessageIdReactionsPost>>,
        TError,
        {messageId: string;data: ReactionRequest},
        TContext
      > => {

      const mutationOptions = getAddReactionApiV1MessagesMessageIdReactionsPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
