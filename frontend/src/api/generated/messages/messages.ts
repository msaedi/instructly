/**
 * Generated by orval v7.16.1 ðŸº
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  DeleteMessageResponse,
  EditMessageRequest,
  GetMessageHistoryApiMessagesHistoryBookingIdGetParams,
  HTTPValidationError,
  MarkMessagesReadRequest,
  MarkMessagesReadResponse,
  MessageConfigResponse,
  MessagesHistoryResponse,
  ReactionRequest,
  SendMessageRequest,
  SendMessageResponse,
  StreamMessagesApiMessagesStreamBookingIdGetParams,
  TypingStatusResponse,
  UnreadCountResponse
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';




/**
 * Public config values for the messaging UI.
 * @summary Get Message Config
 */
export const getMessageConfigApiMessagesConfigGet = (

 signal?: AbortSignal
) => {


      return customFetch<MessageConfigResponse>(
      {url: `/api/messages/config`, method: 'GET', signal
    },
      );
    }




export const getGetMessageConfigApiMessagesConfigGetQueryKey = () => {
    return [
    `/api/messages/config`
    ] as const;
    }


export const getGetMessageConfigApiMessagesConfigGetQueryOptions = <TData = Awaited<ReturnType<typeof getMessageConfigApiMessagesConfigGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageConfigApiMessagesConfigGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMessageConfigApiMessagesConfigGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMessageConfigApiMessagesConfigGet>>> = ({ signal }) => getMessageConfigApiMessagesConfigGet(signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMessageConfigApiMessagesConfigGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMessageConfigApiMessagesConfigGetQueryResult = NonNullable<Awaited<ReturnType<typeof getMessageConfigApiMessagesConfigGet>>>
export type GetMessageConfigApiMessagesConfigGetQueryError = ErrorType<unknown>


export function useGetMessageConfigApiMessagesConfigGet<TData = Awaited<ReturnType<typeof getMessageConfigApiMessagesConfigGet>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageConfigApiMessagesConfigGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMessageConfigApiMessagesConfigGet>>,
          TError,
          Awaited<ReturnType<typeof getMessageConfigApiMessagesConfigGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMessageConfigApiMessagesConfigGet<TData = Awaited<ReturnType<typeof getMessageConfigApiMessagesConfigGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageConfigApiMessagesConfigGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMessageConfigApiMessagesConfigGet>>,
          TError,
          Awaited<ReturnType<typeof getMessageConfigApiMessagesConfigGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMessageConfigApiMessagesConfigGet<TData = Awaited<ReturnType<typeof getMessageConfigApiMessagesConfigGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageConfigApiMessagesConfigGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Message Config
 */

export function useGetMessageConfigApiMessagesConfigGet<TData = Awaited<ReturnType<typeof getMessageConfigApiMessagesConfigGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageConfigApiMessagesConfigGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMessageConfigApiMessagesConfigGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get message history for a booking.

Returns paginated list of messages in chronological order.
Requires VIEW_MESSAGES permission.
 * @summary Get Message History
 */
export const getMessageHistoryApiMessagesHistoryBookingIdGet = (
    bookingId: string,
    params?: GetMessageHistoryApiMessagesHistoryBookingIdGetParams,
 signal?: AbortSignal
) => {


      return customFetch<MessagesHistoryResponse>(
      {url: `/api/messages/history/${bookingId}`, method: 'GET',
        params, signal
    },
      );
    }




export const getGetMessageHistoryApiMessagesHistoryBookingIdGetQueryKey = (bookingId?: string,
    params?: GetMessageHistoryApiMessagesHistoryBookingIdGetParams,) => {
    return [
    `/api/messages/history/${bookingId}`, ...(params ? [params]: [])
    ] as const;
    }


export const getGetMessageHistoryApiMessagesHistoryBookingIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getMessageHistoryApiMessagesHistoryBookingIdGet>>, TError = ErrorType<HTTPValidationError>>(bookingId: string,
    params?: GetMessageHistoryApiMessagesHistoryBookingIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageHistoryApiMessagesHistoryBookingIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMessageHistoryApiMessagesHistoryBookingIdGetQueryKey(bookingId,params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMessageHistoryApiMessagesHistoryBookingIdGet>>> = ({ signal }) => getMessageHistoryApiMessagesHistoryBookingIdGet(bookingId,params, signal);





   return  { queryKey, queryFn, enabled: !!(bookingId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMessageHistoryApiMessagesHistoryBookingIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetMessageHistoryApiMessagesHistoryBookingIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getMessageHistoryApiMessagesHistoryBookingIdGet>>>
export type GetMessageHistoryApiMessagesHistoryBookingIdGetQueryError = ErrorType<HTTPValidationError>


export function useGetMessageHistoryApiMessagesHistoryBookingIdGet<TData = Awaited<ReturnType<typeof getMessageHistoryApiMessagesHistoryBookingIdGet>>, TError = ErrorType<HTTPValidationError>>(
 bookingId: string,
    params: undefined |  GetMessageHistoryApiMessagesHistoryBookingIdGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageHistoryApiMessagesHistoryBookingIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMessageHistoryApiMessagesHistoryBookingIdGet>>,
          TError,
          Awaited<ReturnType<typeof getMessageHistoryApiMessagesHistoryBookingIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMessageHistoryApiMessagesHistoryBookingIdGet<TData = Awaited<ReturnType<typeof getMessageHistoryApiMessagesHistoryBookingIdGet>>, TError = ErrorType<HTTPValidationError>>(
 bookingId: string,
    params?: GetMessageHistoryApiMessagesHistoryBookingIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageHistoryApiMessagesHistoryBookingIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMessageHistoryApiMessagesHistoryBookingIdGet>>,
          TError,
          Awaited<ReturnType<typeof getMessageHistoryApiMessagesHistoryBookingIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetMessageHistoryApiMessagesHistoryBookingIdGet<TData = Awaited<ReturnType<typeof getMessageHistoryApiMessagesHistoryBookingIdGet>>, TError = ErrorType<HTTPValidationError>>(
 bookingId: string,
    params?: GetMessageHistoryApiMessagesHistoryBookingIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageHistoryApiMessagesHistoryBookingIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Message History
 */

export function useGetMessageHistoryApiMessagesHistoryBookingIdGet<TData = Awaited<ReturnType<typeof getMessageHistoryApiMessagesHistoryBookingIdGet>>, TError = ErrorType<HTTPValidationError>>(
 bookingId: string,
    params?: GetMessageHistoryApiMessagesHistoryBookingIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getMessageHistoryApiMessagesHistoryBookingIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetMessageHistoryApiMessagesHistoryBookingIdGetQueryOptions(bookingId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Mark messages as read.

Can mark specific messages or all messages in a booking.
Requires VIEW_MESSAGES permission.
 * @summary Mark Messages As Read
 */
export const markMessagesAsReadApiMessagesMarkReadPost = (
    markMessagesReadRequest: MarkMessagesReadRequest,
 signal?: AbortSignal
) => {


      return customFetch<MarkMessagesReadResponse>(
      {url: `/api/messages/mark-read`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: markMessagesReadRequest, signal
    },
      );
    }



export const getMarkMessagesAsReadApiMessagesMarkReadPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof markMessagesAsReadApiMessagesMarkReadPost>>, TError,{data: MarkMessagesReadRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof markMessagesAsReadApiMessagesMarkReadPost>>, TError,{data: MarkMessagesReadRequest}, TContext> => {

const mutationKey = ['markMessagesAsReadApiMessagesMarkReadPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof markMessagesAsReadApiMessagesMarkReadPost>>, {data: MarkMessagesReadRequest}> = (props) => {
          const {data} = props ?? {};

          return  markMessagesAsReadApiMessagesMarkReadPost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type MarkMessagesAsReadApiMessagesMarkReadPostMutationResult = NonNullable<Awaited<ReturnType<typeof markMessagesAsReadApiMessagesMarkReadPost>>>
    export type MarkMessagesAsReadApiMessagesMarkReadPostMutationBody = MarkMessagesReadRequest
    export type MarkMessagesAsReadApiMessagesMarkReadPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Mark Messages As Read
 */
export const useMarkMessagesAsReadApiMessagesMarkReadPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof markMessagesAsReadApiMessagesMarkReadPost>>, TError,{data: MarkMessagesReadRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof markMessagesAsReadApiMessagesMarkReadPost>>,
        TError,
        {data: MarkMessagesReadRequest},
        TContext
      > => {

      const mutationOptions = getMarkMessagesAsReadApiMessagesMarkReadPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Send a message in a booking chat.

Requires SEND_MESSAGES permission.
Rate limited to 10 messages per minute.
 * @summary Send Message
 */
export const sendMessageApiMessagesSendPost = (
    sendMessageRequest: SendMessageRequest,
 signal?: AbortSignal
) => {


      return customFetch<SendMessageResponse>(
      {url: `/api/messages/send`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: sendMessageRequest, signal
    },
      );
    }



export const getSendMessageApiMessagesSendPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendMessageApiMessagesSendPost>>, TError,{data: SendMessageRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sendMessageApiMessagesSendPost>>, TError,{data: SendMessageRequest}, TContext> => {

const mutationKey = ['sendMessageApiMessagesSendPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendMessageApiMessagesSendPost>>, {data: SendMessageRequest}> = (props) => {
          const {data} = props ?? {};

          return  sendMessageApiMessagesSendPost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type SendMessageApiMessagesSendPostMutationResult = NonNullable<Awaited<ReturnType<typeof sendMessageApiMessagesSendPost>>>
    export type SendMessageApiMessagesSendPostMutationBody = SendMessageRequest
    export type SendMessageApiMessagesSendPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Send Message
 */
export const useSendMessageApiMessagesSendPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendMessageApiMessagesSendPost>>, TError,{data: SendMessageRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sendMessageApiMessagesSendPost>>,
        TError,
        {data: SendMessageRequest},
        TContext
      > => {

      const mutationOptions = getSendMessageApiMessagesSendPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * SSE endpoint for real-time message streaming.

Establishes a Server-Sent Events connection for receiving
real-time messages for a specific booking.

Requires VIEW_MESSAGES permission.
Note: Permission check is done manually since SSE endpoints
can't use regular FastAPI dependencies with EventSource.
 * @summary Stream Messages
 */
export const streamMessagesApiMessagesStreamBookingIdGet = (
    bookingId: string,
    params?: StreamMessagesApiMessagesStreamBookingIdGetParams,
 signal?: AbortSignal
) => {


      return customFetch<unknown>(
      {url: `/api/messages/stream/${bookingId}`, method: 'GET',
        params, signal
    },
      );
    }




export const getStreamMessagesApiMessagesStreamBookingIdGetQueryKey = (bookingId?: string,
    params?: StreamMessagesApiMessagesStreamBookingIdGetParams,) => {
    return [
    `/api/messages/stream/${bookingId}`, ...(params ? [params]: [])
    ] as const;
    }


export const getStreamMessagesApiMessagesStreamBookingIdGetQueryOptions = <TData = Awaited<ReturnType<typeof streamMessagesApiMessagesStreamBookingIdGet>>, TError = ErrorType<HTTPValidationError>>(bookingId: string,
    params?: StreamMessagesApiMessagesStreamBookingIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamMessagesApiMessagesStreamBookingIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getStreamMessagesApiMessagesStreamBookingIdGetQueryKey(bookingId,params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof streamMessagesApiMessagesStreamBookingIdGet>>> = ({ signal }) => streamMessagesApiMessagesStreamBookingIdGet(bookingId,params, signal);





   return  { queryKey, queryFn, enabled: !!(bookingId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof streamMessagesApiMessagesStreamBookingIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type StreamMessagesApiMessagesStreamBookingIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof streamMessagesApiMessagesStreamBookingIdGet>>>
export type StreamMessagesApiMessagesStreamBookingIdGetQueryError = ErrorType<HTTPValidationError>


export function useStreamMessagesApiMessagesStreamBookingIdGet<TData = Awaited<ReturnType<typeof streamMessagesApiMessagesStreamBookingIdGet>>, TError = ErrorType<HTTPValidationError>>(
 bookingId: string,
    params: undefined |  StreamMessagesApiMessagesStreamBookingIdGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamMessagesApiMessagesStreamBookingIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamMessagesApiMessagesStreamBookingIdGet>>,
          TError,
          Awaited<ReturnType<typeof streamMessagesApiMessagesStreamBookingIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamMessagesApiMessagesStreamBookingIdGet<TData = Awaited<ReturnType<typeof streamMessagesApiMessagesStreamBookingIdGet>>, TError = ErrorType<HTTPValidationError>>(
 bookingId: string,
    params?: StreamMessagesApiMessagesStreamBookingIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamMessagesApiMessagesStreamBookingIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof streamMessagesApiMessagesStreamBookingIdGet>>,
          TError,
          Awaited<ReturnType<typeof streamMessagesApiMessagesStreamBookingIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useStreamMessagesApiMessagesStreamBookingIdGet<TData = Awaited<ReturnType<typeof streamMessagesApiMessagesStreamBookingIdGet>>, TError = ErrorType<HTTPValidationError>>(
 bookingId: string,
    params?: StreamMessagesApiMessagesStreamBookingIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamMessagesApiMessagesStreamBookingIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Stream Messages
 */

export function useStreamMessagesApiMessagesStreamBookingIdGet<TData = Awaited<ReturnType<typeof streamMessagesApiMessagesStreamBookingIdGet>>, TError = ErrorType<HTTPValidationError>>(
 bookingId: string,
    params?: StreamMessagesApiMessagesStreamBookingIdGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof streamMessagesApiMessagesStreamBookingIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStreamMessagesApiMessagesStreamBookingIdGetQueryOptions(bookingId,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Send a typing indicator for a booking chat (ephemeral, no DB writes).
Broadcasts a NOTIFY with type=typing_status.
 * @summary Send Typing Indicator
 */
export const sendTypingIndicatorApiMessagesTypingBookingIdPost = (
    bookingId: string,
 signal?: AbortSignal
) => {


      return customFetch<TypingStatusResponse>(
      {url: `/api/messages/typing/${bookingId}`, method: 'POST', signal
    },
      );
    }



export const getSendTypingIndicatorApiMessagesTypingBookingIdPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendTypingIndicatorApiMessagesTypingBookingIdPost>>, TError,{bookingId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sendTypingIndicatorApiMessagesTypingBookingIdPost>>, TError,{bookingId: string}, TContext> => {

const mutationKey = ['sendTypingIndicatorApiMessagesTypingBookingIdPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendTypingIndicatorApiMessagesTypingBookingIdPost>>, {bookingId: string}> = (props) => {
          const {bookingId} = props ?? {};

          return  sendTypingIndicatorApiMessagesTypingBookingIdPost(bookingId,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type SendTypingIndicatorApiMessagesTypingBookingIdPostMutationResult = NonNullable<Awaited<ReturnType<typeof sendTypingIndicatorApiMessagesTypingBookingIdPost>>>

    export type SendTypingIndicatorApiMessagesTypingBookingIdPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Send Typing Indicator
 */
export const useSendTypingIndicatorApiMessagesTypingBookingIdPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendTypingIndicatorApiMessagesTypingBookingIdPost>>, TError,{bookingId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sendTypingIndicatorApiMessagesTypingBookingIdPost>>,
        TError,
        {bookingId: string},
        TContext
      > => {

      const mutationOptions = getSendTypingIndicatorApiMessagesTypingBookingIdPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get total unread message count for current user.

Requires VIEW_MESSAGES permission.
 * @summary Get Unread Count
 */
export const getUnreadCountApiMessagesUnreadCountGet = (

 signal?: AbortSignal
) => {


      return customFetch<UnreadCountResponse>(
      {url: `/api/messages/unread-count`, method: 'GET', signal
    },
      );
    }




export const getGetUnreadCountApiMessagesUnreadCountGetQueryKey = () => {
    return [
    `/api/messages/unread-count`
    ] as const;
    }


export const getGetUnreadCountApiMessagesUnreadCountGetQueryOptions = <TData = Awaited<ReturnType<typeof getUnreadCountApiMessagesUnreadCountGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCountApiMessagesUnreadCountGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUnreadCountApiMessagesUnreadCountGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUnreadCountApiMessagesUnreadCountGet>>> = ({ signal }) => getUnreadCountApiMessagesUnreadCountGet(signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUnreadCountApiMessagesUnreadCountGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUnreadCountApiMessagesUnreadCountGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUnreadCountApiMessagesUnreadCountGet>>>
export type GetUnreadCountApiMessagesUnreadCountGetQueryError = ErrorType<unknown>


export function useGetUnreadCountApiMessagesUnreadCountGet<TData = Awaited<ReturnType<typeof getUnreadCountApiMessagesUnreadCountGet>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCountApiMessagesUnreadCountGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnreadCountApiMessagesUnreadCountGet>>,
          TError,
          Awaited<ReturnType<typeof getUnreadCountApiMessagesUnreadCountGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUnreadCountApiMessagesUnreadCountGet<TData = Awaited<ReturnType<typeof getUnreadCountApiMessagesUnreadCountGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCountApiMessagesUnreadCountGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUnreadCountApiMessagesUnreadCountGet>>,
          TError,
          Awaited<ReturnType<typeof getUnreadCountApiMessagesUnreadCountGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUnreadCountApiMessagesUnreadCountGet<TData = Awaited<ReturnType<typeof getUnreadCountApiMessagesUnreadCountGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCountApiMessagesUnreadCountGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Unread Count
 */

export function useGetUnreadCountApiMessagesUnreadCountGet<TData = Awaited<ReturnType<typeof getUnreadCountApiMessagesUnreadCountGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUnreadCountApiMessagesUnreadCountGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUnreadCountApiMessagesUnreadCountGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Soft delete a message.

Only the sender can delete their own messages.
Requires SEND_MESSAGES permission.
 * @summary Delete Message
 */
export const deleteMessageApiMessagesMessageIdDelete = (
    messageId: string,
 ) => {


      return customFetch<DeleteMessageResponse>(
      {url: `/api/messages/${messageId}`, method: 'DELETE'
    },
      );
    }



export const getDeleteMessageApiMessagesMessageIdDeleteMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMessageApiMessagesMessageIdDelete>>, TError,{messageId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteMessageApiMessagesMessageIdDelete>>, TError,{messageId: string}, TContext> => {

const mutationKey = ['deleteMessageApiMessagesMessageIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMessageApiMessagesMessageIdDelete>>, {messageId: string}> = (props) => {
          const {messageId} = props ?? {};

          return  deleteMessageApiMessagesMessageIdDelete(messageId,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type DeleteMessageApiMessagesMessageIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMessageApiMessagesMessageIdDelete>>>

    export type DeleteMessageApiMessagesMessageIdDeleteMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Delete Message
 */
export const useDeleteMessageApiMessagesMessageIdDelete = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteMessageApiMessagesMessageIdDelete>>, TError,{messageId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteMessageApiMessagesMessageIdDelete>>,
        TError,
        {messageId: string},
        TContext
      > => {

      const mutationOptions = getDeleteMessageApiMessagesMessageIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Edit Message
 */
export const editMessageApiMessagesMessageIdPatch = (
    messageId: string,
    editMessageRequest: EditMessageRequest,
 ) => {


      return customFetch<void>(
      {url: `/api/messages/${messageId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: editMessageRequest
    },
      );
    }



export const getEditMessageApiMessagesMessageIdPatchMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof editMessageApiMessagesMessageIdPatch>>, TError,{messageId: string;data: EditMessageRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof editMessageApiMessagesMessageIdPatch>>, TError,{messageId: string;data: EditMessageRequest}, TContext> => {

const mutationKey = ['editMessageApiMessagesMessageIdPatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof editMessageApiMessagesMessageIdPatch>>, {messageId: string;data: EditMessageRequest}> = (props) => {
          const {messageId,data} = props ?? {};

          return  editMessageApiMessagesMessageIdPatch(messageId,data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type EditMessageApiMessagesMessageIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof editMessageApiMessagesMessageIdPatch>>>
    export type EditMessageApiMessagesMessageIdPatchMutationBody = EditMessageRequest
    export type EditMessageApiMessagesMessageIdPatchMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Edit Message
 */
export const useEditMessageApiMessagesMessageIdPatch = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof editMessageApiMessagesMessageIdPatch>>, TError,{messageId: string;data: EditMessageRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof editMessageApiMessagesMessageIdPatch>>,
        TError,
        {messageId: string;data: EditMessageRequest},
        TContext
      > => {

      const mutationOptions = getEditMessageApiMessagesMessageIdPatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Remove Reaction
 */
export const removeReactionApiMessagesMessageIdReactionsDelete = (
    messageId: string,
    reactionRequest: ReactionRequest,
 ) => {


      return customFetch<void>(
      {url: `/api/messages/${messageId}/reactions`, method: 'DELETE',
      headers: {'Content-Type': 'application/json', },
      data: reactionRequest
    },
      );
    }



export const getRemoveReactionApiMessagesMessageIdReactionsDeleteMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeReactionApiMessagesMessageIdReactionsDelete>>, TError,{messageId: string;data: ReactionRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof removeReactionApiMessagesMessageIdReactionsDelete>>, TError,{messageId: string;data: ReactionRequest}, TContext> => {

const mutationKey = ['removeReactionApiMessagesMessageIdReactionsDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof removeReactionApiMessagesMessageIdReactionsDelete>>, {messageId: string;data: ReactionRequest}> = (props) => {
          const {messageId,data} = props ?? {};

          return  removeReactionApiMessagesMessageIdReactionsDelete(messageId,data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type RemoveReactionApiMessagesMessageIdReactionsDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof removeReactionApiMessagesMessageIdReactionsDelete>>>
    export type RemoveReactionApiMessagesMessageIdReactionsDeleteMutationBody = ReactionRequest
    export type RemoveReactionApiMessagesMessageIdReactionsDeleteMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Remove Reaction
 */
export const useRemoveReactionApiMessagesMessageIdReactionsDelete = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof removeReactionApiMessagesMessageIdReactionsDelete>>, TError,{messageId: string;data: ReactionRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof removeReactionApiMessagesMessageIdReactionsDelete>>,
        TError,
        {messageId: string;data: ReactionRequest},
        TContext
      > => {

      const mutationOptions = getRemoveReactionApiMessagesMessageIdReactionsDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Add Reaction
 */
export const addReactionApiMessagesMessageIdReactionsPost = (
    messageId: string,
    reactionRequest: ReactionRequest,
 signal?: AbortSignal
) => {


      return customFetch<void>(
      {url: `/api/messages/${messageId}/reactions`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: reactionRequest, signal
    },
      );
    }



export const getAddReactionApiMessagesMessageIdReactionsPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addReactionApiMessagesMessageIdReactionsPost>>, TError,{messageId: string;data: ReactionRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof addReactionApiMessagesMessageIdReactionsPost>>, TError,{messageId: string;data: ReactionRequest}, TContext> => {

const mutationKey = ['addReactionApiMessagesMessageIdReactionsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addReactionApiMessagesMessageIdReactionsPost>>, {messageId: string;data: ReactionRequest}> = (props) => {
          const {messageId,data} = props ?? {};

          return  addReactionApiMessagesMessageIdReactionsPost(messageId,data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type AddReactionApiMessagesMessageIdReactionsPostMutationResult = NonNullable<Awaited<ReturnType<typeof addReactionApiMessagesMessageIdReactionsPost>>>
    export type AddReactionApiMessagesMessageIdReactionsPostMutationBody = ReactionRequest
    export type AddReactionApiMessagesMessageIdReactionsPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Add Reaction
 */
export const useAddReactionApiMessagesMessageIdReactionsPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addReactionApiMessagesMessageIdReactionsPost>>, TError,{messageId: string;data: ReactionRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addReactionApiMessagesMessageIdReactionsPost>>,
        TError,
        {messageId: string;data: ReactionRequest},
        TContext
      > => {

      const mutationOptions = getAddReactionApiMessagesMessageIdReactionsPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
