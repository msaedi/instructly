/**
 * Generated by orval v8.0.2 üç∫
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  AppSchemasAvailabilityWindowBulkUpdateRequest,
  ApplyToDateRangeRequest,
  ApplyToDateRangeResponse,
  AvailabilityWindowResponse,
  AvailabilityWindowUpdate,
  BlackoutDateCreate,
  BlackoutDateResponse,
  BookedSlotsResponse,
  BulkUpdateResponse,
  CopyWeekRequest,
  CopyWeekResponse,
  DeleteBlackoutResponse,
  DeleteWindowResponse,
  GetAllAvailabilityApiV1InstructorsAvailabilityGetParams,
  GetWeekAvailabilityApiV1InstructorsAvailabilityWeekGetParams,
  GetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGetParams,
  HTTPValidationError,
  SaveWeekAvailabilityApiV1InstructorsAvailabilityWeekPostParams,
  SpecificDateAvailabilityCreate,
  ValidateWeekRequest,
  WeekAvailabilityResponse,
  WeekAvailabilityUpdateResponse,
  WeekSpecificScheduleCreate,
  WeekValidationResponse,
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Get all availability windows.

CLEAN ARCHITECTURE: Returns only meaningful fields.
No legacy patterns.
 * @summary Get All Availability
 */
export const getGetAllAvailabilityApiV1InstructorsAvailabilityGetUrl = (
  params?: GetAllAvailabilityApiV1InstructorsAvailabilityGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/instructors/availability?${stringifiedParams}`
    : `/api/v1/instructors/availability`;
};

export const getAllAvailabilityApiV1InstructorsAvailabilityGet = async (
  params?: GetAllAvailabilityApiV1InstructorsAvailabilityGetParams,
  options?: RequestInit
): Promise<AvailabilityWindowResponse[]> => {
  return customFetch<AvailabilityWindowResponse[]>(
    getGetAllAvailabilityApiV1InstructorsAvailabilityGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetAllAvailabilityApiV1InstructorsAvailabilityGetQueryKey = (
  params?: GetAllAvailabilityApiV1InstructorsAvailabilityGetParams
) => {
  return [`/api/v1/instructors/availability`, ...(params ? [params] : [])] as const;
};

export const getGetAllAvailabilityApiV1InstructorsAvailabilityGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllAvailabilityApiV1InstructorsAvailabilityGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params?: GetAllAvailabilityApiV1InstructorsAvailabilityGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllAvailabilityApiV1InstructorsAvailabilityGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAllAvailabilityApiV1InstructorsAvailabilityGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllAvailabilityApiV1InstructorsAvailabilityGet>>
  > = ({ signal }) =>
    getAllAvailabilityApiV1InstructorsAvailabilityGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAllAvailabilityApiV1InstructorsAvailabilityGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAllAvailabilityApiV1InstructorsAvailabilityGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllAvailabilityApiV1InstructorsAvailabilityGet>>
>;
export type GetAllAvailabilityApiV1InstructorsAvailabilityGetQueryError =
  ErrorType<void | HTTPValidationError>;

export function useGetAllAvailabilityApiV1InstructorsAvailabilityGet<
  TData = Awaited<ReturnType<typeof getAllAvailabilityApiV1InstructorsAvailabilityGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params: undefined | GetAllAvailabilityApiV1InstructorsAvailabilityGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllAvailabilityApiV1InstructorsAvailabilityGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllAvailabilityApiV1InstructorsAvailabilityGet>>,
          TError,
          Awaited<ReturnType<typeof getAllAvailabilityApiV1InstructorsAvailabilityGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllAvailabilityApiV1InstructorsAvailabilityGet<
  TData = Awaited<ReturnType<typeof getAllAvailabilityApiV1InstructorsAvailabilityGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params?: GetAllAvailabilityApiV1InstructorsAvailabilityGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllAvailabilityApiV1InstructorsAvailabilityGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllAvailabilityApiV1InstructorsAvailabilityGet>>,
          TError,
          Awaited<ReturnType<typeof getAllAvailabilityApiV1InstructorsAvailabilityGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAllAvailabilityApiV1InstructorsAvailabilityGet<
  TData = Awaited<ReturnType<typeof getAllAvailabilityApiV1InstructorsAvailabilityGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params?: GetAllAvailabilityApiV1InstructorsAvailabilityGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllAvailabilityApiV1InstructorsAvailabilityGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get All Availability
 */

export function useGetAllAvailabilityApiV1InstructorsAvailabilityGet<
  TData = Awaited<ReturnType<typeof getAllAvailabilityApiV1InstructorsAvailabilityGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params?: GetAllAvailabilityApiV1InstructorsAvailabilityGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAllAvailabilityApiV1InstructorsAvailabilityGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAllAvailabilityApiV1InstructorsAvailabilityGetQueryOptions(
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Apply a week's pattern to a date range.
 * @summary Apply To Date Range
 */
export const getApplyToDateRangeApiV1InstructorsAvailabilityApplyToDateRangePostUrl = () => {
  return `/api/v1/instructors/availability/apply-to-date-range`;
};

export const applyToDateRangeApiV1InstructorsAvailabilityApplyToDateRangePost = async (
  applyToDateRangeRequest: ApplyToDateRangeRequest,
  options?: RequestInit
): Promise<ApplyToDateRangeResponse> => {
  return customFetch<ApplyToDateRangeResponse>(
    getApplyToDateRangeApiV1InstructorsAvailabilityApplyToDateRangePostUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(applyToDateRangeRequest),
    }
  );
};

export const getApplyToDateRangeApiV1InstructorsAvailabilityApplyToDateRangePostMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof applyToDateRangeApiV1InstructorsAvailabilityApplyToDateRangePost>>,
    TError,
    { data: ApplyToDateRangeRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof applyToDateRangeApiV1InstructorsAvailabilityApplyToDateRangePost>>,
  TError,
  { data: ApplyToDateRangeRequest },
  TContext
> => {
  const mutationKey = ['applyToDateRangeApiV1InstructorsAvailabilityApplyToDateRangePost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof applyToDateRangeApiV1InstructorsAvailabilityApplyToDateRangePost>>,
    { data: ApplyToDateRangeRequest }
  > = (props) => {
    const { data } = props ?? {};

    return applyToDateRangeApiV1InstructorsAvailabilityApplyToDateRangePost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ApplyToDateRangeApiV1InstructorsAvailabilityApplyToDateRangePostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof applyToDateRangeApiV1InstructorsAvailabilityApplyToDateRangePost>>
  >;
export type ApplyToDateRangeApiV1InstructorsAvailabilityApplyToDateRangePostMutationBody =
  ApplyToDateRangeRequest;
export type ApplyToDateRangeApiV1InstructorsAvailabilityApplyToDateRangePostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Apply To Date Range
 */
export const useApplyToDateRangeApiV1InstructorsAvailabilityApplyToDateRangePost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof applyToDateRangeApiV1InstructorsAvailabilityApplyToDateRangePost>>,
      TError,
      { data: ApplyToDateRangeRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof applyToDateRangeApiV1InstructorsAvailabilityApplyToDateRangePost>>,
  TError,
  { data: ApplyToDateRangeRequest },
  TContext
> => {
  return useMutation(
    getApplyToDateRangeApiV1InstructorsAvailabilityApplyToDateRangePostMutationOptions(options),
    queryClient
  );
};
/**
 * Get instructor's blackout dates.
 * @summary Get Blackout Dates
 */
export const getGetBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGetUrl = () => {
  return `/api/v1/instructors/availability/blackout-dates`;
};

export const getBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet = async (
  options?: RequestInit
): Promise<BlackoutDateResponse[]> => {
  return customFetch<BlackoutDateResponse[]>(
    getGetBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGetUrl(),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGetQueryKey = () => {
  return [`/api/v1/instructors/availability/blackout-dates`] as const;
};

export const getGetBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet>>
  > = ({ signal }) =>
    getBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet>>
>;
export type GetBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGetQueryError =
  ErrorType<void>;

export function useGetBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet<
  TData = Awaited<ReturnType<typeof getBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet>>,
          TError,
          Awaited<ReturnType<typeof getBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet<
  TData = Awaited<ReturnType<typeof getBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet>>,
          TError,
          Awaited<ReturnType<typeof getBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet<
  TData = Awaited<ReturnType<typeof getBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Blackout Dates
 */

export function useGetBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet<
  TData = Awaited<ReturnType<typeof getBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions =
    getGetBlackoutDatesApiV1InstructorsAvailabilityBlackoutDatesGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Add a blackout date (vacation/unavailable).
 * @summary Add Blackout Date
 */
export const getAddBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesPostUrl = () => {
  return `/api/v1/instructors/availability/blackout-dates`;
};

export const addBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesPost = async (
  blackoutDateCreate: BlackoutDateCreate,
  options?: RequestInit
): Promise<BlackoutDateResponse> => {
  return customFetch<BlackoutDateResponse>(
    getAddBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesPostUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(blackoutDateCreate),
    }
  );
};

export const getAddBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesPostMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesPost>>,
    TError,
    { data: BlackoutDateCreate },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesPost>>,
  TError,
  { data: BlackoutDateCreate },
  TContext
> => {
  const mutationKey = ['addBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesPost>>,
    { data: BlackoutDateCreate }
  > = (props) => {
    const { data } = props ?? {};

    return addBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof addBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesPost>>
  >;
export type AddBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesPostMutationBody =
  BlackoutDateCreate;
export type AddBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesPostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Add Blackout Date
 */
export const useAddBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesPost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesPost>>,
      TError,
      { data: BlackoutDateCreate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof addBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesPost>>,
  TError,
  { data: BlackoutDateCreate },
  TContext
> => {
  return useMutation(
    getAddBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesPostMutationOptions(options),
    queryClient
  );
};
/**
 * Delete a blackout date.
 * @summary Delete Blackout Date
 */
export const getDeleteBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesBlackoutIdDeleteUrl = (
  blackoutId: string
) => {
  return `/api/v1/instructors/availability/blackout-dates/${blackoutId}`;
};

export const deleteBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesBlackoutIdDelete = async (
  blackoutId: string,
  options?: RequestInit
): Promise<DeleteBlackoutResponse> => {
  return customFetch<DeleteBlackoutResponse>(
    getDeleteBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesBlackoutIdDeleteUrl(blackoutId),
    {
      ...options,
      method: 'DELETE',
    }
  );
};

export const getDeleteBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesBlackoutIdDeleteMutationOptions =
  <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof deleteBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesBlackoutIdDelete
        >
      >,
      TError,
      { blackoutId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof deleteBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesBlackoutIdDelete>
    >,
    TError,
    { blackoutId: string },
    TContext
  > => {
    const mutationKey = [
      'deleteBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesBlackoutIdDelete',
    ];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<
          typeof deleteBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesBlackoutIdDelete
        >
      >,
      { blackoutId: string }
    > = (props) => {
      const { blackoutId } = props ?? {};

      return deleteBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesBlackoutIdDelete(
        blackoutId,
        requestOptions
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type DeleteBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesBlackoutIdDeleteMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof deleteBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesBlackoutIdDelete>
    >
  >;

export type DeleteBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesBlackoutIdDeleteMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Delete Blackout Date
 */
export const useDeleteBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesBlackoutIdDelete = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<
          typeof deleteBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesBlackoutIdDelete
        >
      >,
      TError,
      { blackoutId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<
    ReturnType<typeof deleteBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesBlackoutIdDelete>
  >,
  TError,
  { blackoutId: string },
  TContext
> => {
  return useMutation(
    getDeleteBlackoutDateApiV1InstructorsAvailabilityBlackoutDatesBlackoutIdDeleteMutationOptions(
      options
    ),
    queryClient
  );
};
/**
 * Bulk update availability slots.
 * @summary Bulk Update Availability
 */
export const getBulkUpdateAvailabilityApiV1InstructorsAvailabilityBulkUpdatePatchUrl = () => {
  return `/api/v1/instructors/availability/bulk-update`;
};

export const bulkUpdateAvailabilityApiV1InstructorsAvailabilityBulkUpdatePatch = async (
  appSchemasAvailabilityWindowBulkUpdateRequest: AppSchemasAvailabilityWindowBulkUpdateRequest,
  options?: RequestInit
): Promise<BulkUpdateResponse> => {
  return customFetch<BulkUpdateResponse>(
    getBulkUpdateAvailabilityApiV1InstructorsAvailabilityBulkUpdatePatchUrl(),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(appSchemasAvailabilityWindowBulkUpdateRequest),
    }
  );
};

export const getBulkUpdateAvailabilityApiV1InstructorsAvailabilityBulkUpdatePatchMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof bulkUpdateAvailabilityApiV1InstructorsAvailabilityBulkUpdatePatch>>,
    TError,
    { data: AppSchemasAvailabilityWindowBulkUpdateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof bulkUpdateAvailabilityApiV1InstructorsAvailabilityBulkUpdatePatch>>,
  TError,
  { data: AppSchemasAvailabilityWindowBulkUpdateRequest },
  TContext
> => {
  const mutationKey = ['bulkUpdateAvailabilityApiV1InstructorsAvailabilityBulkUpdatePatch'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof bulkUpdateAvailabilityApiV1InstructorsAvailabilityBulkUpdatePatch>>,
    { data: AppSchemasAvailabilityWindowBulkUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return bulkUpdateAvailabilityApiV1InstructorsAvailabilityBulkUpdatePatch(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type BulkUpdateAvailabilityApiV1InstructorsAvailabilityBulkUpdatePatchMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof bulkUpdateAvailabilityApiV1InstructorsAvailabilityBulkUpdatePatch>>
  >;
export type BulkUpdateAvailabilityApiV1InstructorsAvailabilityBulkUpdatePatchMutationBody =
  AppSchemasAvailabilityWindowBulkUpdateRequest;
export type BulkUpdateAvailabilityApiV1InstructorsAvailabilityBulkUpdatePatchMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Bulk Update Availability
 */
export const useBulkUpdateAvailabilityApiV1InstructorsAvailabilityBulkUpdatePatch = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof bulkUpdateAvailabilityApiV1InstructorsAvailabilityBulkUpdatePatch>>,
      TError,
      { data: AppSchemasAvailabilityWindowBulkUpdateRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof bulkUpdateAvailabilityApiV1InstructorsAvailabilityBulkUpdatePatch>>,
  TError,
  { data: AppSchemasAvailabilityWindowBulkUpdateRequest },
  TContext
> => {
  return useMutation(
    getBulkUpdateAvailabilityApiV1InstructorsAvailabilityBulkUpdatePatchMutationOptions(options),
    queryClient
  );
};
/**
 * Copy availability from one week to another.
 * @summary Copy Week Availability
 */
export const getCopyWeekAvailabilityApiV1InstructorsAvailabilityCopyWeekPostUrl = () => {
  return `/api/v1/instructors/availability/copy-week`;
};

export const copyWeekAvailabilityApiV1InstructorsAvailabilityCopyWeekPost = async (
  copyWeekRequest: CopyWeekRequest,
  options?: RequestInit
): Promise<CopyWeekResponse> => {
  return customFetch<CopyWeekResponse>(
    getCopyWeekAvailabilityApiV1InstructorsAvailabilityCopyWeekPostUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(copyWeekRequest),
    }
  );
};

export const getCopyWeekAvailabilityApiV1InstructorsAvailabilityCopyWeekPostMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof copyWeekAvailabilityApiV1InstructorsAvailabilityCopyWeekPost>>,
    TError,
    { data: CopyWeekRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof copyWeekAvailabilityApiV1InstructorsAvailabilityCopyWeekPost>>,
  TError,
  { data: CopyWeekRequest },
  TContext
> => {
  const mutationKey = ['copyWeekAvailabilityApiV1InstructorsAvailabilityCopyWeekPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof copyWeekAvailabilityApiV1InstructorsAvailabilityCopyWeekPost>>,
    { data: CopyWeekRequest }
  > = (props) => {
    const { data } = props ?? {};

    return copyWeekAvailabilityApiV1InstructorsAvailabilityCopyWeekPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CopyWeekAvailabilityApiV1InstructorsAvailabilityCopyWeekPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof copyWeekAvailabilityApiV1InstructorsAvailabilityCopyWeekPost>>
  >;
export type CopyWeekAvailabilityApiV1InstructorsAvailabilityCopyWeekPostMutationBody =
  CopyWeekRequest;
export type CopyWeekAvailabilityApiV1InstructorsAvailabilityCopyWeekPostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Copy Week Availability
 */
export const useCopyWeekAvailabilityApiV1InstructorsAvailabilityCopyWeekPost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof copyWeekAvailabilityApiV1InstructorsAvailabilityCopyWeekPost>>,
      TError,
      { data: CopyWeekRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof copyWeekAvailabilityApiV1InstructorsAvailabilityCopyWeekPost>>,
  TError,
  { data: CopyWeekRequest },
  TContext
> => {
  return useMutation(
    getCopyWeekAvailabilityApiV1InstructorsAvailabilityCopyWeekPostMutationOptions(options),
    queryClient
  );
};
/**
 * Add availability for a specific date.

Returns clean response using schema.
 * @summary Add Specific Date Availability
 */
export const getAddSpecificDateAvailabilityApiV1InstructorsAvailabilitySpecificDatePostUrl = () => {
  return `/api/v1/instructors/availability/specific-date`;
};

export const addSpecificDateAvailabilityApiV1InstructorsAvailabilitySpecificDatePost = async (
  specificDateAvailabilityCreate: SpecificDateAvailabilityCreate,
  options?: RequestInit
): Promise<AvailabilityWindowResponse> => {
  return customFetch<AvailabilityWindowResponse>(
    getAddSpecificDateAvailabilityApiV1InstructorsAvailabilitySpecificDatePostUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(specificDateAvailabilityCreate),
    }
  );
};

export const getAddSpecificDateAvailabilityApiV1InstructorsAvailabilitySpecificDatePostMutationOptions =
  <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof addSpecificDateAvailabilityApiV1InstructorsAvailabilitySpecificDatePost>
      >,
      TError,
      { data: SpecificDateAvailabilityCreate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof addSpecificDateAvailabilityApiV1InstructorsAvailabilitySpecificDatePost>
    >,
    TError,
    { data: SpecificDateAvailabilityCreate },
    TContext
  > => {
    const mutationKey = ['addSpecificDateAvailabilityApiV1InstructorsAvailabilitySpecificDatePost'];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof addSpecificDateAvailabilityApiV1InstructorsAvailabilitySpecificDatePost>
      >,
      { data: SpecificDateAvailabilityCreate }
    > = (props) => {
      const { data } = props ?? {};

      return addSpecificDateAvailabilityApiV1InstructorsAvailabilitySpecificDatePost(
        data,
        requestOptions
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type AddSpecificDateAvailabilityApiV1InstructorsAvailabilitySpecificDatePostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof addSpecificDateAvailabilityApiV1InstructorsAvailabilitySpecificDatePost>
    >
  >;
export type AddSpecificDateAvailabilityApiV1InstructorsAvailabilitySpecificDatePostMutationBody =
  SpecificDateAvailabilityCreate;
export type AddSpecificDateAvailabilityApiV1InstructorsAvailabilitySpecificDatePostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Add Specific Date Availability
 */
export const useAddSpecificDateAvailabilityApiV1InstructorsAvailabilitySpecificDatePost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof addSpecificDateAvailabilityApiV1InstructorsAvailabilitySpecificDatePost>
      >,
      TError,
      { data: SpecificDateAvailabilityCreate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<
    ReturnType<typeof addSpecificDateAvailabilityApiV1InstructorsAvailabilitySpecificDatePost>
  >,
  TError,
  { data: SpecificDateAvailabilityCreate },
  TContext
> => {
  return useMutation(
    getAddSpecificDateAvailabilityApiV1InstructorsAvailabilitySpecificDatePostMutationOptions(
      options
    ),
    queryClient
  );
};
/**
 * Get availability for a specific week.

Returns clean data structure without legacy fields.
 * @summary Get Week Availability
 */
export const getGetWeekAvailabilityApiV1InstructorsAvailabilityWeekGetUrl = (
  params: GetWeekAvailabilityApiV1InstructorsAvailabilityWeekGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/instructors/availability/week?${stringifiedParams}`
    : `/api/v1/instructors/availability/week`;
};

export const getWeekAvailabilityApiV1InstructorsAvailabilityWeekGet = async (
  params: GetWeekAvailabilityApiV1InstructorsAvailabilityWeekGetParams,
  options?: RequestInit
): Promise<WeekAvailabilityResponse> => {
  return customFetch<WeekAvailabilityResponse>(
    getGetWeekAvailabilityApiV1InstructorsAvailabilityWeekGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetWeekAvailabilityApiV1InstructorsAvailabilityWeekGetQueryKey = (
  params?: GetWeekAvailabilityApiV1InstructorsAvailabilityWeekGetParams
) => {
  return [`/api/v1/instructors/availability/week`, ...(params ? [params] : [])] as const;
};

export const getGetWeekAvailabilityApiV1InstructorsAvailabilityWeekGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getWeekAvailabilityApiV1InstructorsAvailabilityWeekGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params: GetWeekAvailabilityApiV1InstructorsAvailabilityWeekGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getWeekAvailabilityApiV1InstructorsAvailabilityWeekGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetWeekAvailabilityApiV1InstructorsAvailabilityWeekGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getWeekAvailabilityApiV1InstructorsAvailabilityWeekGet>>
  > = ({ signal }) =>
    getWeekAvailabilityApiV1InstructorsAvailabilityWeekGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getWeekAvailabilityApiV1InstructorsAvailabilityWeekGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetWeekAvailabilityApiV1InstructorsAvailabilityWeekGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getWeekAvailabilityApiV1InstructorsAvailabilityWeekGet>>
>;
export type GetWeekAvailabilityApiV1InstructorsAvailabilityWeekGetQueryError =
  ErrorType<void | HTTPValidationError>;

export function useGetWeekAvailabilityApiV1InstructorsAvailabilityWeekGet<
  TData = Awaited<ReturnType<typeof getWeekAvailabilityApiV1InstructorsAvailabilityWeekGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params: GetWeekAvailabilityApiV1InstructorsAvailabilityWeekGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getWeekAvailabilityApiV1InstructorsAvailabilityWeekGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekAvailabilityApiV1InstructorsAvailabilityWeekGet>>,
          TError,
          Awaited<ReturnType<typeof getWeekAvailabilityApiV1InstructorsAvailabilityWeekGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekAvailabilityApiV1InstructorsAvailabilityWeekGet<
  TData = Awaited<ReturnType<typeof getWeekAvailabilityApiV1InstructorsAvailabilityWeekGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params: GetWeekAvailabilityApiV1InstructorsAvailabilityWeekGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getWeekAvailabilityApiV1InstructorsAvailabilityWeekGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekAvailabilityApiV1InstructorsAvailabilityWeekGet>>,
          TError,
          Awaited<ReturnType<typeof getWeekAvailabilityApiV1InstructorsAvailabilityWeekGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekAvailabilityApiV1InstructorsAvailabilityWeekGet<
  TData = Awaited<ReturnType<typeof getWeekAvailabilityApiV1InstructorsAvailabilityWeekGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params: GetWeekAvailabilityApiV1InstructorsAvailabilityWeekGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getWeekAvailabilityApiV1InstructorsAvailabilityWeekGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Week Availability
 */

export function useGetWeekAvailabilityApiV1InstructorsAvailabilityWeekGet<
  TData = Awaited<ReturnType<typeof getWeekAvailabilityApiV1InstructorsAvailabilityWeekGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params: GetWeekAvailabilityApiV1InstructorsAvailabilityWeekGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getWeekAvailabilityApiV1InstructorsAvailabilityWeekGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetWeekAvailabilityApiV1InstructorsAvailabilityWeekGetQueryOptions(
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Save availability for specific dates in a week.

Clean implementation with proper cache warming.
 * @summary Save Week Availability
 */
export const getSaveWeekAvailabilityApiV1InstructorsAvailabilityWeekPostUrl = (
  params?: SaveWeekAvailabilityApiV1InstructorsAvailabilityWeekPostParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/instructors/availability/week?${stringifiedParams}`
    : `/api/v1/instructors/availability/week`;
};

export const saveWeekAvailabilityApiV1InstructorsAvailabilityWeekPost = async (
  weekSpecificScheduleCreate: WeekSpecificScheduleCreate,
  params?: SaveWeekAvailabilityApiV1InstructorsAvailabilityWeekPostParams,
  options?: RequestInit
): Promise<WeekAvailabilityUpdateResponse> => {
  return customFetch<WeekAvailabilityUpdateResponse>(
    getSaveWeekAvailabilityApiV1InstructorsAvailabilityWeekPostUrl(params),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(weekSpecificScheduleCreate),
    }
  );
};

export const getSaveWeekAvailabilityApiV1InstructorsAvailabilityWeekPostMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof saveWeekAvailabilityApiV1InstructorsAvailabilityWeekPost>>,
    TError,
    {
      data: WeekSpecificScheduleCreate;
      params?: SaveWeekAvailabilityApiV1InstructorsAvailabilityWeekPostParams;
    },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof saveWeekAvailabilityApiV1InstructorsAvailabilityWeekPost>>,
  TError,
  {
    data: WeekSpecificScheduleCreate;
    params?: SaveWeekAvailabilityApiV1InstructorsAvailabilityWeekPostParams;
  },
  TContext
> => {
  const mutationKey = ['saveWeekAvailabilityApiV1InstructorsAvailabilityWeekPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof saveWeekAvailabilityApiV1InstructorsAvailabilityWeekPost>>,
    {
      data: WeekSpecificScheduleCreate;
      params?: SaveWeekAvailabilityApiV1InstructorsAvailabilityWeekPostParams;
    }
  > = (props) => {
    const { data, params } = props ?? {};

    return saveWeekAvailabilityApiV1InstructorsAvailabilityWeekPost(data, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SaveWeekAvailabilityApiV1InstructorsAvailabilityWeekPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof saveWeekAvailabilityApiV1InstructorsAvailabilityWeekPost>>
>;
export type SaveWeekAvailabilityApiV1InstructorsAvailabilityWeekPostMutationBody =
  WeekSpecificScheduleCreate;
export type SaveWeekAvailabilityApiV1InstructorsAvailabilityWeekPostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Save Week Availability
 */
export const useSaveWeekAvailabilityApiV1InstructorsAvailabilityWeekPost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof saveWeekAvailabilityApiV1InstructorsAvailabilityWeekPost>>,
      TError,
      {
        data: WeekSpecificScheduleCreate;
        params?: SaveWeekAvailabilityApiV1InstructorsAvailabilityWeekPostParams;
      },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof saveWeekAvailabilityApiV1InstructorsAvailabilityWeekPost>>,
  TError,
  {
    data: WeekSpecificScheduleCreate;
    params?: SaveWeekAvailabilityApiV1InstructorsAvailabilityWeekPostParams;
  },
  TContext
> => {
  return useMutation(
    getSaveWeekAvailabilityApiV1InstructorsAvailabilityWeekPostMutationOptions(options),
    queryClient
  );
};
/**
 * Get all booked slots for a week with preview information.
 * @summary Get Week Booked Slots
 */
export const getGetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGetUrl = (
  params: GetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/instructors/availability/week/booked-slots?${stringifiedParams}`
    : `/api/v1/instructors/availability/week/booked-slots`;
};

export const getWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet = async (
  params: GetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGetParams,
  options?: RequestInit
): Promise<BookedSlotsResponse> => {
  return customFetch<BookedSlotsResponse>(
    getGetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGetQueryKey = (
  params?: GetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGetParams
) => {
  return [
    `/api/v1/instructors/availability/week/booked-slots`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet>
  >,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params: GetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet>>
  > = ({ signal }) =>
    getWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet(params, {
      signal,
      ...requestOptions,
    });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet>>
  >;
export type GetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGetQueryError =
  ErrorType<void | HTTPValidationError>;

export function useGetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet<
  TData = Awaited<
    ReturnType<typeof getWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet>
  >,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params: GetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet>
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet<
  TData = Awaited<
    ReturnType<typeof getWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet>
  >,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params: GetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet>
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet<
  TData = Awaited<
    ReturnType<typeof getWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet>
  >,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params: GetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Week Booked Slots
 */

export function useGetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet<
  TData = Awaited<
    ReturnType<typeof getWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet>
  >,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params: GetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGet>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions =
    getGetWeekBookedSlotsApiV1InstructorsAvailabilityWeekBookedSlotsGetQueryOptions(
      params,
      options
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Validate planned changes to week availability.
 * @summary Validate Week Changes
 */
export const getValidateWeekChangesApiV1InstructorsAvailabilityWeekValidateChangesPostUrl = () => {
  return `/api/v1/instructors/availability/week/validate-changes`;
};

export const validateWeekChangesApiV1InstructorsAvailabilityWeekValidateChangesPost = async (
  validateWeekRequest: ValidateWeekRequest,
  options?: RequestInit
): Promise<WeekValidationResponse> => {
  return customFetch<WeekValidationResponse>(
    getValidateWeekChangesApiV1InstructorsAvailabilityWeekValidateChangesPostUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(validateWeekRequest),
    }
  );
};

export const getValidateWeekChangesApiV1InstructorsAvailabilityWeekValidateChangesPostMutationOptions =
  <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof validateWeekChangesApiV1InstructorsAvailabilityWeekValidateChangesPost>
      >,
      TError,
      { data: ValidateWeekRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof validateWeekChangesApiV1InstructorsAvailabilityWeekValidateChangesPost>
    >,
    TError,
    { data: ValidateWeekRequest },
    TContext
  > => {
    const mutationKey = ['validateWeekChangesApiV1InstructorsAvailabilityWeekValidateChangesPost'];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof validateWeekChangesApiV1InstructorsAvailabilityWeekValidateChangesPost>
      >,
      { data: ValidateWeekRequest }
    > = (props) => {
      const { data } = props ?? {};

      return validateWeekChangesApiV1InstructorsAvailabilityWeekValidateChangesPost(
        data,
        requestOptions
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type ValidateWeekChangesApiV1InstructorsAvailabilityWeekValidateChangesPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof validateWeekChangesApiV1InstructorsAvailabilityWeekValidateChangesPost>
    >
  >;
export type ValidateWeekChangesApiV1InstructorsAvailabilityWeekValidateChangesPostMutationBody =
  ValidateWeekRequest;
export type ValidateWeekChangesApiV1InstructorsAvailabilityWeekValidateChangesPostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Validate Week Changes
 */
export const useValidateWeekChangesApiV1InstructorsAvailabilityWeekValidateChangesPost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof validateWeekChangesApiV1InstructorsAvailabilityWeekValidateChangesPost>
      >,
      TError,
      { data: ValidateWeekRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<
    ReturnType<typeof validateWeekChangesApiV1InstructorsAvailabilityWeekValidateChangesPost>
  >,
  TError,
  { data: ValidateWeekRequest },
  TContext
> => {
  return useMutation(
    getValidateWeekChangesApiV1InstructorsAvailabilityWeekValidateChangesPostMutationOptions(
      options
    ),
    queryClient
  );
};
/**
 * Delete an availability window.

DEPRECATED: Individual window deletion not supported in bitmap storage.
Use POST /api/v1/instructors/availability/week to remove windows from days.
 * @summary Delete Availability Window
 */
export const getDeleteAvailabilityWindowApiV1InstructorsAvailabilityWindowIdDeleteUrl = (
  windowId: string
) => {
  return `/api/v1/instructors/availability/${windowId}`;
};

export const deleteAvailabilityWindowApiV1InstructorsAvailabilityWindowIdDelete = async (
  windowId: string,
  options?: RequestInit
): Promise<DeleteWindowResponse> => {
  return customFetch<DeleteWindowResponse>(
    getDeleteAvailabilityWindowApiV1InstructorsAvailabilityWindowIdDeleteUrl(windowId),
    {
      ...options,
      method: 'DELETE',
    }
  );
};

export const getDeleteAvailabilityWindowApiV1InstructorsAvailabilityWindowIdDeleteMutationOptions =
  <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof deleteAvailabilityWindowApiV1InstructorsAvailabilityWindowIdDelete>
      >,
      TError,
      { windowId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<ReturnType<typeof deleteAvailabilityWindowApiV1InstructorsAvailabilityWindowIdDelete>>,
    TError,
    { windowId: string },
    TContext
  > => {
    const mutationKey = ['deleteAvailabilityWindowApiV1InstructorsAvailabilityWindowIdDelete'];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof deleteAvailabilityWindowApiV1InstructorsAvailabilityWindowIdDelete>
      >,
      { windowId: string }
    > = (props) => {
      const { windowId } = props ?? {};

      return deleteAvailabilityWindowApiV1InstructorsAvailabilityWindowIdDelete(
        windowId,
        requestOptions
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type DeleteAvailabilityWindowApiV1InstructorsAvailabilityWindowIdDeleteMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof deleteAvailabilityWindowApiV1InstructorsAvailabilityWindowIdDelete>>
  >;

export type DeleteAvailabilityWindowApiV1InstructorsAvailabilityWindowIdDeleteMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Delete Availability Window
 */
export const useDeleteAvailabilityWindowApiV1InstructorsAvailabilityWindowIdDelete = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof deleteAvailabilityWindowApiV1InstructorsAvailabilityWindowIdDelete>
      >,
      TError,
      { windowId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteAvailabilityWindowApiV1InstructorsAvailabilityWindowIdDelete>>,
  TError,
  { windowId: string },
  TContext
> => {
  return useMutation(
    getDeleteAvailabilityWindowApiV1InstructorsAvailabilityWindowIdDeleteMutationOptions(options),
    queryClient
  );
};
/**
 * Update an availability window.

DEPRECATED: Individual window updates not supported in bitmap storage.
Use POST /api/v1/instructors/availability/week to update entire days.
 * @summary Update Availability Window
 */
export const getUpdateAvailabilityWindowApiV1InstructorsAvailabilityWindowIdPatchUrl = (
  windowId: string
) => {
  return `/api/v1/instructors/availability/${windowId}`;
};

export const updateAvailabilityWindowApiV1InstructorsAvailabilityWindowIdPatch = async (
  windowId: string,
  availabilityWindowUpdate: AvailabilityWindowUpdate,
  options?: RequestInit
): Promise<AvailabilityWindowResponse> => {
  return customFetch<AvailabilityWindowResponse>(
    getUpdateAvailabilityWindowApiV1InstructorsAvailabilityWindowIdPatchUrl(windowId),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(availabilityWindowUpdate),
    }
  );
};

export const getUpdateAvailabilityWindowApiV1InstructorsAvailabilityWindowIdPatchMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateAvailabilityWindowApiV1InstructorsAvailabilityWindowIdPatch>>,
    TError,
    { windowId: string; data: AvailabilityWindowUpdate },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateAvailabilityWindowApiV1InstructorsAvailabilityWindowIdPatch>>,
  TError,
  { windowId: string; data: AvailabilityWindowUpdate },
  TContext
> => {
  const mutationKey = ['updateAvailabilityWindowApiV1InstructorsAvailabilityWindowIdPatch'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateAvailabilityWindowApiV1InstructorsAvailabilityWindowIdPatch>>,
    { windowId: string; data: AvailabilityWindowUpdate }
  > = (props) => {
    const { windowId, data } = props ?? {};

    return updateAvailabilityWindowApiV1InstructorsAvailabilityWindowIdPatch(
      windowId,
      data,
      requestOptions
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateAvailabilityWindowApiV1InstructorsAvailabilityWindowIdPatchMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof updateAvailabilityWindowApiV1InstructorsAvailabilityWindowIdPatch>>
  >;
export type UpdateAvailabilityWindowApiV1InstructorsAvailabilityWindowIdPatchMutationBody =
  AvailabilityWindowUpdate;
export type UpdateAvailabilityWindowApiV1InstructorsAvailabilityWindowIdPatchMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Update Availability Window
 */
export const useUpdateAvailabilityWindowApiV1InstructorsAvailabilityWindowIdPatch = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateAvailabilityWindowApiV1InstructorsAvailabilityWindowIdPatch>>,
      TError,
      { windowId: string; data: AvailabilityWindowUpdate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateAvailabilityWindowApiV1InstructorsAvailabilityWindowIdPatch>>,
  TError,
  { windowId: string; data: AvailabilityWindowUpdate },
  TContext
> => {
  return useMutation(
    getUpdateAvailabilityWindowApiV1InstructorsAvailabilityWindowIdPatchMutationOptions(options),
    queryClient
  );
};
