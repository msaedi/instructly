/**
 * Generated by orval v7.16.1 ðŸº
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ApplyToDateRangeRequest,
  ApplyToDateRangeResponse,
  AvailabilityWindowResponse,
  AvailabilityWindowUpdate,
  BlackoutDateCreate,
  BlackoutDateResponse,
  BookedSlotsResponse,
  BulkUpdateRequest,
  BulkUpdateResponse,
  CopyWeekRequest,
  CopyWeekResponse,
  DeleteBlackoutResponse,
  DeleteWindowResponse,
  GetAllAvailabilityInstructorsAvailabilityGetParams,
  GetWeekAvailabilityInstructorsAvailabilityWeekGetParams,
  GetWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGetParams,
  HTTPValidationError,
  SaveWeekAvailabilityInstructorsAvailabilityWeekPostParams,
  SpecificDateAvailabilityCreate,
  ValidateWeekRequest,
  WeekAvailabilityResponse,
  WeekAvailabilityUpdateResponse,
  WeekSpecificScheduleCreate,
  WeekValidationResponse
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';




/**
 * Get all availability windows.

CLEAN ARCHITECTURE: Returns only meaningful fields.
No legacy patterns.
 * @summary Get All Availability
 */
export const getAllAvailabilityInstructorsAvailabilityGet = (
    params?: GetAllAvailabilityInstructorsAvailabilityGetParams,
 signal?: AbortSignal
) => {


      return customFetch<AvailabilityWindowResponse[]>(
      {url: `/instructors/availability/`, method: 'GET',
        params, signal
    },
      );
    }




export const getGetAllAvailabilityInstructorsAvailabilityGetQueryKey = (params?: GetAllAvailabilityInstructorsAvailabilityGetParams,) => {
    return [
    `/instructors/availability/`, ...(params ? [params]: [])
    ] as const;
    }


export const getGetAllAvailabilityInstructorsAvailabilityGetQueryOptions = <TData = Awaited<ReturnType<typeof getAllAvailabilityInstructorsAvailabilityGet>>, TError = ErrorType<HTTPValidationError>>(params?: GetAllAvailabilityInstructorsAvailabilityGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAvailabilityInstructorsAvailabilityGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllAvailabilityInstructorsAvailabilityGetQueryKey(params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllAvailabilityInstructorsAvailabilityGet>>> = ({ signal }) => getAllAvailabilityInstructorsAvailabilityGet(params, signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllAvailabilityInstructorsAvailabilityGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllAvailabilityInstructorsAvailabilityGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAllAvailabilityInstructorsAvailabilityGet>>>
export type GetAllAvailabilityInstructorsAvailabilityGetQueryError = ErrorType<HTTPValidationError>


export function useGetAllAvailabilityInstructorsAvailabilityGet<TData = Awaited<ReturnType<typeof getAllAvailabilityInstructorsAvailabilityGet>>, TError = ErrorType<HTTPValidationError>>(
 params: undefined |  GetAllAvailabilityInstructorsAvailabilityGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAvailabilityInstructorsAvailabilityGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllAvailabilityInstructorsAvailabilityGet>>,
          TError,
          Awaited<ReturnType<typeof getAllAvailabilityInstructorsAvailabilityGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllAvailabilityInstructorsAvailabilityGet<TData = Awaited<ReturnType<typeof getAllAvailabilityInstructorsAvailabilityGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetAllAvailabilityInstructorsAvailabilityGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAvailabilityInstructorsAvailabilityGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllAvailabilityInstructorsAvailabilityGet>>,
          TError,
          Awaited<ReturnType<typeof getAllAvailabilityInstructorsAvailabilityGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllAvailabilityInstructorsAvailabilityGet<TData = Awaited<ReturnType<typeof getAllAvailabilityInstructorsAvailabilityGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetAllAvailabilityInstructorsAvailabilityGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAvailabilityInstructorsAvailabilityGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get All Availability
 */

export function useGetAllAvailabilityInstructorsAvailabilityGet<TData = Awaited<ReturnType<typeof getAllAvailabilityInstructorsAvailabilityGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetAllAvailabilityInstructorsAvailabilityGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllAvailabilityInstructorsAvailabilityGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllAvailabilityInstructorsAvailabilityGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Apply a week's pattern to a date range.
 * @summary Apply To Date Range
 */
export const applyToDateRangeInstructorsAvailabilityApplyToDateRangePost = (
    applyToDateRangeRequest: ApplyToDateRangeRequest,
 signal?: AbortSignal
) => {


      return customFetch<ApplyToDateRangeResponse>(
      {url: `/instructors/availability/apply-to-date-range`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: applyToDateRangeRequest, signal
    },
      );
    }



export const getApplyToDateRangeInstructorsAvailabilityApplyToDateRangePostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof applyToDateRangeInstructorsAvailabilityApplyToDateRangePost>>, TError,{data: ApplyToDateRangeRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof applyToDateRangeInstructorsAvailabilityApplyToDateRangePost>>, TError,{data: ApplyToDateRangeRequest}, TContext> => {

const mutationKey = ['applyToDateRangeInstructorsAvailabilityApplyToDateRangePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof applyToDateRangeInstructorsAvailabilityApplyToDateRangePost>>, {data: ApplyToDateRangeRequest}> = (props) => {
          const {data} = props ?? {};

          return  applyToDateRangeInstructorsAvailabilityApplyToDateRangePost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type ApplyToDateRangeInstructorsAvailabilityApplyToDateRangePostMutationResult = NonNullable<Awaited<ReturnType<typeof applyToDateRangeInstructorsAvailabilityApplyToDateRangePost>>>
    export type ApplyToDateRangeInstructorsAvailabilityApplyToDateRangePostMutationBody = ApplyToDateRangeRequest
    export type ApplyToDateRangeInstructorsAvailabilityApplyToDateRangePostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Apply To Date Range
 */
export const useApplyToDateRangeInstructorsAvailabilityApplyToDateRangePost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof applyToDateRangeInstructorsAvailabilityApplyToDateRangePost>>, TError,{data: ApplyToDateRangeRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof applyToDateRangeInstructorsAvailabilityApplyToDateRangePost>>,
        TError,
        {data: ApplyToDateRangeRequest},
        TContext
      > => {

      const mutationOptions = getApplyToDateRangeInstructorsAvailabilityApplyToDateRangePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get instructor's blackout dates.
 * @summary Get Blackout Dates
 */
export const getBlackoutDatesInstructorsAvailabilityBlackoutDatesGet = (

 signal?: AbortSignal
) => {


      return customFetch<BlackoutDateResponse[]>(
      {url: `/instructors/availability/blackout-dates`, method: 'GET', signal
    },
      );
    }




export const getGetBlackoutDatesInstructorsAvailabilityBlackoutDatesGetQueryKey = () => {
    return [
    `/instructors/availability/blackout-dates`
    ] as const;
    }


export const getGetBlackoutDatesInstructorsAvailabilityBlackoutDatesGetQueryOptions = <TData = Awaited<ReturnType<typeof getBlackoutDatesInstructorsAvailabilityBlackoutDatesGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlackoutDatesInstructorsAvailabilityBlackoutDatesGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBlackoutDatesInstructorsAvailabilityBlackoutDatesGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBlackoutDatesInstructorsAvailabilityBlackoutDatesGet>>> = ({ signal }) => getBlackoutDatesInstructorsAvailabilityBlackoutDatesGet(signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBlackoutDatesInstructorsAvailabilityBlackoutDatesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBlackoutDatesInstructorsAvailabilityBlackoutDatesGetQueryResult = NonNullable<Awaited<ReturnType<typeof getBlackoutDatesInstructorsAvailabilityBlackoutDatesGet>>>
export type GetBlackoutDatesInstructorsAvailabilityBlackoutDatesGetQueryError = ErrorType<unknown>


export function useGetBlackoutDatesInstructorsAvailabilityBlackoutDatesGet<TData = Awaited<ReturnType<typeof getBlackoutDatesInstructorsAvailabilityBlackoutDatesGet>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlackoutDatesInstructorsAvailabilityBlackoutDatesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBlackoutDatesInstructorsAvailabilityBlackoutDatesGet>>,
          TError,
          Awaited<ReturnType<typeof getBlackoutDatesInstructorsAvailabilityBlackoutDatesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBlackoutDatesInstructorsAvailabilityBlackoutDatesGet<TData = Awaited<ReturnType<typeof getBlackoutDatesInstructorsAvailabilityBlackoutDatesGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlackoutDatesInstructorsAvailabilityBlackoutDatesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBlackoutDatesInstructorsAvailabilityBlackoutDatesGet>>,
          TError,
          Awaited<ReturnType<typeof getBlackoutDatesInstructorsAvailabilityBlackoutDatesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBlackoutDatesInstructorsAvailabilityBlackoutDatesGet<TData = Awaited<ReturnType<typeof getBlackoutDatesInstructorsAvailabilityBlackoutDatesGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlackoutDatesInstructorsAvailabilityBlackoutDatesGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Blackout Dates
 */

export function useGetBlackoutDatesInstructorsAvailabilityBlackoutDatesGet<TData = Awaited<ReturnType<typeof getBlackoutDatesInstructorsAvailabilityBlackoutDatesGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBlackoutDatesInstructorsAvailabilityBlackoutDatesGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBlackoutDatesInstructorsAvailabilityBlackoutDatesGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Add a blackout date (vacation/unavailable).
 * @summary Add Blackout Date
 */
export const addBlackoutDateInstructorsAvailabilityBlackoutDatesPost = (
    blackoutDateCreate: BlackoutDateCreate,
 signal?: AbortSignal
) => {


      return customFetch<BlackoutDateResponse>(
      {url: `/instructors/availability/blackout-dates`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: blackoutDateCreate, signal
    },
      );
    }



export const getAddBlackoutDateInstructorsAvailabilityBlackoutDatesPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addBlackoutDateInstructorsAvailabilityBlackoutDatesPost>>, TError,{data: BlackoutDateCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof addBlackoutDateInstructorsAvailabilityBlackoutDatesPost>>, TError,{data: BlackoutDateCreate}, TContext> => {

const mutationKey = ['addBlackoutDateInstructorsAvailabilityBlackoutDatesPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addBlackoutDateInstructorsAvailabilityBlackoutDatesPost>>, {data: BlackoutDateCreate}> = (props) => {
          const {data} = props ?? {};

          return  addBlackoutDateInstructorsAvailabilityBlackoutDatesPost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type AddBlackoutDateInstructorsAvailabilityBlackoutDatesPostMutationResult = NonNullable<Awaited<ReturnType<typeof addBlackoutDateInstructorsAvailabilityBlackoutDatesPost>>>
    export type AddBlackoutDateInstructorsAvailabilityBlackoutDatesPostMutationBody = BlackoutDateCreate
    export type AddBlackoutDateInstructorsAvailabilityBlackoutDatesPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Add Blackout Date
 */
export const useAddBlackoutDateInstructorsAvailabilityBlackoutDatesPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addBlackoutDateInstructorsAvailabilityBlackoutDatesPost>>, TError,{data: BlackoutDateCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addBlackoutDateInstructorsAvailabilityBlackoutDatesPost>>,
        TError,
        {data: BlackoutDateCreate},
        TContext
      > => {

      const mutationOptions = getAddBlackoutDateInstructorsAvailabilityBlackoutDatesPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete a blackout date.
 * @summary Delete Blackout Date
 */
export const deleteBlackoutDateInstructorsAvailabilityBlackoutDatesBlackoutIdDelete = (
    blackoutId: string,
 ) => {


      return customFetch<DeleteBlackoutResponse>(
      {url: `/instructors/availability/blackout-dates/${blackoutId}`, method: 'DELETE'
    },
      );
    }



export const getDeleteBlackoutDateInstructorsAvailabilityBlackoutDatesBlackoutIdDeleteMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBlackoutDateInstructorsAvailabilityBlackoutDatesBlackoutIdDelete>>, TError,{blackoutId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteBlackoutDateInstructorsAvailabilityBlackoutDatesBlackoutIdDelete>>, TError,{blackoutId: string}, TContext> => {

const mutationKey = ['deleteBlackoutDateInstructorsAvailabilityBlackoutDatesBlackoutIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteBlackoutDateInstructorsAvailabilityBlackoutDatesBlackoutIdDelete>>, {blackoutId: string}> = (props) => {
          const {blackoutId} = props ?? {};

          return  deleteBlackoutDateInstructorsAvailabilityBlackoutDatesBlackoutIdDelete(blackoutId,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type DeleteBlackoutDateInstructorsAvailabilityBlackoutDatesBlackoutIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteBlackoutDateInstructorsAvailabilityBlackoutDatesBlackoutIdDelete>>>

    export type DeleteBlackoutDateInstructorsAvailabilityBlackoutDatesBlackoutIdDeleteMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Delete Blackout Date
 */
export const useDeleteBlackoutDateInstructorsAvailabilityBlackoutDatesBlackoutIdDelete = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteBlackoutDateInstructorsAvailabilityBlackoutDatesBlackoutIdDelete>>, TError,{blackoutId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteBlackoutDateInstructorsAvailabilityBlackoutDatesBlackoutIdDelete>>,
        TError,
        {blackoutId: string},
        TContext
      > => {

      const mutationOptions = getDeleteBlackoutDateInstructorsAvailabilityBlackoutDatesBlackoutIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Bulk update availability slots.
 * @summary Bulk Update Availability
 */
export const bulkUpdateAvailabilityInstructorsAvailabilityBulkUpdatePatch = (
    bulkUpdateRequest: BulkUpdateRequest,
 ) => {


      return customFetch<BulkUpdateResponse>(
      {url: `/instructors/availability/bulk-update`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: bulkUpdateRequest
    },
      );
    }



export const getBulkUpdateAvailabilityInstructorsAvailabilityBulkUpdatePatchMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bulkUpdateAvailabilityInstructorsAvailabilityBulkUpdatePatch>>, TError,{data: BulkUpdateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof bulkUpdateAvailabilityInstructorsAvailabilityBulkUpdatePatch>>, TError,{data: BulkUpdateRequest}, TContext> => {

const mutationKey = ['bulkUpdateAvailabilityInstructorsAvailabilityBulkUpdatePatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof bulkUpdateAvailabilityInstructorsAvailabilityBulkUpdatePatch>>, {data: BulkUpdateRequest}> = (props) => {
          const {data} = props ?? {};

          return  bulkUpdateAvailabilityInstructorsAvailabilityBulkUpdatePatch(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type BulkUpdateAvailabilityInstructorsAvailabilityBulkUpdatePatchMutationResult = NonNullable<Awaited<ReturnType<typeof bulkUpdateAvailabilityInstructorsAvailabilityBulkUpdatePatch>>>
    export type BulkUpdateAvailabilityInstructorsAvailabilityBulkUpdatePatchMutationBody = BulkUpdateRequest
    export type BulkUpdateAvailabilityInstructorsAvailabilityBulkUpdatePatchMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Bulk Update Availability
 */
export const useBulkUpdateAvailabilityInstructorsAvailabilityBulkUpdatePatch = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof bulkUpdateAvailabilityInstructorsAvailabilityBulkUpdatePatch>>, TError,{data: BulkUpdateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof bulkUpdateAvailabilityInstructorsAvailabilityBulkUpdatePatch>>,
        TError,
        {data: BulkUpdateRequest},
        TContext
      > => {

      const mutationOptions = getBulkUpdateAvailabilityInstructorsAvailabilityBulkUpdatePatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Copy availability from one week to another.
 * @summary Copy Week Availability
 */
export const copyWeekAvailabilityInstructorsAvailabilityCopyWeekPost = (
    copyWeekRequest: CopyWeekRequest,
 signal?: AbortSignal
) => {


      return customFetch<CopyWeekResponse>(
      {url: `/instructors/availability/copy-week`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: copyWeekRequest, signal
    },
      );
    }



export const getCopyWeekAvailabilityInstructorsAvailabilityCopyWeekPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof copyWeekAvailabilityInstructorsAvailabilityCopyWeekPost>>, TError,{data: CopyWeekRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof copyWeekAvailabilityInstructorsAvailabilityCopyWeekPost>>, TError,{data: CopyWeekRequest}, TContext> => {

const mutationKey = ['copyWeekAvailabilityInstructorsAvailabilityCopyWeekPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof copyWeekAvailabilityInstructorsAvailabilityCopyWeekPost>>, {data: CopyWeekRequest}> = (props) => {
          const {data} = props ?? {};

          return  copyWeekAvailabilityInstructorsAvailabilityCopyWeekPost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type CopyWeekAvailabilityInstructorsAvailabilityCopyWeekPostMutationResult = NonNullable<Awaited<ReturnType<typeof copyWeekAvailabilityInstructorsAvailabilityCopyWeekPost>>>
    export type CopyWeekAvailabilityInstructorsAvailabilityCopyWeekPostMutationBody = CopyWeekRequest
    export type CopyWeekAvailabilityInstructorsAvailabilityCopyWeekPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Copy Week Availability
 */
export const useCopyWeekAvailabilityInstructorsAvailabilityCopyWeekPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof copyWeekAvailabilityInstructorsAvailabilityCopyWeekPost>>, TError,{data: CopyWeekRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof copyWeekAvailabilityInstructorsAvailabilityCopyWeekPost>>,
        TError,
        {data: CopyWeekRequest},
        TContext
      > => {

      const mutationOptions = getCopyWeekAvailabilityInstructorsAvailabilityCopyWeekPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Add availability for a specific date.

Returns clean response using schema.
 * @summary Add Specific Date Availability
 */
export const addSpecificDateAvailabilityInstructorsAvailabilitySpecificDatePost = (
    specificDateAvailabilityCreate: SpecificDateAvailabilityCreate,
 signal?: AbortSignal
) => {


      return customFetch<AvailabilityWindowResponse>(
      {url: `/instructors/availability/specific-date`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: specificDateAvailabilityCreate, signal
    },
      );
    }



export const getAddSpecificDateAvailabilityInstructorsAvailabilitySpecificDatePostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addSpecificDateAvailabilityInstructorsAvailabilitySpecificDatePost>>, TError,{data: SpecificDateAvailabilityCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof addSpecificDateAvailabilityInstructorsAvailabilitySpecificDatePost>>, TError,{data: SpecificDateAvailabilityCreate}, TContext> => {

const mutationKey = ['addSpecificDateAvailabilityInstructorsAvailabilitySpecificDatePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addSpecificDateAvailabilityInstructorsAvailabilitySpecificDatePost>>, {data: SpecificDateAvailabilityCreate}> = (props) => {
          const {data} = props ?? {};

          return  addSpecificDateAvailabilityInstructorsAvailabilitySpecificDatePost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type AddSpecificDateAvailabilityInstructorsAvailabilitySpecificDatePostMutationResult = NonNullable<Awaited<ReturnType<typeof addSpecificDateAvailabilityInstructorsAvailabilitySpecificDatePost>>>
    export type AddSpecificDateAvailabilityInstructorsAvailabilitySpecificDatePostMutationBody = SpecificDateAvailabilityCreate
    export type AddSpecificDateAvailabilityInstructorsAvailabilitySpecificDatePostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Add Specific Date Availability
 */
export const useAddSpecificDateAvailabilityInstructorsAvailabilitySpecificDatePost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addSpecificDateAvailabilityInstructorsAvailabilitySpecificDatePost>>, TError,{data: SpecificDateAvailabilityCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addSpecificDateAvailabilityInstructorsAvailabilitySpecificDatePost>>,
        TError,
        {data: SpecificDateAvailabilityCreate},
        TContext
      > => {

      const mutationOptions = getAddSpecificDateAvailabilityInstructorsAvailabilitySpecificDatePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get availability for a specific week.

Returns clean data structure without legacy fields.
 * @summary Get Week Availability
 */
export const getWeekAvailabilityInstructorsAvailabilityWeekGet = (
    params: GetWeekAvailabilityInstructorsAvailabilityWeekGetParams,
 signal?: AbortSignal
) => {


      return customFetch<WeekAvailabilityResponse>(
      {url: `/instructors/availability/week`, method: 'GET',
        params, signal
    },
      );
    }




export const getGetWeekAvailabilityInstructorsAvailabilityWeekGetQueryKey = (params?: GetWeekAvailabilityInstructorsAvailabilityWeekGetParams,) => {
    return [
    `/instructors/availability/week`, ...(params ? [params]: [])
    ] as const;
    }


export const getGetWeekAvailabilityInstructorsAvailabilityWeekGetQueryOptions = <TData = Awaited<ReturnType<typeof getWeekAvailabilityInstructorsAvailabilityWeekGet>>, TError = ErrorType<HTTPValidationError>>(params: GetWeekAvailabilityInstructorsAvailabilityWeekGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekAvailabilityInstructorsAvailabilityWeekGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWeekAvailabilityInstructorsAvailabilityWeekGetQueryKey(params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWeekAvailabilityInstructorsAvailabilityWeekGet>>> = ({ signal }) => getWeekAvailabilityInstructorsAvailabilityWeekGet(params, signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWeekAvailabilityInstructorsAvailabilityWeekGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWeekAvailabilityInstructorsAvailabilityWeekGetQueryResult = NonNullable<Awaited<ReturnType<typeof getWeekAvailabilityInstructorsAvailabilityWeekGet>>>
export type GetWeekAvailabilityInstructorsAvailabilityWeekGetQueryError = ErrorType<HTTPValidationError>


export function useGetWeekAvailabilityInstructorsAvailabilityWeekGet<TData = Awaited<ReturnType<typeof getWeekAvailabilityInstructorsAvailabilityWeekGet>>, TError = ErrorType<HTTPValidationError>>(
 params: GetWeekAvailabilityInstructorsAvailabilityWeekGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekAvailabilityInstructorsAvailabilityWeekGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekAvailabilityInstructorsAvailabilityWeekGet>>,
          TError,
          Awaited<ReturnType<typeof getWeekAvailabilityInstructorsAvailabilityWeekGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWeekAvailabilityInstructorsAvailabilityWeekGet<TData = Awaited<ReturnType<typeof getWeekAvailabilityInstructorsAvailabilityWeekGet>>, TError = ErrorType<HTTPValidationError>>(
 params: GetWeekAvailabilityInstructorsAvailabilityWeekGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekAvailabilityInstructorsAvailabilityWeekGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekAvailabilityInstructorsAvailabilityWeekGet>>,
          TError,
          Awaited<ReturnType<typeof getWeekAvailabilityInstructorsAvailabilityWeekGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWeekAvailabilityInstructorsAvailabilityWeekGet<TData = Awaited<ReturnType<typeof getWeekAvailabilityInstructorsAvailabilityWeekGet>>, TError = ErrorType<HTTPValidationError>>(
 params: GetWeekAvailabilityInstructorsAvailabilityWeekGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekAvailabilityInstructorsAvailabilityWeekGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Week Availability
 */

export function useGetWeekAvailabilityInstructorsAvailabilityWeekGet<TData = Awaited<ReturnType<typeof getWeekAvailabilityInstructorsAvailabilityWeekGet>>, TError = ErrorType<HTTPValidationError>>(
 params: GetWeekAvailabilityInstructorsAvailabilityWeekGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekAvailabilityInstructorsAvailabilityWeekGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWeekAvailabilityInstructorsAvailabilityWeekGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Save availability for specific dates in a week.

Clean implementation with proper cache warming.
 * @summary Save Week Availability
 */
export const saveWeekAvailabilityInstructorsAvailabilityWeekPost = (
    weekSpecificScheduleCreate: WeekSpecificScheduleCreate,
    params?: SaveWeekAvailabilityInstructorsAvailabilityWeekPostParams,
 signal?: AbortSignal
) => {


      return customFetch<WeekAvailabilityUpdateResponse>(
      {url: `/instructors/availability/week`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: weekSpecificScheduleCreate,
        params, signal
    },
      );
    }



export const getSaveWeekAvailabilityInstructorsAvailabilityWeekPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveWeekAvailabilityInstructorsAvailabilityWeekPost>>, TError,{data: WeekSpecificScheduleCreate;params?: SaveWeekAvailabilityInstructorsAvailabilityWeekPostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof saveWeekAvailabilityInstructorsAvailabilityWeekPost>>, TError,{data: WeekSpecificScheduleCreate;params?: SaveWeekAvailabilityInstructorsAvailabilityWeekPostParams}, TContext> => {

const mutationKey = ['saveWeekAvailabilityInstructorsAvailabilityWeekPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof saveWeekAvailabilityInstructorsAvailabilityWeekPost>>, {data: WeekSpecificScheduleCreate;params?: SaveWeekAvailabilityInstructorsAvailabilityWeekPostParams}> = (props) => {
          const {data,params} = props ?? {};

          return  saveWeekAvailabilityInstructorsAvailabilityWeekPost(data,params,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type SaveWeekAvailabilityInstructorsAvailabilityWeekPostMutationResult = NonNullable<Awaited<ReturnType<typeof saveWeekAvailabilityInstructorsAvailabilityWeekPost>>>
    export type SaveWeekAvailabilityInstructorsAvailabilityWeekPostMutationBody = WeekSpecificScheduleCreate
    export type SaveWeekAvailabilityInstructorsAvailabilityWeekPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Save Week Availability
 */
export const useSaveWeekAvailabilityInstructorsAvailabilityWeekPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof saveWeekAvailabilityInstructorsAvailabilityWeekPost>>, TError,{data: WeekSpecificScheduleCreate;params?: SaveWeekAvailabilityInstructorsAvailabilityWeekPostParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof saveWeekAvailabilityInstructorsAvailabilityWeekPost>>,
        TError,
        {data: WeekSpecificScheduleCreate;params?: SaveWeekAvailabilityInstructorsAvailabilityWeekPostParams},
        TContext
      > => {

      const mutationOptions = getSaveWeekAvailabilityInstructorsAvailabilityWeekPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get all booked slots for a week with preview information.
 * @summary Get Week Booked Slots
 */
export const getWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet = (
    params: GetWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGetParams,
 signal?: AbortSignal
) => {


      return customFetch<BookedSlotsResponse>(
      {url: `/instructors/availability/week/booked-slots`, method: 'GET',
        params, signal
    },
      );
    }




export const getGetWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGetQueryKey = (params?: GetWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGetParams,) => {
    return [
    `/instructors/availability/week/booked-slots`, ...(params ? [params]: [])
    ] as const;
    }


export const getGetWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGetQueryOptions = <TData = Awaited<ReturnType<typeof getWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet>>, TError = ErrorType<HTTPValidationError>>(params: GetWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGetQueryKey(params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet>>> = ({ signal }) => getWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet(params, signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet>>>
export type GetWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGetQueryError = ErrorType<HTTPValidationError>


export function useGetWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet<TData = Awaited<ReturnType<typeof getWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet>>, TError = ErrorType<HTTPValidationError>>(
 params: GetWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet>>,
          TError,
          Awaited<ReturnType<typeof getWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet<TData = Awaited<ReturnType<typeof getWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet>>, TError = ErrorType<HTTPValidationError>>(
 params: GetWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet>>,
          TError,
          Awaited<ReturnType<typeof getWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet<TData = Awaited<ReturnType<typeof getWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet>>, TError = ErrorType<HTTPValidationError>>(
 params: GetWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Week Booked Slots
 */

export function useGetWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet<TData = Awaited<ReturnType<typeof getWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet>>, TError = ErrorType<HTTPValidationError>>(
 params: GetWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetWeekBookedSlotsInstructorsAvailabilityWeekBookedSlotsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Validate planned changes to week availability.
 * @summary Validate Week Changes
 */
export const validateWeekChangesInstructorsAvailabilityWeekValidateChangesPost = (
    validateWeekRequest: ValidateWeekRequest,
 signal?: AbortSignal
) => {


      return customFetch<WeekValidationResponse>(
      {url: `/instructors/availability/week/validate-changes`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: validateWeekRequest, signal
    },
      );
    }



export const getValidateWeekChangesInstructorsAvailabilityWeekValidateChangesPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateWeekChangesInstructorsAvailabilityWeekValidateChangesPost>>, TError,{data: ValidateWeekRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof validateWeekChangesInstructorsAvailabilityWeekValidateChangesPost>>, TError,{data: ValidateWeekRequest}, TContext> => {

const mutationKey = ['validateWeekChangesInstructorsAvailabilityWeekValidateChangesPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof validateWeekChangesInstructorsAvailabilityWeekValidateChangesPost>>, {data: ValidateWeekRequest}> = (props) => {
          const {data} = props ?? {};

          return  validateWeekChangesInstructorsAvailabilityWeekValidateChangesPost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type ValidateWeekChangesInstructorsAvailabilityWeekValidateChangesPostMutationResult = NonNullable<Awaited<ReturnType<typeof validateWeekChangesInstructorsAvailabilityWeekValidateChangesPost>>>
    export type ValidateWeekChangesInstructorsAvailabilityWeekValidateChangesPostMutationBody = ValidateWeekRequest
    export type ValidateWeekChangesInstructorsAvailabilityWeekValidateChangesPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Validate Week Changes
 */
export const useValidateWeekChangesInstructorsAvailabilityWeekValidateChangesPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof validateWeekChangesInstructorsAvailabilityWeekValidateChangesPost>>, TError,{data: ValidateWeekRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof validateWeekChangesInstructorsAvailabilityWeekValidateChangesPost>>,
        TError,
        {data: ValidateWeekRequest},
        TContext
      > => {

      const mutationOptions = getValidateWeekChangesInstructorsAvailabilityWeekValidateChangesPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete an availability window.

DEPRECATED: Individual window deletion not supported in bitmap storage.
Use POST /instructors/availability/week to remove windows from days.
 * @summary Delete Availability Window
 */
export const deleteAvailabilityWindowInstructorsAvailabilityWindowIdDelete = (
    windowId: string,
 ) => {


      return customFetch<DeleteWindowResponse>(
      {url: `/instructors/availability/${windowId}`, method: 'DELETE'
    },
      );
    }



export const getDeleteAvailabilityWindowInstructorsAvailabilityWindowIdDeleteMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAvailabilityWindowInstructorsAvailabilityWindowIdDelete>>, TError,{windowId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteAvailabilityWindowInstructorsAvailabilityWindowIdDelete>>, TError,{windowId: string}, TContext> => {

const mutationKey = ['deleteAvailabilityWindowInstructorsAvailabilityWindowIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAvailabilityWindowInstructorsAvailabilityWindowIdDelete>>, {windowId: string}> = (props) => {
          const {windowId} = props ?? {};

          return  deleteAvailabilityWindowInstructorsAvailabilityWindowIdDelete(windowId,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type DeleteAvailabilityWindowInstructorsAvailabilityWindowIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAvailabilityWindowInstructorsAvailabilityWindowIdDelete>>>

    export type DeleteAvailabilityWindowInstructorsAvailabilityWindowIdDeleteMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Delete Availability Window
 */
export const useDeleteAvailabilityWindowInstructorsAvailabilityWindowIdDelete = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAvailabilityWindowInstructorsAvailabilityWindowIdDelete>>, TError,{windowId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAvailabilityWindowInstructorsAvailabilityWindowIdDelete>>,
        TError,
        {windowId: string},
        TContext
      > => {

      const mutationOptions = getDeleteAvailabilityWindowInstructorsAvailabilityWindowIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Update an availability window.

DEPRECATED: Individual window updates not supported in bitmap storage.
Use POST /instructors/availability/week to update entire days.
 * @summary Update Availability Window
 */
export const updateAvailabilityWindowInstructorsAvailabilityWindowIdPatch = (
    windowId: string,
    availabilityWindowUpdate: AvailabilityWindowUpdate,
 ) => {


      return customFetch<AvailabilityWindowResponse>(
      {url: `/instructors/availability/${windowId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: availabilityWindowUpdate
    },
      );
    }



export const getUpdateAvailabilityWindowInstructorsAvailabilityWindowIdPatchMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAvailabilityWindowInstructorsAvailabilityWindowIdPatch>>, TError,{windowId: string;data: AvailabilityWindowUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateAvailabilityWindowInstructorsAvailabilityWindowIdPatch>>, TError,{windowId: string;data: AvailabilityWindowUpdate}, TContext> => {

const mutationKey = ['updateAvailabilityWindowInstructorsAvailabilityWindowIdPatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateAvailabilityWindowInstructorsAvailabilityWindowIdPatch>>, {windowId: string;data: AvailabilityWindowUpdate}> = (props) => {
          const {windowId,data} = props ?? {};

          return  updateAvailabilityWindowInstructorsAvailabilityWindowIdPatch(windowId,data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type UpdateAvailabilityWindowInstructorsAvailabilityWindowIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateAvailabilityWindowInstructorsAvailabilityWindowIdPatch>>>
    export type UpdateAvailabilityWindowInstructorsAvailabilityWindowIdPatchMutationBody = AvailabilityWindowUpdate
    export type UpdateAvailabilityWindowInstructorsAvailabilityWindowIdPatchMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Update Availability Window
 */
export const useUpdateAvailabilityWindowInstructorsAvailabilityWindowIdPatch = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateAvailabilityWindowInstructorsAvailabilityWindowIdPatch>>, TError,{windowId: string;data: AvailabilityWindowUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateAvailabilityWindowInstructorsAvailabilityWindowIdPatch>>,
        TError,
        {windowId: string;data: AvailabilityWindowUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateAvailabilityWindowInstructorsAvailabilityWindowIdPatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
