/**
 * Generated by orval v8.0.3 üç∫
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  AlertAcknowledgeResponse,
  AlertSummaryResponse,
  AvailabilityCacheMetricsResponse,
  CacheMetricsResponse,
  DatabaseHealthResponse,
  DatabasePoolStatusResponse,
  DatabaseStatsResponse,
  ExtendedCacheStats,
  GetAlertSummaryApiV1MonitoringAlertsSummaryGetParams,
  GetLiveAlertsApiV1MonitoringAlertsLiveGetParams,
  GetRecentAlertsApiV1MonitoringAlertsRecentGetParams,
  GetSlowQueriesApiV1MonitoringSlowQueriesGetParams,
  GetSlowRequestsApiV1MonitoringSlowRequestsGetParams,
  HTTPValidationError,
  HealthCheckResponse,
  LiveAlertsResponse,
  MonitoringDashboardResponse,
  PaymentHealthCheckTriggerResponse,
  PaymentHealthResponse,
  PerformanceMetricsResponse,
  RateLimitResetResponse,
  RateLimitStats,
  RateLimitTestResponse,
  RecentAlertsResponse,
  RedisCeleryQueuesResponse,
  RedisConnectionAuditResponse,
  RedisFlushQueuesResponse,
  RedisHealthResponse,
  RedisStatsResponse,
  RedisTestResponse,
  ResetRateLimitsApiV1OpsRateLimitsResetPostParams,
  SlowQueriesResponse,
  SlowRequestsResponse,
  SuccessResponse,
  TestRateLimitApiV1OpsRateLimitsTestGetParams,
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Simple database health check endpoint.

No authentication required - helps verify database connectivity.

Returns:
    Database connection status
 * @summary Database Health
 */
export const getDatabaseHealthApiV1DatabaseHealthGetUrl = () => {
  return `/api/v1/database/health`;
};

export const databaseHealthApiV1DatabaseHealthGet = async (
  options?: RequestInit
): Promise<DatabaseHealthResponse> => {
  return customFetch<DatabaseHealthResponse>(getDatabaseHealthApiV1DatabaseHealthGetUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getDatabaseHealthApiV1DatabaseHealthGetQueryKey = () => {
  return [`/api/v1/database/health`] as const;
};

export const getDatabaseHealthApiV1DatabaseHealthGetQueryOptions = <
  TData = Awaited<ReturnType<typeof databaseHealthApiV1DatabaseHealthGet>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof databaseHealthApiV1DatabaseHealthGet>>, TError, TData>
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDatabaseHealthApiV1DatabaseHealthGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof databaseHealthApiV1DatabaseHealthGet>>
  > = ({ signal }) => databaseHealthApiV1DatabaseHealthGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof databaseHealthApiV1DatabaseHealthGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DatabaseHealthApiV1DatabaseHealthGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof databaseHealthApiV1DatabaseHealthGet>>
>;
export type DatabaseHealthApiV1DatabaseHealthGetQueryError = ErrorType<void>;

export function useDatabaseHealthApiV1DatabaseHealthGet<
  TData = Awaited<ReturnType<typeof databaseHealthApiV1DatabaseHealthGet>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof databaseHealthApiV1DatabaseHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof databaseHealthApiV1DatabaseHealthGet>>,
          TError,
          Awaited<ReturnType<typeof databaseHealthApiV1DatabaseHealthGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDatabaseHealthApiV1DatabaseHealthGet<
  TData = Awaited<ReturnType<typeof databaseHealthApiV1DatabaseHealthGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof databaseHealthApiV1DatabaseHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof databaseHealthApiV1DatabaseHealthGet>>,
          TError,
          Awaited<ReturnType<typeof databaseHealthApiV1DatabaseHealthGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDatabaseHealthApiV1DatabaseHealthGet<
  TData = Awaited<ReturnType<typeof databaseHealthApiV1DatabaseHealthGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof databaseHealthApiV1DatabaseHealthGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Database Health
 */

export function useDatabaseHealthApiV1DatabaseHealthGet<
  TData = Awaited<ReturnType<typeof databaseHealthApiV1DatabaseHealthGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof databaseHealthApiV1DatabaseHealthGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getDatabaseHealthApiV1DatabaseHealthGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get detailed database connection pool statistics.

Requires ACCESS_MONITORING permission.

Returns:
    Connection pool metrics including:
    - Active connections
    - Available connections
    - Pool configuration
    - Usage percentage
 * @summary Database Pool Status
 */
export const getDatabasePoolStatusApiV1DatabasePoolStatusGetUrl = () => {
  return `/api/v1/database/pool-status`;
};

export const databasePoolStatusApiV1DatabasePoolStatusGet = async (
  options?: RequestInit
): Promise<DatabasePoolStatusResponse> => {
  return customFetch<DatabasePoolStatusResponse>(
    getDatabasePoolStatusApiV1DatabasePoolStatusGetUrl(),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getDatabasePoolStatusApiV1DatabasePoolStatusGetQueryKey = () => {
  return [`/api/v1/database/pool-status`] as const;
};

export const getDatabasePoolStatusApiV1DatabasePoolStatusGetQueryOptions = <
  TData = Awaited<ReturnType<typeof databasePoolStatusApiV1DatabasePoolStatusGet>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof databasePoolStatusApiV1DatabasePoolStatusGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getDatabasePoolStatusApiV1DatabasePoolStatusGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof databasePoolStatusApiV1DatabasePoolStatusGet>>
  > = ({ signal }) => databasePoolStatusApiV1DatabasePoolStatusGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof databasePoolStatusApiV1DatabasePoolStatusGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DatabasePoolStatusApiV1DatabasePoolStatusGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof databasePoolStatusApiV1DatabasePoolStatusGet>>
>;
export type DatabasePoolStatusApiV1DatabasePoolStatusGetQueryError = ErrorType<void>;

export function useDatabasePoolStatusApiV1DatabasePoolStatusGet<
  TData = Awaited<ReturnType<typeof databasePoolStatusApiV1DatabasePoolStatusGet>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof databasePoolStatusApiV1DatabasePoolStatusGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof databasePoolStatusApiV1DatabasePoolStatusGet>>,
          TError,
          Awaited<ReturnType<typeof databasePoolStatusApiV1DatabasePoolStatusGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDatabasePoolStatusApiV1DatabasePoolStatusGet<
  TData = Awaited<ReturnType<typeof databasePoolStatusApiV1DatabasePoolStatusGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof databasePoolStatusApiV1DatabasePoolStatusGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof databasePoolStatusApiV1DatabasePoolStatusGet>>,
          TError,
          Awaited<ReturnType<typeof databasePoolStatusApiV1DatabasePoolStatusGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDatabasePoolStatusApiV1DatabasePoolStatusGet<
  TData = Awaited<ReturnType<typeof databasePoolStatusApiV1DatabasePoolStatusGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof databasePoolStatusApiV1DatabasePoolStatusGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Database Pool Status
 */

export function useDatabasePoolStatusApiV1DatabasePoolStatusGet<
  TData = Awaited<ReturnType<typeof databasePoolStatusApiV1DatabasePoolStatusGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof databasePoolStatusApiV1DatabasePoolStatusGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getDatabasePoolStatusApiV1DatabasePoolStatusGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get comprehensive database statistics.

Requires ACCESS_MONITORING permission.

Returns:
    Database metrics including pool status and performance indicators
 * @summary Database Stats
 */
export const getDatabaseStatsApiV1DatabaseStatsGetUrl = () => {
  return `/api/v1/database/stats`;
};

export const databaseStatsApiV1DatabaseStatsGet = async (
  options?: RequestInit
): Promise<DatabaseStatsResponse> => {
  return customFetch<DatabaseStatsResponse>(getDatabaseStatsApiV1DatabaseStatsGetUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getDatabaseStatsApiV1DatabaseStatsGetQueryKey = () => {
  return [`/api/v1/database/stats`] as const;
};

export const getDatabaseStatsApiV1DatabaseStatsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof databaseStatsApiV1DatabaseStatsGet>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof databaseStatsApiV1DatabaseStatsGet>>, TError, TData>
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDatabaseStatsApiV1DatabaseStatsGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof databaseStatsApiV1DatabaseStatsGet>>> = ({
    signal,
  }) => databaseStatsApiV1DatabaseStatsGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof databaseStatsApiV1DatabaseStatsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DatabaseStatsApiV1DatabaseStatsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof databaseStatsApiV1DatabaseStatsGet>>
>;
export type DatabaseStatsApiV1DatabaseStatsGetQueryError = ErrorType<void>;

export function useDatabaseStatsApiV1DatabaseStatsGet<
  TData = Awaited<ReturnType<typeof databaseStatsApiV1DatabaseStatsGet>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof databaseStatsApiV1DatabaseStatsGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof databaseStatsApiV1DatabaseStatsGet>>,
          TError,
          Awaited<ReturnType<typeof databaseStatsApiV1DatabaseStatsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDatabaseStatsApiV1DatabaseStatsGet<
  TData = Awaited<ReturnType<typeof databaseStatsApiV1DatabaseStatsGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof databaseStatsApiV1DatabaseStatsGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof databaseStatsApiV1DatabaseStatsGet>>,
          TError,
          Awaited<ReturnType<typeof databaseStatsApiV1DatabaseStatsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDatabaseStatsApiV1DatabaseStatsGet<
  TData = Awaited<ReturnType<typeof databaseStatsApiV1DatabaseStatsGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof databaseStatsApiV1DatabaseStatsGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Database Stats
 */

export function useDatabaseStatsApiV1DatabaseStatsGet<
  TData = Awaited<ReturnType<typeof databaseStatsApiV1DatabaseStatsGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof databaseStatsApiV1DatabaseStatsGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getDatabaseStatsApiV1DatabaseStatsGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Acknowledge an alert to reset its cooldown.
 * @summary Acknowledge Alert
 */
export const getAcknowledgeAlertApiV1MonitoringAlertsAcknowledgeAlertTypePostUrl = (
  alertType: string
) => {
  return `/api/v1/monitoring/alerts/acknowledge/${alertType}`;
};

export const acknowledgeAlertApiV1MonitoringAlertsAcknowledgeAlertTypePost = async (
  alertType: string,
  options?: RequestInit
): Promise<AlertAcknowledgeResponse> => {
  return customFetch<AlertAcknowledgeResponse>(
    getAcknowledgeAlertApiV1MonitoringAlertsAcknowledgeAlertTypePostUrl(alertType),
    {
      ...options,
      method: 'POST',
    }
  );
};

export const getAcknowledgeAlertApiV1MonitoringAlertsAcknowledgeAlertTypePostMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof acknowledgeAlertApiV1MonitoringAlertsAcknowledgeAlertTypePost>>,
    TError,
    { alertType: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof acknowledgeAlertApiV1MonitoringAlertsAcknowledgeAlertTypePost>>,
  TError,
  { alertType: string },
  TContext
> => {
  const mutationKey = ['acknowledgeAlertApiV1MonitoringAlertsAcknowledgeAlertTypePost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof acknowledgeAlertApiV1MonitoringAlertsAcknowledgeAlertTypePost>>,
    { alertType: string }
  > = (props) => {
    const { alertType } = props ?? {};

    return acknowledgeAlertApiV1MonitoringAlertsAcknowledgeAlertTypePost(alertType, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AcknowledgeAlertApiV1MonitoringAlertsAcknowledgeAlertTypePostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof acknowledgeAlertApiV1MonitoringAlertsAcknowledgeAlertTypePost>>
  >;

export type AcknowledgeAlertApiV1MonitoringAlertsAcknowledgeAlertTypePostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Acknowledge Alert
 */
export const useAcknowledgeAlertApiV1MonitoringAlertsAcknowledgeAlertTypePost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof acknowledgeAlertApiV1MonitoringAlertsAcknowledgeAlertTypePost>>,
      TError,
      { alertType: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof acknowledgeAlertApiV1MonitoringAlertsAcknowledgeAlertTypePost>>,
  TError,
  { alertType: string },
  TContext
> => {
  return useMutation(
    getAcknowledgeAlertApiV1MonitoringAlertsAcknowledgeAlertTypePostMutationOptions(options),
    queryClient
  );
};
/**
 * Get very recent alerts (similar to live view).
 * @summary Get Live Alerts
 */
export const getGetLiveAlertsApiV1MonitoringAlertsLiveGetUrl = (
  params?: GetLiveAlertsApiV1MonitoringAlertsLiveGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/monitoring/alerts/live?${stringifiedParams}`
    : `/api/v1/monitoring/alerts/live`;
};

export const getLiveAlertsApiV1MonitoringAlertsLiveGet = async (
  params?: GetLiveAlertsApiV1MonitoringAlertsLiveGetParams,
  options?: RequestInit
): Promise<LiveAlertsResponse> => {
  return customFetch<LiveAlertsResponse>(getGetLiveAlertsApiV1MonitoringAlertsLiveGetUrl(params), {
    ...options,
    method: 'GET',
  });
};

export const getGetLiveAlertsApiV1MonitoringAlertsLiveGetQueryKey = (
  params?: GetLiveAlertsApiV1MonitoringAlertsLiveGetParams
) => {
  return [`/api/v1/monitoring/alerts/live`, ...(params ? [params] : [])] as const;
};

export const getGetLiveAlertsApiV1MonitoringAlertsLiveGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getLiveAlertsApiV1MonitoringAlertsLiveGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetLiveAlertsApiV1MonitoringAlertsLiveGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveAlertsApiV1MonitoringAlertsLiveGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetLiveAlertsApiV1MonitoringAlertsLiveGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getLiveAlertsApiV1MonitoringAlertsLiveGet>>
  > = ({ signal }) =>
    getLiveAlertsApiV1MonitoringAlertsLiveGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLiveAlertsApiV1MonitoringAlertsLiveGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetLiveAlertsApiV1MonitoringAlertsLiveGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLiveAlertsApiV1MonitoringAlertsLiveGet>>
>;
export type GetLiveAlertsApiV1MonitoringAlertsLiveGetQueryError = ErrorType<HTTPValidationError>;

export function useGetLiveAlertsApiV1MonitoringAlertsLiveGet<
  TData = Awaited<ReturnType<typeof getLiveAlertsApiV1MonitoringAlertsLiveGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: undefined | GetLiveAlertsApiV1MonitoringAlertsLiveGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveAlertsApiV1MonitoringAlertsLiveGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLiveAlertsApiV1MonitoringAlertsLiveGet>>,
          TError,
          Awaited<ReturnType<typeof getLiveAlertsApiV1MonitoringAlertsLiveGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetLiveAlertsApiV1MonitoringAlertsLiveGet<
  TData = Awaited<ReturnType<typeof getLiveAlertsApiV1MonitoringAlertsLiveGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetLiveAlertsApiV1MonitoringAlertsLiveGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveAlertsApiV1MonitoringAlertsLiveGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLiveAlertsApiV1MonitoringAlertsLiveGet>>,
          TError,
          Awaited<ReturnType<typeof getLiveAlertsApiV1MonitoringAlertsLiveGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetLiveAlertsApiV1MonitoringAlertsLiveGet<
  TData = Awaited<ReturnType<typeof getLiveAlertsApiV1MonitoringAlertsLiveGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetLiveAlertsApiV1MonitoringAlertsLiveGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveAlertsApiV1MonitoringAlertsLiveGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Live Alerts
 */

export function useGetLiveAlertsApiV1MonitoringAlertsLiveGet<
  TData = Awaited<ReturnType<typeof getLiveAlertsApiV1MonitoringAlertsLiveGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetLiveAlertsApiV1MonitoringAlertsLiveGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getLiveAlertsApiV1MonitoringAlertsLiveGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetLiveAlertsApiV1MonitoringAlertsLiveGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get recent alerts from the database.
 * @summary Get Recent Alerts
 */
export const getGetRecentAlertsApiV1MonitoringAlertsRecentGetUrl = (
  params?: GetRecentAlertsApiV1MonitoringAlertsRecentGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/monitoring/alerts/recent?${stringifiedParams}`
    : `/api/v1/monitoring/alerts/recent`;
};

export const getRecentAlertsApiV1MonitoringAlertsRecentGet = async (
  params?: GetRecentAlertsApiV1MonitoringAlertsRecentGetParams,
  options?: RequestInit
): Promise<RecentAlertsResponse> => {
  return customFetch<RecentAlertsResponse>(
    getGetRecentAlertsApiV1MonitoringAlertsRecentGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetRecentAlertsApiV1MonitoringAlertsRecentGetQueryKey = (
  params?: GetRecentAlertsApiV1MonitoringAlertsRecentGetParams
) => {
  return [`/api/v1/monitoring/alerts/recent`, ...(params ? [params] : [])] as const;
};

export const getGetRecentAlertsApiV1MonitoringAlertsRecentGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getRecentAlertsApiV1MonitoringAlertsRecentGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetRecentAlertsApiV1MonitoringAlertsRecentGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentAlertsApiV1MonitoringAlertsRecentGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetRecentAlertsApiV1MonitoringAlertsRecentGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRecentAlertsApiV1MonitoringAlertsRecentGet>>
  > = ({ signal }) =>
    getRecentAlertsApiV1MonitoringAlertsRecentGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRecentAlertsApiV1MonitoringAlertsRecentGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRecentAlertsApiV1MonitoringAlertsRecentGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRecentAlertsApiV1MonitoringAlertsRecentGet>>
>;
export type GetRecentAlertsApiV1MonitoringAlertsRecentGetQueryError =
  ErrorType<HTTPValidationError>;

export function useGetRecentAlertsApiV1MonitoringAlertsRecentGet<
  TData = Awaited<ReturnType<typeof getRecentAlertsApiV1MonitoringAlertsRecentGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: undefined | GetRecentAlertsApiV1MonitoringAlertsRecentGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentAlertsApiV1MonitoringAlertsRecentGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecentAlertsApiV1MonitoringAlertsRecentGet>>,
          TError,
          Awaited<ReturnType<typeof getRecentAlertsApiV1MonitoringAlertsRecentGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetRecentAlertsApiV1MonitoringAlertsRecentGet<
  TData = Awaited<ReturnType<typeof getRecentAlertsApiV1MonitoringAlertsRecentGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetRecentAlertsApiV1MonitoringAlertsRecentGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentAlertsApiV1MonitoringAlertsRecentGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRecentAlertsApiV1MonitoringAlertsRecentGet>>,
          TError,
          Awaited<ReturnType<typeof getRecentAlertsApiV1MonitoringAlertsRecentGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetRecentAlertsApiV1MonitoringAlertsRecentGet<
  TData = Awaited<ReturnType<typeof getRecentAlertsApiV1MonitoringAlertsRecentGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetRecentAlertsApiV1MonitoringAlertsRecentGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentAlertsApiV1MonitoringAlertsRecentGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Recent Alerts
 */

export function useGetRecentAlertsApiV1MonitoringAlertsRecentGet<
  TData = Awaited<ReturnType<typeof getRecentAlertsApiV1MonitoringAlertsRecentGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetRecentAlertsApiV1MonitoringAlertsRecentGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRecentAlertsApiV1MonitoringAlertsRecentGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetRecentAlertsApiV1MonitoringAlertsRecentGetQueryOptions(
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get alert summary statistics.
 * @summary Get Alert Summary
 */
export const getGetAlertSummaryApiV1MonitoringAlertsSummaryGetUrl = (
  params?: GetAlertSummaryApiV1MonitoringAlertsSummaryGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/monitoring/alerts/summary?${stringifiedParams}`
    : `/api/v1/monitoring/alerts/summary`;
};

export const getAlertSummaryApiV1MonitoringAlertsSummaryGet = async (
  params?: GetAlertSummaryApiV1MonitoringAlertsSummaryGetParams,
  options?: RequestInit
): Promise<AlertSummaryResponse> => {
  return customFetch<AlertSummaryResponse>(
    getGetAlertSummaryApiV1MonitoringAlertsSummaryGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetAlertSummaryApiV1MonitoringAlertsSummaryGetQueryKey = (
  params?: GetAlertSummaryApiV1MonitoringAlertsSummaryGetParams
) => {
  return [`/api/v1/monitoring/alerts/summary`, ...(params ? [params] : [])] as const;
};

export const getGetAlertSummaryApiV1MonitoringAlertsSummaryGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAlertSummaryApiV1MonitoringAlertsSummaryGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetAlertSummaryApiV1MonitoringAlertsSummaryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAlertSummaryApiV1MonitoringAlertsSummaryGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAlertSummaryApiV1MonitoringAlertsSummaryGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAlertSummaryApiV1MonitoringAlertsSummaryGet>>
  > = ({ signal }) =>
    getAlertSummaryApiV1MonitoringAlertsSummaryGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAlertSummaryApiV1MonitoringAlertsSummaryGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAlertSummaryApiV1MonitoringAlertsSummaryGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAlertSummaryApiV1MonitoringAlertsSummaryGet>>
>;
export type GetAlertSummaryApiV1MonitoringAlertsSummaryGetQueryError =
  ErrorType<HTTPValidationError>;

export function useGetAlertSummaryApiV1MonitoringAlertsSummaryGet<
  TData = Awaited<ReturnType<typeof getAlertSummaryApiV1MonitoringAlertsSummaryGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: undefined | GetAlertSummaryApiV1MonitoringAlertsSummaryGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAlertSummaryApiV1MonitoringAlertsSummaryGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAlertSummaryApiV1MonitoringAlertsSummaryGet>>,
          TError,
          Awaited<ReturnType<typeof getAlertSummaryApiV1MonitoringAlertsSummaryGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAlertSummaryApiV1MonitoringAlertsSummaryGet<
  TData = Awaited<ReturnType<typeof getAlertSummaryApiV1MonitoringAlertsSummaryGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetAlertSummaryApiV1MonitoringAlertsSummaryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAlertSummaryApiV1MonitoringAlertsSummaryGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAlertSummaryApiV1MonitoringAlertsSummaryGet>>,
          TError,
          Awaited<ReturnType<typeof getAlertSummaryApiV1MonitoringAlertsSummaryGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAlertSummaryApiV1MonitoringAlertsSummaryGet<
  TData = Awaited<ReturnType<typeof getAlertSummaryApiV1MonitoringAlertsSummaryGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetAlertSummaryApiV1MonitoringAlertsSummaryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAlertSummaryApiV1MonitoringAlertsSummaryGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Alert Summary
 */

export function useGetAlertSummaryApiV1MonitoringAlertsSummaryGet<
  TData = Awaited<ReturnType<typeof getAlertSummaryApiV1MonitoringAlertsSummaryGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetAlertSummaryApiV1MonitoringAlertsSummaryGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAlertSummaryApiV1MonitoringAlertsSummaryGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetAlertSummaryApiV1MonitoringAlertsSummaryGetQueryOptions(
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get extended cache statistics.
 * @summary Get Extended Cache Stats
 */
export const getGetExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGetUrl = () => {
  return `/api/v1/monitoring/cache/extended-stats`;
};

export const getExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet = async (
  options?: RequestInit
): Promise<ExtendedCacheStats> => {
  return customFetch<ExtendedCacheStats>(
    getGetExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGetUrl(),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGetQueryKey = () => {
  return [`/api/v1/monitoring/cache/extended-stats`] as const;
};

export const getGetExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet>>
  > = ({ signal }) =>
    getExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet>>
>;
export type GetExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGetQueryError =
  ErrorType<void | HTTPValidationError>;

export function useGetExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet<
  TData = Awaited<ReturnType<typeof getExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet>>,
          TError,
          Awaited<ReturnType<typeof getExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet<
  TData = Awaited<ReturnType<typeof getExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet>>,
          TError,
          Awaited<ReturnType<typeof getExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet<
  TData = Awaited<ReturnType<typeof getExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Extended Cache Stats
 */

export function useGetExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet<
  TData = Awaited<ReturnType<typeof getExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions =
    getGetExtendedCacheStatsApiV1MonitoringCacheExtendedStatsGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get comprehensive monitoring dashboard data.

Requires monitoring API key in production.
 * @summary Get Monitoring Dashboard
 */
export const getGetMonitoringDashboardApiV1MonitoringDashboardGetUrl = () => {
  return `/api/v1/monitoring/dashboard`;
};

export const getMonitoringDashboardApiV1MonitoringDashboardGet = async (
  options?: RequestInit
): Promise<MonitoringDashboardResponse> => {
  return customFetch<MonitoringDashboardResponse>(
    getGetMonitoringDashboardApiV1MonitoringDashboardGetUrl(),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetMonitoringDashboardApiV1MonitoringDashboardGetQueryKey = () => {
  return [`/api/v1/monitoring/dashboard`] as const;
};

export const getGetMonitoringDashboardApiV1MonitoringDashboardGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getMonitoringDashboardApiV1MonitoringDashboardGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getMonitoringDashboardApiV1MonitoringDashboardGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMonitoringDashboardApiV1MonitoringDashboardGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMonitoringDashboardApiV1MonitoringDashboardGet>>
  > = ({ signal }) =>
    getMonitoringDashboardApiV1MonitoringDashboardGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMonitoringDashboardApiV1MonitoringDashboardGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMonitoringDashboardApiV1MonitoringDashboardGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMonitoringDashboardApiV1MonitoringDashboardGet>>
>;
export type GetMonitoringDashboardApiV1MonitoringDashboardGetQueryError =
  ErrorType<void | HTTPValidationError>;

export function useGetMonitoringDashboardApiV1MonitoringDashboardGet<
  TData = Awaited<ReturnType<typeof getMonitoringDashboardApiV1MonitoringDashboardGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMonitoringDashboardApiV1MonitoringDashboardGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonitoringDashboardApiV1MonitoringDashboardGet>>,
          TError,
          Awaited<ReturnType<typeof getMonitoringDashboardApiV1MonitoringDashboardGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonitoringDashboardApiV1MonitoringDashboardGet<
  TData = Awaited<ReturnType<typeof getMonitoringDashboardApiV1MonitoringDashboardGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMonitoringDashboardApiV1MonitoringDashboardGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMonitoringDashboardApiV1MonitoringDashboardGet>>,
          TError,
          Awaited<ReturnType<typeof getMonitoringDashboardApiV1MonitoringDashboardGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMonitoringDashboardApiV1MonitoringDashboardGet<
  TData = Awaited<ReturnType<typeof getMonitoringDashboardApiV1MonitoringDashboardGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMonitoringDashboardApiV1MonitoringDashboardGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Monitoring Dashboard
 */

export function useGetMonitoringDashboardApiV1MonitoringDashboardGet<
  TData = Awaited<ReturnType<typeof getMonitoringDashboardApiV1MonitoringDashboardGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMonitoringDashboardApiV1MonitoringDashboardGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMonitoringDashboardApiV1MonitoringDashboardGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get payment system health metrics.

Returns metrics about:
- Pending authorizations
- Failed authorizations
- Recent processing activity
- System alerts

Requires monitoring API key in production.
 * @summary Get Payment System Health
 */
export const getGetPaymentSystemHealthApiV1MonitoringPaymentHealthGetUrl = () => {
  return `/api/v1/monitoring/payment-health`;
};

export const getPaymentSystemHealthApiV1MonitoringPaymentHealthGet = async (
  options?: RequestInit
): Promise<PaymentHealthResponse> => {
  return customFetch<PaymentHealthResponse>(
    getGetPaymentSystemHealthApiV1MonitoringPaymentHealthGetUrl(),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetPaymentSystemHealthApiV1MonitoringPaymentHealthGetQueryKey = () => {
  return [`/api/v1/monitoring/payment-health`] as const;
};

export const getGetPaymentSystemHealthApiV1MonitoringPaymentHealthGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getPaymentSystemHealthApiV1MonitoringPaymentHealthGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getPaymentSystemHealthApiV1MonitoringPaymentHealthGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetPaymentSystemHealthApiV1MonitoringPaymentHealthGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPaymentSystemHealthApiV1MonitoringPaymentHealthGet>>
  > = ({ signal }) =>
    getPaymentSystemHealthApiV1MonitoringPaymentHealthGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPaymentSystemHealthApiV1MonitoringPaymentHealthGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPaymentSystemHealthApiV1MonitoringPaymentHealthGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPaymentSystemHealthApiV1MonitoringPaymentHealthGet>>
>;
export type GetPaymentSystemHealthApiV1MonitoringPaymentHealthGetQueryError =
  ErrorType<void | HTTPValidationError>;

export function useGetPaymentSystemHealthApiV1MonitoringPaymentHealthGet<
  TData = Awaited<ReturnType<typeof getPaymentSystemHealthApiV1MonitoringPaymentHealthGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPaymentSystemHealthApiV1MonitoringPaymentHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaymentSystemHealthApiV1MonitoringPaymentHealthGet>>,
          TError,
          Awaited<ReturnType<typeof getPaymentSystemHealthApiV1MonitoringPaymentHealthGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPaymentSystemHealthApiV1MonitoringPaymentHealthGet<
  TData = Awaited<ReturnType<typeof getPaymentSystemHealthApiV1MonitoringPaymentHealthGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPaymentSystemHealthApiV1MonitoringPaymentHealthGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPaymentSystemHealthApiV1MonitoringPaymentHealthGet>>,
          TError,
          Awaited<ReturnType<typeof getPaymentSystemHealthApiV1MonitoringPaymentHealthGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPaymentSystemHealthApiV1MonitoringPaymentHealthGet<
  TData = Awaited<ReturnType<typeof getPaymentSystemHealthApiV1MonitoringPaymentHealthGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPaymentSystemHealthApiV1MonitoringPaymentHealthGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Payment System Health
 */

export function useGetPaymentSystemHealthApiV1MonitoringPaymentHealthGet<
  TData = Awaited<ReturnType<typeof getPaymentSystemHealthApiV1MonitoringPaymentHealthGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPaymentSystemHealthApiV1MonitoringPaymentHealthGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions =
    getGetPaymentSystemHealthApiV1MonitoringPaymentHealthGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get recent slow queries.
 * @summary Get Slow Queries
 */
export const getGetSlowQueriesApiV1MonitoringSlowQueriesGetUrl = (
  params?: GetSlowQueriesApiV1MonitoringSlowQueriesGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/monitoring/slow-queries?${stringifiedParams}`
    : `/api/v1/monitoring/slow-queries`;
};

export const getSlowQueriesApiV1MonitoringSlowQueriesGet = async (
  params?: GetSlowQueriesApiV1MonitoringSlowQueriesGetParams,
  options?: RequestInit
): Promise<SlowQueriesResponse> => {
  return customFetch<SlowQueriesResponse>(
    getGetSlowQueriesApiV1MonitoringSlowQueriesGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetSlowQueriesApiV1MonitoringSlowQueriesGetQueryKey = (
  params?: GetSlowQueriesApiV1MonitoringSlowQueriesGetParams
) => {
  return [`/api/v1/monitoring/slow-queries`, ...(params ? [params] : [])] as const;
};

export const getGetSlowQueriesApiV1MonitoringSlowQueriesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getSlowQueriesApiV1MonitoringSlowQueriesGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params?: GetSlowQueriesApiV1MonitoringSlowQueriesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSlowQueriesApiV1MonitoringSlowQueriesGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSlowQueriesApiV1MonitoringSlowQueriesGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSlowQueriesApiV1MonitoringSlowQueriesGet>>
  > = ({ signal }) =>
    getSlowQueriesApiV1MonitoringSlowQueriesGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSlowQueriesApiV1MonitoringSlowQueriesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSlowQueriesApiV1MonitoringSlowQueriesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSlowQueriesApiV1MonitoringSlowQueriesGet>>
>;
export type GetSlowQueriesApiV1MonitoringSlowQueriesGetQueryError =
  ErrorType<void | HTTPValidationError>;

export function useGetSlowQueriesApiV1MonitoringSlowQueriesGet<
  TData = Awaited<ReturnType<typeof getSlowQueriesApiV1MonitoringSlowQueriesGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params: undefined | GetSlowQueriesApiV1MonitoringSlowQueriesGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSlowQueriesApiV1MonitoringSlowQueriesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSlowQueriesApiV1MonitoringSlowQueriesGet>>,
          TError,
          Awaited<ReturnType<typeof getSlowQueriesApiV1MonitoringSlowQueriesGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSlowQueriesApiV1MonitoringSlowQueriesGet<
  TData = Awaited<ReturnType<typeof getSlowQueriesApiV1MonitoringSlowQueriesGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params?: GetSlowQueriesApiV1MonitoringSlowQueriesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSlowQueriesApiV1MonitoringSlowQueriesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSlowQueriesApiV1MonitoringSlowQueriesGet>>,
          TError,
          Awaited<ReturnType<typeof getSlowQueriesApiV1MonitoringSlowQueriesGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSlowQueriesApiV1MonitoringSlowQueriesGet<
  TData = Awaited<ReturnType<typeof getSlowQueriesApiV1MonitoringSlowQueriesGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params?: GetSlowQueriesApiV1MonitoringSlowQueriesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSlowQueriesApiV1MonitoringSlowQueriesGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Slow Queries
 */

export function useGetSlowQueriesApiV1MonitoringSlowQueriesGet<
  TData = Awaited<ReturnType<typeof getSlowQueriesApiV1MonitoringSlowQueriesGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params?: GetSlowQueriesApiV1MonitoringSlowQueriesGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSlowQueriesApiV1MonitoringSlowQueriesGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSlowQueriesApiV1MonitoringSlowQueriesGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get recent slow requests.
 * @summary Get Slow Requests
 */
export const getGetSlowRequestsApiV1MonitoringSlowRequestsGetUrl = (
  params?: GetSlowRequestsApiV1MonitoringSlowRequestsGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/monitoring/slow-requests?${stringifiedParams}`
    : `/api/v1/monitoring/slow-requests`;
};

export const getSlowRequestsApiV1MonitoringSlowRequestsGet = async (
  params?: GetSlowRequestsApiV1MonitoringSlowRequestsGetParams,
  options?: RequestInit
): Promise<SlowRequestsResponse> => {
  return customFetch<SlowRequestsResponse>(
    getGetSlowRequestsApiV1MonitoringSlowRequestsGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetSlowRequestsApiV1MonitoringSlowRequestsGetQueryKey = (
  params?: GetSlowRequestsApiV1MonitoringSlowRequestsGetParams
) => {
  return [`/api/v1/monitoring/slow-requests`, ...(params ? [params] : [])] as const;
};

export const getGetSlowRequestsApiV1MonitoringSlowRequestsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getSlowRequestsApiV1MonitoringSlowRequestsGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params?: GetSlowRequestsApiV1MonitoringSlowRequestsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSlowRequestsApiV1MonitoringSlowRequestsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetSlowRequestsApiV1MonitoringSlowRequestsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSlowRequestsApiV1MonitoringSlowRequestsGet>>
  > = ({ signal }) =>
    getSlowRequestsApiV1MonitoringSlowRequestsGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSlowRequestsApiV1MonitoringSlowRequestsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSlowRequestsApiV1MonitoringSlowRequestsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSlowRequestsApiV1MonitoringSlowRequestsGet>>
>;
export type GetSlowRequestsApiV1MonitoringSlowRequestsGetQueryError =
  ErrorType<void | HTTPValidationError>;

export function useGetSlowRequestsApiV1MonitoringSlowRequestsGet<
  TData = Awaited<ReturnType<typeof getSlowRequestsApiV1MonitoringSlowRequestsGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params: undefined | GetSlowRequestsApiV1MonitoringSlowRequestsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSlowRequestsApiV1MonitoringSlowRequestsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSlowRequestsApiV1MonitoringSlowRequestsGet>>,
          TError,
          Awaited<ReturnType<typeof getSlowRequestsApiV1MonitoringSlowRequestsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSlowRequestsApiV1MonitoringSlowRequestsGet<
  TData = Awaited<ReturnType<typeof getSlowRequestsApiV1MonitoringSlowRequestsGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params?: GetSlowRequestsApiV1MonitoringSlowRequestsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSlowRequestsApiV1MonitoringSlowRequestsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSlowRequestsApiV1MonitoringSlowRequestsGet>>,
          TError,
          Awaited<ReturnType<typeof getSlowRequestsApiV1MonitoringSlowRequestsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSlowRequestsApiV1MonitoringSlowRequestsGet<
  TData = Awaited<ReturnType<typeof getSlowRequestsApiV1MonitoringSlowRequestsGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params?: GetSlowRequestsApiV1MonitoringSlowRequestsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSlowRequestsApiV1MonitoringSlowRequestsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Slow Requests
 */

export function useGetSlowRequestsApiV1MonitoringSlowRequestsGet<
  TData = Awaited<ReturnType<typeof getSlowRequestsApiV1MonitoringSlowRequestsGet>>,
  TError = ErrorType<void | HTTPValidationError>,
>(
  params?: GetSlowRequestsApiV1MonitoringSlowRequestsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSlowRequestsApiV1MonitoringSlowRequestsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSlowRequestsApiV1MonitoringSlowRequestsGetQueryOptions(
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Manually trigger a payment system health check.

This will run the health check task immediately and return the results.

Requires monitoring API key in production.
 * @summary Trigger Payment Health Check
 */
export const getTriggerPaymentHealthCheckApiV1MonitoringTriggerPaymentHealthCheckPostUrl = () => {
  return `/api/v1/monitoring/trigger-payment-health-check`;
};

export const triggerPaymentHealthCheckApiV1MonitoringTriggerPaymentHealthCheckPost = async (
  options?: RequestInit
): Promise<PaymentHealthCheckTriggerResponse> => {
  return customFetch<PaymentHealthCheckTriggerResponse>(
    getTriggerPaymentHealthCheckApiV1MonitoringTriggerPaymentHealthCheckPostUrl(),
    {
      ...options,
      method: 'POST',
    }
  );
};

export const getTriggerPaymentHealthCheckApiV1MonitoringTriggerPaymentHealthCheckPostMutationOptions =
  <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof triggerPaymentHealthCheckApiV1MonitoringTriggerPaymentHealthCheckPost>
      >,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof triggerPaymentHealthCheckApiV1MonitoringTriggerPaymentHealthCheckPost>
    >,
    TError,
    void,
    TContext
  > => {
    const mutationKey = ['triggerPaymentHealthCheckApiV1MonitoringTriggerPaymentHealthCheckPost'];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof triggerPaymentHealthCheckApiV1MonitoringTriggerPaymentHealthCheckPost>
      >,
      void
    > = () => {
      return triggerPaymentHealthCheckApiV1MonitoringTriggerPaymentHealthCheckPost(requestOptions);
    };

    return { mutationFn, ...mutationOptions };
  };

export type TriggerPaymentHealthCheckApiV1MonitoringTriggerPaymentHealthCheckPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof triggerPaymentHealthCheckApiV1MonitoringTriggerPaymentHealthCheckPost>
    >
  >;

export type TriggerPaymentHealthCheckApiV1MonitoringTriggerPaymentHealthCheckPostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Trigger Payment Health Check
 */
export const useTriggerPaymentHealthCheckApiV1MonitoringTriggerPaymentHealthCheckPost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof triggerPaymentHealthCheckApiV1MonitoringTriggerPaymentHealthCheckPost>
      >,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof triggerPaymentHealthCheckApiV1MonitoringTriggerPaymentHealthCheckPost>>,
  TError,
  void,
  TContext
> => {
  return useMutation(
    getTriggerPaymentHealthCheckApiV1MonitoringTriggerPaymentHealthCheckPostMutationOptions(
      options
    ),
    queryClient
  );
};
/**
 * Get detailed cache metrics including availability-specific stats.
 * @summary Get Cache Metrics
 */
export const getGetCacheMetricsApiV1OpsCacheGetUrl = () => {
  return `/api/v1/ops/cache`;
};

export const getCacheMetricsApiV1OpsCacheGet = async (
  options?: RequestInit
): Promise<CacheMetricsResponse> => {
  return customFetch<CacheMetricsResponse>(getGetCacheMetricsApiV1OpsCacheGetUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getGetCacheMetricsApiV1OpsCacheGetQueryKey = () => {
  return [`/api/v1/ops/cache`] as const;
};

export const getGetCacheMetricsApiV1OpsCacheGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getCacheMetricsApiV1OpsCacheGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getCacheMetricsApiV1OpsCacheGet>>, TError, TData>
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCacheMetricsApiV1OpsCacheGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCacheMetricsApiV1OpsCacheGet>>> = ({
    signal,
  }) => getCacheMetricsApiV1OpsCacheGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCacheMetricsApiV1OpsCacheGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCacheMetricsApiV1OpsCacheGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCacheMetricsApiV1OpsCacheGet>>
>;
export type GetCacheMetricsApiV1OpsCacheGetQueryError = ErrorType<unknown>;

export function useGetCacheMetricsApiV1OpsCacheGet<
  TData = Awaited<ReturnType<typeof getCacheMetricsApiV1OpsCacheGet>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCacheMetricsApiV1OpsCacheGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCacheMetricsApiV1OpsCacheGet>>,
          TError,
          Awaited<ReturnType<typeof getCacheMetricsApiV1OpsCacheGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCacheMetricsApiV1OpsCacheGet<
  TData = Awaited<ReturnType<typeof getCacheMetricsApiV1OpsCacheGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCacheMetricsApiV1OpsCacheGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCacheMetricsApiV1OpsCacheGet>>,
          TError,
          Awaited<ReturnType<typeof getCacheMetricsApiV1OpsCacheGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCacheMetricsApiV1OpsCacheGet<
  TData = Awaited<ReturnType<typeof getCacheMetricsApiV1OpsCacheGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCacheMetricsApiV1OpsCacheGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Cache Metrics
 */

export function useGetCacheMetricsApiV1OpsCacheGet<
  TData = Awaited<ReturnType<typeof getCacheMetricsApiV1OpsCacheGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCacheMetricsApiV1OpsCacheGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCacheMetricsApiV1OpsCacheGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get detailed availability-specific cache metrics and top cached keys.
 * @summary Get Availability Cache Metrics
 */
export const getGetAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGetUrl = () => {
  return `/api/v1/ops/cache/availability`;
};

export const getAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet = async (
  options?: RequestInit
): Promise<AvailabilityCacheMetricsResponse> => {
  return customFetch<AvailabilityCacheMetricsResponse>(
    getGetAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGetUrl(),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGetQueryKey = () => {
  return [`/api/v1/ops/cache/availability`] as const;
};

export const getGetAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet>>
  > = ({ signal }) =>
    getAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet>>
>;
export type GetAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGetQueryError = ErrorType<unknown>;

export function useGetAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet<
  TData = Awaited<ReturnType<typeof getAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet>>,
          TError,
          Awaited<ReturnType<typeof getAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet<
  TData = Awaited<ReturnType<typeof getAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet>>,
          TError,
          Awaited<ReturnType<typeof getAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet<
  TData = Awaited<ReturnType<typeof getAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Availability Cache Metrics
 */

export function useGetAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet<
  TData = Awaited<ReturnType<typeof getAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions =
    getGetAvailabilityCacheMetricsApiV1OpsCacheAvailabilityGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Reset cache statistics.
 * @summary Reset Cache Stats
 */
export const getResetCacheStatsApiV1OpsCacheResetStatsPostUrl = () => {
  return `/api/v1/ops/cache/reset-stats`;
};

export const resetCacheStatsApiV1OpsCacheResetStatsPost = async (
  options?: RequestInit
): Promise<SuccessResponse> => {
  return customFetch<SuccessResponse>(getResetCacheStatsApiV1OpsCacheResetStatsPostUrl(), {
    ...options,
    method: 'POST',
  });
};

export const getResetCacheStatsApiV1OpsCacheResetStatsPostMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resetCacheStatsApiV1OpsCacheResetStatsPost>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof resetCacheStatsApiV1OpsCacheResetStatsPost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['resetCacheStatsApiV1OpsCacheResetStatsPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resetCacheStatsApiV1OpsCacheResetStatsPost>>,
    void
  > = () => {
    return resetCacheStatsApiV1OpsCacheResetStatsPost(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ResetCacheStatsApiV1OpsCacheResetStatsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof resetCacheStatsApiV1OpsCacheResetStatsPost>>
>;

export type ResetCacheStatsApiV1OpsCacheResetStatsPostMutationError = ErrorType<unknown>;

/**
 * @summary Reset Cache Stats
 */
export const useResetCacheStatsApiV1OpsCacheResetStatsPost = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof resetCacheStatsApiV1OpsCacheResetStatsPost>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof resetCacheStatsApiV1OpsCacheResetStatsPost>>,
  TError,
  void,
  TContext
> => {
  return useMutation(
    getResetCacheStatsApiV1OpsCacheResetStatsPostMutationOptions(options),
    queryClient
  );
};
/**
 * Basic health check endpoint.
 * @summary Health Check
 */
export const getHealthCheckApiV1OpsHealthGetUrl = () => {
  return `/api/v1/ops/health`;
};

export const healthCheckApiV1OpsHealthGet = async (
  options?: RequestInit
): Promise<HealthCheckResponse> => {
  return customFetch<HealthCheckResponse>(getHealthCheckApiV1OpsHealthGetUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getHealthCheckApiV1OpsHealthGetQueryKey = () => {
  return [`/api/v1/ops/health`] as const;
};

export const getHealthCheckApiV1OpsHealthGetQueryOptions = <
  TData = Awaited<ReturnType<typeof healthCheckApiV1OpsHealthGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthCheckApiV1OpsHealthGet>>, TError, TData>
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthCheckApiV1OpsHealthGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheckApiV1OpsHealthGet>>> = ({
    signal,
  }) => healthCheckApiV1OpsHealthGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthCheckApiV1OpsHealthGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthCheckApiV1OpsHealthGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthCheckApiV1OpsHealthGet>>
>;
export type HealthCheckApiV1OpsHealthGetQueryError = ErrorType<unknown>;

export function useHealthCheckApiV1OpsHealthGet<
  TData = Awaited<ReturnType<typeof healthCheckApiV1OpsHealthGet>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheckApiV1OpsHealthGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckApiV1OpsHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckApiV1OpsHealthGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useHealthCheckApiV1OpsHealthGet<
  TData = Awaited<ReturnType<typeof healthCheckApiV1OpsHealthGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheckApiV1OpsHealthGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckApiV1OpsHealthGet>>,
          TError,
          Awaited<ReturnType<typeof healthCheckApiV1OpsHealthGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useHealthCheckApiV1OpsHealthGet<
  TData = Awaited<ReturnType<typeof healthCheckApiV1OpsHealthGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheckApiV1OpsHealthGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Health Check
 */

export function useHealthCheckApiV1OpsHealthGet<
  TData = Awaited<ReturnType<typeof healthCheckApiV1OpsHealthGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheckApiV1OpsHealthGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getHealthCheckApiV1OpsHealthGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get performance metrics from all services.
 * @summary Get Performance Metrics
 */
export const getGetPerformanceMetricsApiV1OpsPerformanceGetUrl = () => {
  return `/api/v1/ops/performance`;
};

export const getPerformanceMetricsApiV1OpsPerformanceGet = async (
  options?: RequestInit
): Promise<PerformanceMetricsResponse> => {
  return customFetch<PerformanceMetricsResponse>(
    getGetPerformanceMetricsApiV1OpsPerformanceGetUrl(),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetPerformanceMetricsApiV1OpsPerformanceGetQueryKey = () => {
  return [`/api/v1/ops/performance`] as const;
};

export const getGetPerformanceMetricsApiV1OpsPerformanceGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getPerformanceMetricsApiV1OpsPerformanceGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getPerformanceMetricsApiV1OpsPerformanceGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetPerformanceMetricsApiV1OpsPerformanceGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPerformanceMetricsApiV1OpsPerformanceGet>>
  > = ({ signal }) => getPerformanceMetricsApiV1OpsPerformanceGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPerformanceMetricsApiV1OpsPerformanceGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPerformanceMetricsApiV1OpsPerformanceGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPerformanceMetricsApiV1OpsPerformanceGet>>
>;
export type GetPerformanceMetricsApiV1OpsPerformanceGetQueryError = ErrorType<unknown>;

export function useGetPerformanceMetricsApiV1OpsPerformanceGet<
  TData = Awaited<ReturnType<typeof getPerformanceMetricsApiV1OpsPerformanceGet>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPerformanceMetricsApiV1OpsPerformanceGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPerformanceMetricsApiV1OpsPerformanceGet>>,
          TError,
          Awaited<ReturnType<typeof getPerformanceMetricsApiV1OpsPerformanceGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPerformanceMetricsApiV1OpsPerformanceGet<
  TData = Awaited<ReturnType<typeof getPerformanceMetricsApiV1OpsPerformanceGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPerformanceMetricsApiV1OpsPerformanceGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPerformanceMetricsApiV1OpsPerformanceGet>>,
          TError,
          Awaited<ReturnType<typeof getPerformanceMetricsApiV1OpsPerformanceGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPerformanceMetricsApiV1OpsPerformanceGet<
  TData = Awaited<ReturnType<typeof getPerformanceMetricsApiV1OpsPerformanceGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPerformanceMetricsApiV1OpsPerformanceGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Performance Metrics
 */

export function useGetPerformanceMetricsApiV1OpsPerformanceGet<
  TData = Awaited<ReturnType<typeof getPerformanceMetricsApiV1OpsPerformanceGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPerformanceMetricsApiV1OpsPerformanceGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPerformanceMetricsApiV1OpsPerformanceGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get current rate limit statistics.

Shows:
- Total rate limit keys
- Breakdown by endpoint/type
- Top limited clients

Requires authentication.
 * @summary Get Rate Limit Stats
 */
export const getGetRateLimitStatsApiV1OpsRateLimitsGetUrl = () => {
  return `/api/v1/ops/rate-limits`;
};

export const getRateLimitStatsApiV1OpsRateLimitsGet = async (
  options?: RequestInit
): Promise<RateLimitStats> => {
  return customFetch<RateLimitStats>(getGetRateLimitStatsApiV1OpsRateLimitsGetUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getGetRateLimitStatsApiV1OpsRateLimitsGetQueryKey = () => {
  return [`/api/v1/ops/rate-limits`] as const;
};

export const getGetRateLimitStatsApiV1OpsRateLimitsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getRateLimitStatsApiV1OpsRateLimitsGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getRateLimitStatsApiV1OpsRateLimitsGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRateLimitStatsApiV1OpsRateLimitsGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getRateLimitStatsApiV1OpsRateLimitsGet>>
  > = ({ signal }) => getRateLimitStatsApiV1OpsRateLimitsGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getRateLimitStatsApiV1OpsRateLimitsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetRateLimitStatsApiV1OpsRateLimitsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRateLimitStatsApiV1OpsRateLimitsGet>>
>;
export type GetRateLimitStatsApiV1OpsRateLimitsGetQueryError = ErrorType<unknown>;

export function useGetRateLimitStatsApiV1OpsRateLimitsGet<
  TData = Awaited<ReturnType<typeof getRateLimitStatsApiV1OpsRateLimitsGet>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRateLimitStatsApiV1OpsRateLimitsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRateLimitStatsApiV1OpsRateLimitsGet>>,
          TError,
          Awaited<ReturnType<typeof getRateLimitStatsApiV1OpsRateLimitsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetRateLimitStatsApiV1OpsRateLimitsGet<
  TData = Awaited<ReturnType<typeof getRateLimitStatsApiV1OpsRateLimitsGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRateLimitStatsApiV1OpsRateLimitsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getRateLimitStatsApiV1OpsRateLimitsGet>>,
          TError,
          Awaited<ReturnType<typeof getRateLimitStatsApiV1OpsRateLimitsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetRateLimitStatsApiV1OpsRateLimitsGet<
  TData = Awaited<ReturnType<typeof getRateLimitStatsApiV1OpsRateLimitsGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRateLimitStatsApiV1OpsRateLimitsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Rate Limit Stats
 */

export function useGetRateLimitStatsApiV1OpsRateLimitsGet<
  TData = Awaited<ReturnType<typeof getRateLimitStatsApiV1OpsRateLimitsGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getRateLimitStatsApiV1OpsRateLimitsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetRateLimitStatsApiV1OpsRateLimitsGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Reset rate limits matching a pattern.

Useful for:
- Unblocking legitimate users
- Testing
- Emergency response

Requires admin privileges.
 * @summary Reset Rate Limits
 */
export const getResetRateLimitsApiV1OpsRateLimitsResetPostUrl = (
  params: ResetRateLimitsApiV1OpsRateLimitsResetPostParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/ops/rate-limits/reset?${stringifiedParams}`
    : `/api/v1/ops/rate-limits/reset`;
};

export const resetRateLimitsApiV1OpsRateLimitsResetPost = async (
  params: ResetRateLimitsApiV1OpsRateLimitsResetPostParams,
  options?: RequestInit
): Promise<RateLimitResetResponse> => {
  return customFetch<RateLimitResetResponse>(
    getResetRateLimitsApiV1OpsRateLimitsResetPostUrl(params),
    {
      ...options,
      method: 'POST',
    }
  );
};

export const getResetRateLimitsApiV1OpsRateLimitsResetPostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resetRateLimitsApiV1OpsRateLimitsResetPost>>,
    TError,
    { params: ResetRateLimitsApiV1OpsRateLimitsResetPostParams },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof resetRateLimitsApiV1OpsRateLimitsResetPost>>,
  TError,
  { params: ResetRateLimitsApiV1OpsRateLimitsResetPostParams },
  TContext
> => {
  const mutationKey = ['resetRateLimitsApiV1OpsRateLimitsResetPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resetRateLimitsApiV1OpsRateLimitsResetPost>>,
    { params: ResetRateLimitsApiV1OpsRateLimitsResetPostParams }
  > = (props) => {
    const { params } = props ?? {};

    return resetRateLimitsApiV1OpsRateLimitsResetPost(params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ResetRateLimitsApiV1OpsRateLimitsResetPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof resetRateLimitsApiV1OpsRateLimitsResetPost>>
>;

export type ResetRateLimitsApiV1OpsRateLimitsResetPostMutationError =
  ErrorType<HTTPValidationError>;

/**
 * @summary Reset Rate Limits
 */
export const useResetRateLimitsApiV1OpsRateLimitsResetPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof resetRateLimitsApiV1OpsRateLimitsResetPost>>,
      TError,
      { params: ResetRateLimitsApiV1OpsRateLimitsResetPostParams },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof resetRateLimitsApiV1OpsRateLimitsResetPost>>,
  TError,
  { params: ResetRateLimitsApiV1OpsRateLimitsResetPostParams },
  TContext
> => {
  return useMutation(
    getResetRateLimitsApiV1OpsRateLimitsResetPostMutationOptions(options),
    queryClient
  );
};
/**
 * Test endpoint to verify rate limiting is working.

This endpoint has a low rate limit for testing purposes.
Try making multiple requests to see rate limiting in action.
 * @summary Test Rate Limit
 */
export const getTestRateLimitApiV1OpsRateLimitsTestGetUrl = (
  params?: TestRateLimitApiV1OpsRateLimitsTestGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/ops/rate-limits/test?${stringifiedParams}`
    : `/api/v1/ops/rate-limits/test`;
};

export const testRateLimitApiV1OpsRateLimitsTestGet = async (
  params?: TestRateLimitApiV1OpsRateLimitsTestGetParams,
  options?: RequestInit
): Promise<RateLimitTestResponse> => {
  return customFetch<RateLimitTestResponse>(getTestRateLimitApiV1OpsRateLimitsTestGetUrl(params), {
    ...options,
    method: 'GET',
  });
};

export const getTestRateLimitApiV1OpsRateLimitsTestGetQueryKey = (
  params?: TestRateLimitApiV1OpsRateLimitsTestGetParams
) => {
  return [`/api/v1/ops/rate-limits/test`, ...(params ? [params] : [])] as const;
};

export const getTestRateLimitApiV1OpsRateLimitsTestGetQueryOptions = <
  TData = Awaited<ReturnType<typeof testRateLimitApiV1OpsRateLimitsTestGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: TestRateLimitApiV1OpsRateLimitsTestGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof testRateLimitApiV1OpsRateLimitsTestGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getTestRateLimitApiV1OpsRateLimitsTestGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof testRateLimitApiV1OpsRateLimitsTestGet>>
  > = ({ signal }) => testRateLimitApiV1OpsRateLimitsTestGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof testRateLimitApiV1OpsRateLimitsTestGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TestRateLimitApiV1OpsRateLimitsTestGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof testRateLimitApiV1OpsRateLimitsTestGet>>
>;
export type TestRateLimitApiV1OpsRateLimitsTestGetQueryError = ErrorType<HTTPValidationError>;

export function useTestRateLimitApiV1OpsRateLimitsTestGet<
  TData = Awaited<ReturnType<typeof testRateLimitApiV1OpsRateLimitsTestGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: undefined | TestRateLimitApiV1OpsRateLimitsTestGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof testRateLimitApiV1OpsRateLimitsTestGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof testRateLimitApiV1OpsRateLimitsTestGet>>,
          TError,
          Awaited<ReturnType<typeof testRateLimitApiV1OpsRateLimitsTestGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useTestRateLimitApiV1OpsRateLimitsTestGet<
  TData = Awaited<ReturnType<typeof testRateLimitApiV1OpsRateLimitsTestGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: TestRateLimitApiV1OpsRateLimitsTestGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof testRateLimitApiV1OpsRateLimitsTestGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof testRateLimitApiV1OpsRateLimitsTestGet>>,
          TError,
          Awaited<ReturnType<typeof testRateLimitApiV1OpsRateLimitsTestGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useTestRateLimitApiV1OpsRateLimitsTestGet<
  TData = Awaited<ReturnType<typeof testRateLimitApiV1OpsRateLimitsTestGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: TestRateLimitApiV1OpsRateLimitsTestGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof testRateLimitApiV1OpsRateLimitsTestGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Test Rate Limit
 */

export function useTestRateLimitApiV1OpsRateLimitsTestGet<
  TData = Awaited<ReturnType<typeof testRateLimitApiV1OpsRateLimitsTestGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: TestRateLimitApiV1OpsRateLimitsTestGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof testRateLimitApiV1OpsRateLimitsTestGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getTestRateLimitApiV1OpsRateLimitsTestGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get recent slow queries.
 * @summary Get Slow Queries
 */
export const getGetSlowQueriesApiV1OpsSlowQueriesGetUrl = () => {
  return `/api/v1/ops/slow-queries`;
};

export const getSlowQueriesApiV1OpsSlowQueriesGet = async (
  options?: RequestInit
): Promise<SlowQueriesResponse> => {
  return customFetch<SlowQueriesResponse>(getGetSlowQueriesApiV1OpsSlowQueriesGetUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getGetSlowQueriesApiV1OpsSlowQueriesGetQueryKey = () => {
  return [`/api/v1/ops/slow-queries`] as const;
};

export const getGetSlowQueriesApiV1OpsSlowQueriesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getSlowQueriesApiV1OpsSlowQueriesGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getSlowQueriesApiV1OpsSlowQueriesGet>>, TError, TData>
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetSlowQueriesApiV1OpsSlowQueriesGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getSlowQueriesApiV1OpsSlowQueriesGet>>
  > = ({ signal }) => getSlowQueriesApiV1OpsSlowQueriesGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getSlowQueriesApiV1OpsSlowQueriesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetSlowQueriesApiV1OpsSlowQueriesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getSlowQueriesApiV1OpsSlowQueriesGet>>
>;
export type GetSlowQueriesApiV1OpsSlowQueriesGetQueryError = ErrorType<unknown>;

export function useGetSlowQueriesApiV1OpsSlowQueriesGet<
  TData = Awaited<ReturnType<typeof getSlowQueriesApiV1OpsSlowQueriesGet>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSlowQueriesApiV1OpsSlowQueriesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSlowQueriesApiV1OpsSlowQueriesGet>>,
          TError,
          Awaited<ReturnType<typeof getSlowQueriesApiV1OpsSlowQueriesGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSlowQueriesApiV1OpsSlowQueriesGet<
  TData = Awaited<ReturnType<typeof getSlowQueriesApiV1OpsSlowQueriesGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSlowQueriesApiV1OpsSlowQueriesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getSlowQueriesApiV1OpsSlowQueriesGet>>,
          TError,
          Awaited<ReturnType<typeof getSlowQueriesApiV1OpsSlowQueriesGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetSlowQueriesApiV1OpsSlowQueriesGet<
  TData = Awaited<ReturnType<typeof getSlowQueriesApiV1OpsSlowQueriesGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSlowQueriesApiV1OpsSlowQueriesGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Slow Queries
 */

export function useGetSlowQueriesApiV1OpsSlowQueriesGet<
  TData = Awaited<ReturnType<typeof getSlowQueriesApiV1OpsSlowQueriesGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getSlowQueriesApiV1OpsSlowQueriesGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetSlowQueriesApiV1OpsSlowQueriesGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get Celery queue status and pending tasks.

Requires ACCESS_MONITORING permission.

Returns:
    Queue lengths and task counts
 * @summary Celery Queue Status
 */
export const getCeleryQueueStatusApiV1RedisCeleryQueuesGetUrl = () => {
  return `/api/v1/redis/celery-queues`;
};

export const celeryQueueStatusApiV1RedisCeleryQueuesGet = async (
  options?: RequestInit
): Promise<RedisCeleryQueuesResponse> => {
  return customFetch<RedisCeleryQueuesResponse>(
    getCeleryQueueStatusApiV1RedisCeleryQueuesGetUrl(),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getCeleryQueueStatusApiV1RedisCeleryQueuesGetQueryKey = () => {
  return [`/api/v1/redis/celery-queues`] as const;
};

export const getCeleryQueueStatusApiV1RedisCeleryQueuesGetQueryOptions = <
  TData = Awaited<ReturnType<typeof celeryQueueStatusApiV1RedisCeleryQueuesGet>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof celeryQueueStatusApiV1RedisCeleryQueuesGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getCeleryQueueStatusApiV1RedisCeleryQueuesGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof celeryQueueStatusApiV1RedisCeleryQueuesGet>>
  > = ({ signal }) => celeryQueueStatusApiV1RedisCeleryQueuesGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof celeryQueueStatusApiV1RedisCeleryQueuesGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CeleryQueueStatusApiV1RedisCeleryQueuesGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof celeryQueueStatusApiV1RedisCeleryQueuesGet>>
>;
export type CeleryQueueStatusApiV1RedisCeleryQueuesGetQueryError = ErrorType<void>;

export function useCeleryQueueStatusApiV1RedisCeleryQueuesGet<
  TData = Awaited<ReturnType<typeof celeryQueueStatusApiV1RedisCeleryQueuesGet>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof celeryQueueStatusApiV1RedisCeleryQueuesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof celeryQueueStatusApiV1RedisCeleryQueuesGet>>,
          TError,
          Awaited<ReturnType<typeof celeryQueueStatusApiV1RedisCeleryQueuesGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useCeleryQueueStatusApiV1RedisCeleryQueuesGet<
  TData = Awaited<ReturnType<typeof celeryQueueStatusApiV1RedisCeleryQueuesGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof celeryQueueStatusApiV1RedisCeleryQueuesGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof celeryQueueStatusApiV1RedisCeleryQueuesGet>>,
          TError,
          Awaited<ReturnType<typeof celeryQueueStatusApiV1RedisCeleryQueuesGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useCeleryQueueStatusApiV1RedisCeleryQueuesGet<
  TData = Awaited<ReturnType<typeof celeryQueueStatusApiV1RedisCeleryQueuesGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof celeryQueueStatusApiV1RedisCeleryQueuesGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Celery Queue Status
 */

export function useCeleryQueueStatusApiV1RedisCeleryQueuesGet<
  TData = Awaited<ReturnType<typeof celeryQueueStatusApiV1RedisCeleryQueuesGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof celeryQueueStatusApiV1RedisCeleryQueuesGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getCeleryQueueStatusApiV1RedisCeleryQueuesGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Audit all Redis connections across the system.

Checks which Redis instance each service is using and identifies
any remaining Upstash connections.

Requires ACCESS_MONITORING permission.

Returns:
    Summary of Redis connections across all services
 * @summary Redis Connection Audit
 */
export const getRedisConnectionAuditApiV1RedisConnectionAuditGetUrl = () => {
  return `/api/v1/redis/connection-audit`;
};

export const redisConnectionAuditApiV1RedisConnectionAuditGet = async (
  options?: RequestInit
): Promise<RedisConnectionAuditResponse> => {
  return customFetch<RedisConnectionAuditResponse>(
    getRedisConnectionAuditApiV1RedisConnectionAuditGetUrl(),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getRedisConnectionAuditApiV1RedisConnectionAuditGetQueryKey = () => {
  return [`/api/v1/redis/connection-audit`] as const;
};

export const getRedisConnectionAuditApiV1RedisConnectionAuditGetQueryOptions = <
  TData = Awaited<ReturnType<typeof redisConnectionAuditApiV1RedisConnectionAuditGet>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof redisConnectionAuditApiV1RedisConnectionAuditGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getRedisConnectionAuditApiV1RedisConnectionAuditGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof redisConnectionAuditApiV1RedisConnectionAuditGet>>
  > = ({ signal }) =>
    redisConnectionAuditApiV1RedisConnectionAuditGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof redisConnectionAuditApiV1RedisConnectionAuditGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RedisConnectionAuditApiV1RedisConnectionAuditGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof redisConnectionAuditApiV1RedisConnectionAuditGet>>
>;
export type RedisConnectionAuditApiV1RedisConnectionAuditGetQueryError = ErrorType<void>;

export function useRedisConnectionAuditApiV1RedisConnectionAuditGet<
  TData = Awaited<ReturnType<typeof redisConnectionAuditApiV1RedisConnectionAuditGet>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof redisConnectionAuditApiV1RedisConnectionAuditGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof redisConnectionAuditApiV1RedisConnectionAuditGet>>,
          TError,
          Awaited<ReturnType<typeof redisConnectionAuditApiV1RedisConnectionAuditGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useRedisConnectionAuditApiV1RedisConnectionAuditGet<
  TData = Awaited<ReturnType<typeof redisConnectionAuditApiV1RedisConnectionAuditGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof redisConnectionAuditApiV1RedisConnectionAuditGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof redisConnectionAuditApiV1RedisConnectionAuditGet>>,
          TError,
          Awaited<ReturnType<typeof redisConnectionAuditApiV1RedisConnectionAuditGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useRedisConnectionAuditApiV1RedisConnectionAuditGet<
  TData = Awaited<ReturnType<typeof redisConnectionAuditApiV1RedisConnectionAuditGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof redisConnectionAuditApiV1RedisConnectionAuditGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Redis Connection Audit
 */

export function useRedisConnectionAuditApiV1RedisConnectionAuditGet<
  TData = Awaited<ReturnType<typeof redisConnectionAuditApiV1RedisConnectionAuditGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof redisConnectionAuditApiV1RedisConnectionAuditGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getRedisConnectionAuditApiV1RedisConnectionAuditGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Flush all Celery queues (DANGER: removes all pending tasks).

Requires ACCESS_MONITORING permission.
Use with caution - this will delete all pending tasks!

Returns:
    Number of tasks removed from each queue
 * @summary Flush Celery Queues
 */
export const getFlushCeleryQueuesApiV1RedisFlushQueuesDeleteUrl = () => {
  return `/api/v1/redis/flush-queues`;
};

export const flushCeleryQueuesApiV1RedisFlushQueuesDelete = async (
  options?: RequestInit
): Promise<RedisFlushQueuesResponse> => {
  return customFetch<RedisFlushQueuesResponse>(
    getFlushCeleryQueuesApiV1RedisFlushQueuesDeleteUrl(),
    {
      ...options,
      method: 'DELETE',
    }
  );
};

export const getFlushCeleryQueuesApiV1RedisFlushQueuesDeleteMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof flushCeleryQueuesApiV1RedisFlushQueuesDelete>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof flushCeleryQueuesApiV1RedisFlushQueuesDelete>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['flushCeleryQueuesApiV1RedisFlushQueuesDelete'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof flushCeleryQueuesApiV1RedisFlushQueuesDelete>>,
    void
  > = () => {
    return flushCeleryQueuesApiV1RedisFlushQueuesDelete(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type FlushCeleryQueuesApiV1RedisFlushQueuesDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof flushCeleryQueuesApiV1RedisFlushQueuesDelete>>
>;

export type FlushCeleryQueuesApiV1RedisFlushQueuesDeleteMutationError = ErrorType<void>;

/**
 * @summary Flush Celery Queues
 */
export const useFlushCeleryQueuesApiV1RedisFlushQueuesDelete = <
  TError = ErrorType<void>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof flushCeleryQueuesApiV1RedisFlushQueuesDelete>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof flushCeleryQueuesApiV1RedisFlushQueuesDelete>>,
  TError,
  void,
  TContext
> => {
  return useMutation(
    getFlushCeleryQueuesApiV1RedisFlushQueuesDeleteMutationOptions(options),
    queryClient
  );
};
/**
 * Check Redis connection health.

Returns:
    Basic health status
 * @summary Redis Health
 */
export const getRedisHealthApiV1RedisHealthGetUrl = () => {
  return `/api/v1/redis/health`;
};

export const redisHealthApiV1RedisHealthGet = async (
  options?: RequestInit
): Promise<RedisHealthResponse> => {
  return customFetch<RedisHealthResponse>(getRedisHealthApiV1RedisHealthGetUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getRedisHealthApiV1RedisHealthGetQueryKey = () => {
  return [`/api/v1/redis/health`] as const;
};

export const getRedisHealthApiV1RedisHealthGetQueryOptions = <
  TData = Awaited<ReturnType<typeof redisHealthApiV1RedisHealthGet>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof redisHealthApiV1RedisHealthGet>>, TError, TData>
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRedisHealthApiV1RedisHealthGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof redisHealthApiV1RedisHealthGet>>> = ({
    signal,
  }) => redisHealthApiV1RedisHealthGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof redisHealthApiV1RedisHealthGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RedisHealthApiV1RedisHealthGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof redisHealthApiV1RedisHealthGet>>
>;
export type RedisHealthApiV1RedisHealthGetQueryError = ErrorType<void>;

export function useRedisHealthApiV1RedisHealthGet<
  TData = Awaited<ReturnType<typeof redisHealthApiV1RedisHealthGet>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof redisHealthApiV1RedisHealthGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof redisHealthApiV1RedisHealthGet>>,
          TError,
          Awaited<ReturnType<typeof redisHealthApiV1RedisHealthGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useRedisHealthApiV1RedisHealthGet<
  TData = Awaited<ReturnType<typeof redisHealthApiV1RedisHealthGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof redisHealthApiV1RedisHealthGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof redisHealthApiV1RedisHealthGet>>,
          TError,
          Awaited<ReturnType<typeof redisHealthApiV1RedisHealthGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useRedisHealthApiV1RedisHealthGet<
  TData = Awaited<ReturnType<typeof redisHealthApiV1RedisHealthGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof redisHealthApiV1RedisHealthGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Redis Health
 */

export function useRedisHealthApiV1RedisHealthGet<
  TData = Awaited<ReturnType<typeof redisHealthApiV1RedisHealthGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof redisHealthApiV1RedisHealthGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getRedisHealthApiV1RedisHealthGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get detailed Redis statistics and metrics.

Requires ACCESS_MONITORING permission.

Returns:
    Comprehensive Redis metrics including:
    - Memory usage
    - Connection stats
    - Operation counts
    - Celery queue lengths
 * @summary Redis Stats
 */
export const getRedisStatsApiV1RedisStatsGetUrl = () => {
  return `/api/v1/redis/stats`;
};

export const redisStatsApiV1RedisStatsGet = async (
  options?: RequestInit
): Promise<RedisStatsResponse> => {
  return customFetch<RedisStatsResponse>(getRedisStatsApiV1RedisStatsGetUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getRedisStatsApiV1RedisStatsGetQueryKey = () => {
  return [`/api/v1/redis/stats`] as const;
};

export const getRedisStatsApiV1RedisStatsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof redisStatsApiV1RedisStatsGet>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof redisStatsApiV1RedisStatsGet>>, TError, TData>
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRedisStatsApiV1RedisStatsGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof redisStatsApiV1RedisStatsGet>>> = ({
    signal,
  }) => redisStatsApiV1RedisStatsGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof redisStatsApiV1RedisStatsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RedisStatsApiV1RedisStatsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof redisStatsApiV1RedisStatsGet>>
>;
export type RedisStatsApiV1RedisStatsGetQueryError = ErrorType<void>;

export function useRedisStatsApiV1RedisStatsGet<
  TData = Awaited<ReturnType<typeof redisStatsApiV1RedisStatsGet>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof redisStatsApiV1RedisStatsGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof redisStatsApiV1RedisStatsGet>>,
          TError,
          Awaited<ReturnType<typeof redisStatsApiV1RedisStatsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useRedisStatsApiV1RedisStatsGet<
  TData = Awaited<ReturnType<typeof redisStatsApiV1RedisStatsGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof redisStatsApiV1RedisStatsGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof redisStatsApiV1RedisStatsGet>>,
          TError,
          Awaited<ReturnType<typeof redisStatsApiV1RedisStatsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useRedisStatsApiV1RedisStatsGet<
  TData = Awaited<ReturnType<typeof redisStatsApiV1RedisStatsGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof redisStatsApiV1RedisStatsGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Redis Stats
 */

export function useRedisStatsApiV1RedisStatsGet<
  TData = Awaited<ReturnType<typeof redisStatsApiV1RedisStatsGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof redisStatsApiV1RedisStatsGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getRedisStatsApiV1RedisStatsGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Simple Redis connection test endpoint.

No authentication required - helps verify Redis migration is working.

Returns:
    Connection status and basic info
 * @summary Redis Test
 */
export const getRedisTestApiV1RedisTestGetUrl = () => {
  return `/api/v1/redis/test`;
};

export const redisTestApiV1RedisTestGet = async (
  options?: RequestInit
): Promise<RedisTestResponse> => {
  return customFetch<RedisTestResponse>(getRedisTestApiV1RedisTestGetUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getRedisTestApiV1RedisTestGetQueryKey = () => {
  return [`/api/v1/redis/test`] as const;
};

export const getRedisTestApiV1RedisTestGetQueryOptions = <
  TData = Awaited<ReturnType<typeof redisTestApiV1RedisTestGet>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof redisTestApiV1RedisTestGet>>, TError, TData>
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRedisTestApiV1RedisTestGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof redisTestApiV1RedisTestGet>>> = ({
    signal,
  }) => redisTestApiV1RedisTestGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof redisTestApiV1RedisTestGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RedisTestApiV1RedisTestGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof redisTestApiV1RedisTestGet>>
>;
export type RedisTestApiV1RedisTestGetQueryError = ErrorType<void>;

export function useRedisTestApiV1RedisTestGet<
  TData = Awaited<ReturnType<typeof redisTestApiV1RedisTestGet>>,
  TError = ErrorType<void>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof redisTestApiV1RedisTestGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof redisTestApiV1RedisTestGet>>,
          TError,
          Awaited<ReturnType<typeof redisTestApiV1RedisTestGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useRedisTestApiV1RedisTestGet<
  TData = Awaited<ReturnType<typeof redisTestApiV1RedisTestGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof redisTestApiV1RedisTestGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof redisTestApiV1RedisTestGet>>,
          TError,
          Awaited<ReturnType<typeof redisTestApiV1RedisTestGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useRedisTestApiV1RedisTestGet<
  TData = Awaited<ReturnType<typeof redisTestApiV1RedisTestGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof redisTestApiV1RedisTestGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Redis Test
 */

export function useRedisTestApiV1RedisTestGet<
  TData = Awaited<ReturnType<typeof redisTestApiV1RedisTestGet>>,
  TError = ErrorType<void>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof redisTestApiV1RedisTestGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getRedisTestApiV1RedisTestGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}
