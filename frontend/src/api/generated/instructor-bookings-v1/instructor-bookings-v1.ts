/**
 * Generated by orval v8.4.1 üç∫
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  BodyDisputeCompletionApiV1InstructorBookingsBookingIdDisputePost,
  BookingResponse,
  GetCompletedBookingsApiV1InstructorBookingsCompletedGetParams,
  GetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGetParams,
  GetUpcomingBookingsApiV1InstructorBookingsUpcomingGetParams,
  HTTPValidationError,
  ListInstructorBookingsApiV1InstructorBookingsGetParams,
  MarkLessonCompleteApiV1InstructorBookingsBookingIdCompletePostParams,
  PaginatedResponseBookingResponse,
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * List instructor bookings with filters.
 * @summary List Instructor Bookings
 */
export const getListInstructorBookingsApiV1InstructorBookingsGetUrl = (
  params?: ListInstructorBookingsApiV1InstructorBookingsGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/instructor-bookings?${stringifiedParams}`
    : `/api/v1/instructor-bookings`;
};

export const listInstructorBookingsApiV1InstructorBookingsGet = async (
  params?: ListInstructorBookingsApiV1InstructorBookingsGetParams,
  options?: RequestInit
): Promise<PaginatedResponseBookingResponse> => {
  return customFetch<PaginatedResponseBookingResponse>(
    getListInstructorBookingsApiV1InstructorBookingsGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getListInstructorBookingsApiV1InstructorBookingsGetQueryKey = (
  params?: ListInstructorBookingsApiV1InstructorBookingsGetParams
) => {
  return [`/api/v1/instructor-bookings`, ...(params ? [params] : [])] as const;
};

export const getListInstructorBookingsApiV1InstructorBookingsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listInstructorBookingsApiV1InstructorBookingsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: ListInstructorBookingsApiV1InstructorBookingsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listInstructorBookingsApiV1InstructorBookingsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getListInstructorBookingsApiV1InstructorBookingsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listInstructorBookingsApiV1InstructorBookingsGet>>
  > = ({ signal }) =>
    listInstructorBookingsApiV1InstructorBookingsGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listInstructorBookingsApiV1InstructorBookingsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListInstructorBookingsApiV1InstructorBookingsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listInstructorBookingsApiV1InstructorBookingsGet>>
>;
export type ListInstructorBookingsApiV1InstructorBookingsGetQueryError =
  ErrorType<HTTPValidationError>;

export function useListInstructorBookingsApiV1InstructorBookingsGet<
  TData = Awaited<ReturnType<typeof listInstructorBookingsApiV1InstructorBookingsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: undefined | ListInstructorBookingsApiV1InstructorBookingsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listInstructorBookingsApiV1InstructorBookingsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listInstructorBookingsApiV1InstructorBookingsGet>>,
          TError,
          Awaited<ReturnType<typeof listInstructorBookingsApiV1InstructorBookingsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListInstructorBookingsApiV1InstructorBookingsGet<
  TData = Awaited<ReturnType<typeof listInstructorBookingsApiV1InstructorBookingsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: ListInstructorBookingsApiV1InstructorBookingsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listInstructorBookingsApiV1InstructorBookingsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listInstructorBookingsApiV1InstructorBookingsGet>>,
          TError,
          Awaited<ReturnType<typeof listInstructorBookingsApiV1InstructorBookingsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListInstructorBookingsApiV1InstructorBookingsGet<
  TData = Awaited<ReturnType<typeof listInstructorBookingsApiV1InstructorBookingsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: ListInstructorBookingsApiV1InstructorBookingsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listInstructorBookingsApiV1InstructorBookingsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List Instructor Bookings
 */

export function useListInstructorBookingsApiV1InstructorBookingsGet<
  TData = Awaited<ReturnType<typeof listInstructorBookingsApiV1InstructorBookingsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: ListInstructorBookingsApiV1InstructorBookingsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listInstructorBookingsApiV1InstructorBookingsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListInstructorBookingsApiV1InstructorBookingsGetQueryOptions(
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get instructor's completed bookings.
 * @summary Get Completed Bookings
 */
export const getGetCompletedBookingsApiV1InstructorBookingsCompletedGetUrl = (
  params?: GetCompletedBookingsApiV1InstructorBookingsCompletedGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/instructor-bookings/completed?${stringifiedParams}`
    : `/api/v1/instructor-bookings/completed`;
};

export const getCompletedBookingsApiV1InstructorBookingsCompletedGet = async (
  params?: GetCompletedBookingsApiV1InstructorBookingsCompletedGetParams,
  options?: RequestInit
): Promise<PaginatedResponseBookingResponse> => {
  return customFetch<PaginatedResponseBookingResponse>(
    getGetCompletedBookingsApiV1InstructorBookingsCompletedGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetCompletedBookingsApiV1InstructorBookingsCompletedGetQueryKey = (
  params?: GetCompletedBookingsApiV1InstructorBookingsCompletedGetParams
) => {
  return [`/api/v1/instructor-bookings/completed`, ...(params ? [params] : [])] as const;
};

export const getGetCompletedBookingsApiV1InstructorBookingsCompletedGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getCompletedBookingsApiV1InstructorBookingsCompletedGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetCompletedBookingsApiV1InstructorBookingsCompletedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCompletedBookingsApiV1InstructorBookingsCompletedGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetCompletedBookingsApiV1InstructorBookingsCompletedGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCompletedBookingsApiV1InstructorBookingsCompletedGet>>
  > = ({ signal }) =>
    getCompletedBookingsApiV1InstructorBookingsCompletedGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCompletedBookingsApiV1InstructorBookingsCompletedGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCompletedBookingsApiV1InstructorBookingsCompletedGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCompletedBookingsApiV1InstructorBookingsCompletedGet>>
>;
export type GetCompletedBookingsApiV1InstructorBookingsCompletedGetQueryError =
  ErrorType<HTTPValidationError>;

export function useGetCompletedBookingsApiV1InstructorBookingsCompletedGet<
  TData = Awaited<ReturnType<typeof getCompletedBookingsApiV1InstructorBookingsCompletedGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: undefined | GetCompletedBookingsApiV1InstructorBookingsCompletedGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCompletedBookingsApiV1InstructorBookingsCompletedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompletedBookingsApiV1InstructorBookingsCompletedGet>>,
          TError,
          Awaited<ReturnType<typeof getCompletedBookingsApiV1InstructorBookingsCompletedGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCompletedBookingsApiV1InstructorBookingsCompletedGet<
  TData = Awaited<ReturnType<typeof getCompletedBookingsApiV1InstructorBookingsCompletedGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetCompletedBookingsApiV1InstructorBookingsCompletedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCompletedBookingsApiV1InstructorBookingsCompletedGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompletedBookingsApiV1InstructorBookingsCompletedGet>>,
          TError,
          Awaited<ReturnType<typeof getCompletedBookingsApiV1InstructorBookingsCompletedGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCompletedBookingsApiV1InstructorBookingsCompletedGet<
  TData = Awaited<ReturnType<typeof getCompletedBookingsApiV1InstructorBookingsCompletedGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetCompletedBookingsApiV1InstructorBookingsCompletedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCompletedBookingsApiV1InstructorBookingsCompletedGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Completed Bookings
 */

export function useGetCompletedBookingsApiV1InstructorBookingsCompletedGet<
  TData = Awaited<ReturnType<typeof getCompletedBookingsApiV1InstructorBookingsCompletedGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetCompletedBookingsApiV1InstructorBookingsCompletedGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCompletedBookingsApiV1InstructorBookingsCompletedGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCompletedBookingsApiV1InstructorBookingsCompletedGetQueryOptions(
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get all bookings that are pending completion by the instructor.

Returns bookings that:
- Are confirmed status
- Have ended (based on date/time)
- Haven't been marked complete yet
 * @summary Get Pending Completion Bookings
 */
export const getGetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGetUrl = (
  params?: GetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/instructor-bookings/pending-completion?${stringifiedParams}`
    : `/api/v1/instructor-bookings/pending-completion`;
};

export const getPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet = async (
  params?: GetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGetParams,
  options?: RequestInit
): Promise<PaginatedResponseBookingResponse> => {
  return customFetch<PaginatedResponseBookingResponse>(
    getGetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGetQueryKey = (
  params?: GetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGetParams
) => {
  return [`/api/v1/instructor-bookings/pending-completion`, ...(params ? [params] : [])] as const;
};

export const getGetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGetQueryOptions =
  <
    TData = Awaited<
      ReturnType<typeof getPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet>
    >,
    TError = ErrorType<HTTPValidationError>,
  >(
    params?: GetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGetParams,
    options?: {
      query?: Partial<
        UseQueryOptions<
          Awaited<
            ReturnType<
              typeof getPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet
            >
          >,
          TError,
          TData
        >
      >;
      request?: SecondParameter<typeof customFetch>;
    }
  ) => {
    const { query: queryOptions, request: requestOptions } = options ?? {};

    const queryKey =
      queryOptions?.queryKey ??
      getGetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGetQueryKey(params);

    const queryFn: QueryFunction<
      Awaited<
        ReturnType<typeof getPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet>
      >
    > = ({ signal }) =>
      getPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet(params, {
        signal,
        ...requestOptions,
      });

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
      Awaited<
        ReturnType<typeof getPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet>
      >,
      TError,
      TData
    > & { queryKey: DataTag<QueryKey, TData, TError> };
  };

export type GetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGetQueryResult =
  NonNullable<
    Awaited<
      ReturnType<typeof getPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet>
    >
  >;
export type GetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGetQueryError =
  ErrorType<HTTPValidationError>;

export function useGetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet<
  TData = Awaited<
    ReturnType<typeof getPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet>
  >,
  TError = ErrorType<HTTPValidationError>,
>(
  params: undefined | GetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet
            >
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet<
  TData = Awaited<
    ReturnType<typeof getPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet>
  >,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<
              typeof getPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet
            >
          >,
          TError,
          Awaited<
            ReturnType<
              typeof getPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet
            >
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet<
  TData = Awaited<
    ReturnType<typeof getPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet>
  >,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Pending Completion Bookings
 */

export function useGetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet<
  TData = Awaited<
    ReturnType<typeof getPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet>
  >,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGet>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions =
    getGetPendingCompletionBookingsApiV1InstructorBookingsPendingCompletionGetQueryOptions(
      params,
      options
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Return instructor's upcoming confirmed bookings.
 * @summary Get Upcoming Bookings
 */
export const getGetUpcomingBookingsApiV1InstructorBookingsUpcomingGetUrl = (
  params?: GetUpcomingBookingsApiV1InstructorBookingsUpcomingGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/instructor-bookings/upcoming?${stringifiedParams}`
    : `/api/v1/instructor-bookings/upcoming`;
};

export const getUpcomingBookingsApiV1InstructorBookingsUpcomingGet = async (
  params?: GetUpcomingBookingsApiV1InstructorBookingsUpcomingGetParams,
  options?: RequestInit
): Promise<PaginatedResponseBookingResponse> => {
  return customFetch<PaginatedResponseBookingResponse>(
    getGetUpcomingBookingsApiV1InstructorBookingsUpcomingGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetUpcomingBookingsApiV1InstructorBookingsUpcomingGetQueryKey = (
  params?: GetUpcomingBookingsApiV1InstructorBookingsUpcomingGetParams
) => {
  return [`/api/v1/instructor-bookings/upcoming`, ...(params ? [params] : [])] as const;
};

export const getGetUpcomingBookingsApiV1InstructorBookingsUpcomingGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getUpcomingBookingsApiV1InstructorBookingsUpcomingGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetUpcomingBookingsApiV1InstructorBookingsUpcomingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUpcomingBookingsApiV1InstructorBookingsUpcomingGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetUpcomingBookingsApiV1InstructorBookingsUpcomingGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUpcomingBookingsApiV1InstructorBookingsUpcomingGet>>
  > = ({ signal }) =>
    getUpcomingBookingsApiV1InstructorBookingsUpcomingGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUpcomingBookingsApiV1InstructorBookingsUpcomingGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUpcomingBookingsApiV1InstructorBookingsUpcomingGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUpcomingBookingsApiV1InstructorBookingsUpcomingGet>>
>;
export type GetUpcomingBookingsApiV1InstructorBookingsUpcomingGetQueryError =
  ErrorType<HTTPValidationError>;

export function useGetUpcomingBookingsApiV1InstructorBookingsUpcomingGet<
  TData = Awaited<ReturnType<typeof getUpcomingBookingsApiV1InstructorBookingsUpcomingGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: undefined | GetUpcomingBookingsApiV1InstructorBookingsUpcomingGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUpcomingBookingsApiV1InstructorBookingsUpcomingGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUpcomingBookingsApiV1InstructorBookingsUpcomingGet>>,
          TError,
          Awaited<ReturnType<typeof getUpcomingBookingsApiV1InstructorBookingsUpcomingGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUpcomingBookingsApiV1InstructorBookingsUpcomingGet<
  TData = Awaited<ReturnType<typeof getUpcomingBookingsApiV1InstructorBookingsUpcomingGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetUpcomingBookingsApiV1InstructorBookingsUpcomingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUpcomingBookingsApiV1InstructorBookingsUpcomingGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUpcomingBookingsApiV1InstructorBookingsUpcomingGet>>,
          TError,
          Awaited<ReturnType<typeof getUpcomingBookingsApiV1InstructorBookingsUpcomingGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUpcomingBookingsApiV1InstructorBookingsUpcomingGet<
  TData = Awaited<ReturnType<typeof getUpcomingBookingsApiV1InstructorBookingsUpcomingGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetUpcomingBookingsApiV1InstructorBookingsUpcomingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUpcomingBookingsApiV1InstructorBookingsUpcomingGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Upcoming Bookings
 */

export function useGetUpcomingBookingsApiV1InstructorBookingsUpcomingGet<
  TData = Awaited<ReturnType<typeof getUpcomingBookingsApiV1InstructorBookingsUpcomingGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetUpcomingBookingsApiV1InstructorBookingsUpcomingGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getUpcomingBookingsApiV1InstructorBookingsUpcomingGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUpcomingBookingsApiV1InstructorBookingsUpcomingGetQueryOptions(
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Mark a lesson as completed by the instructor.

This triggers the 24-hour payment capture timer. The payment will be
captured 24 hours after this endpoint is called, giving the student
time to dispute if needed.

Args:
    booking_id: The booking to mark as complete
    notes: Optional completion notes from instructor

Returns:
    Updated booking information

Raises:
    404: Booking not found
    422: Booking cannot be marked complete (wrong status, not instructor's booking)
 * @summary Mark Lesson Complete
 */
export const getMarkLessonCompleteApiV1InstructorBookingsBookingIdCompletePostUrl = (
  bookingId: string,
  params?: MarkLessonCompleteApiV1InstructorBookingsBookingIdCompletePostParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/instructor-bookings/${bookingId}/complete?${stringifiedParams}`
    : `/api/v1/instructor-bookings/${bookingId}/complete`;
};

export const markLessonCompleteApiV1InstructorBookingsBookingIdCompletePost = async (
  bookingId: string,
  params?: MarkLessonCompleteApiV1InstructorBookingsBookingIdCompletePostParams,
  options?: RequestInit
): Promise<BookingResponse> => {
  return customFetch<BookingResponse>(
    getMarkLessonCompleteApiV1InstructorBookingsBookingIdCompletePostUrl(bookingId, params),
    {
      ...options,
      method: 'POST',
    }
  );
};

export const getMarkLessonCompleteApiV1InstructorBookingsBookingIdCompletePostMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof markLessonCompleteApiV1InstructorBookingsBookingIdCompletePost>>,
    TError,
    {
      bookingId: string;
      params?: MarkLessonCompleteApiV1InstructorBookingsBookingIdCompletePostParams;
    },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof markLessonCompleteApiV1InstructorBookingsBookingIdCompletePost>>,
  TError,
  {
    bookingId: string;
    params?: MarkLessonCompleteApiV1InstructorBookingsBookingIdCompletePostParams;
  },
  TContext
> => {
  const mutationKey = ['markLessonCompleteApiV1InstructorBookingsBookingIdCompletePost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof markLessonCompleteApiV1InstructorBookingsBookingIdCompletePost>>,
    {
      bookingId: string;
      params?: MarkLessonCompleteApiV1InstructorBookingsBookingIdCompletePostParams;
    }
  > = (props) => {
    const { bookingId, params } = props ?? {};

    return markLessonCompleteApiV1InstructorBookingsBookingIdCompletePost(
      bookingId,
      params,
      requestOptions
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type MarkLessonCompleteApiV1InstructorBookingsBookingIdCompletePostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof markLessonCompleteApiV1InstructorBookingsBookingIdCompletePost>>
  >;

export type MarkLessonCompleteApiV1InstructorBookingsBookingIdCompletePostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Mark Lesson Complete
 */
export const useMarkLessonCompleteApiV1InstructorBookingsBookingIdCompletePost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof markLessonCompleteApiV1InstructorBookingsBookingIdCompletePost>>,
      TError,
      {
        bookingId: string;
        params?: MarkLessonCompleteApiV1InstructorBookingsBookingIdCompletePostParams;
      },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof markLessonCompleteApiV1InstructorBookingsBookingIdCompletePost>>,
  TError,
  {
    bookingId: string;
    params?: MarkLessonCompleteApiV1InstructorBookingsBookingIdCompletePostParams;
  },
  TContext
> => {
  return useMutation(
    getMarkLessonCompleteApiV1InstructorBookingsBookingIdCompletePostMutationOptions(options),
    queryClient
  );
};
/**
 * Dispute a lesson completion as an instructor.

Used when a student marks a lesson as complete but the instructor disagrees.
This pauses payment capture pending resolution.

Args:
    booking_id: The booking to dispute
    reason: Reason for disputing the completion

Returns:
    Updated booking information
 * @summary Dispute Completion
 */
export const getDisputeCompletionApiV1InstructorBookingsBookingIdDisputePostUrl = (
  bookingId: string
) => {
  return `/api/v1/instructor-bookings/${bookingId}/dispute`;
};

export const disputeCompletionApiV1InstructorBookingsBookingIdDisputePost = async (
  bookingId: string,
  bodyDisputeCompletionApiV1InstructorBookingsBookingIdDisputePost: BodyDisputeCompletionApiV1InstructorBookingsBookingIdDisputePost,
  options?: RequestInit
): Promise<BookingResponse> => {
  return customFetch<BookingResponse>(
    getDisputeCompletionApiV1InstructorBookingsBookingIdDisputePostUrl(bookingId),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(bodyDisputeCompletionApiV1InstructorBookingsBookingIdDisputePost),
    }
  );
};

export const getDisputeCompletionApiV1InstructorBookingsBookingIdDisputePostMutationOptions = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof disputeCompletionApiV1InstructorBookingsBookingIdDisputePost>>,
    TError,
    { bookingId: string; data: BodyDisputeCompletionApiV1InstructorBookingsBookingIdDisputePost },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof disputeCompletionApiV1InstructorBookingsBookingIdDisputePost>>,
  TError,
  { bookingId: string; data: BodyDisputeCompletionApiV1InstructorBookingsBookingIdDisputePost },
  TContext
> => {
  const mutationKey = ['disputeCompletionApiV1InstructorBookingsBookingIdDisputePost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof disputeCompletionApiV1InstructorBookingsBookingIdDisputePost>>,
    { bookingId: string; data: BodyDisputeCompletionApiV1InstructorBookingsBookingIdDisputePost }
  > = (props) => {
    const { bookingId, data } = props ?? {};

    return disputeCompletionApiV1InstructorBookingsBookingIdDisputePost(
      bookingId,
      data,
      requestOptions
    );
  };

  return { mutationFn, ...mutationOptions };
};

export type DisputeCompletionApiV1InstructorBookingsBookingIdDisputePostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof disputeCompletionApiV1InstructorBookingsBookingIdDisputePost>>
  >;
export type DisputeCompletionApiV1InstructorBookingsBookingIdDisputePostMutationBody =
  BodyDisputeCompletionApiV1InstructorBookingsBookingIdDisputePost;
export type DisputeCompletionApiV1InstructorBookingsBookingIdDisputePostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Dispute Completion
 */
export const useDisputeCompletionApiV1InstructorBookingsBookingIdDisputePost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof disputeCompletionApiV1InstructorBookingsBookingIdDisputePost>>,
      TError,
      { bookingId: string; data: BodyDisputeCompletionApiV1InstructorBookingsBookingIdDisputePost },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof disputeCompletionApiV1InstructorBookingsBookingIdDisputePost>>,
  TError,
  { bookingId: string; data: BodyDisputeCompletionApiV1InstructorBookingsBookingIdDisputePost },
  TContext
> => {
  return useMutation(
    getDisputeCompletionApiV1InstructorBookingsBookingIdDisputePostMutationOptions(options),
    queryClient
  );
};
