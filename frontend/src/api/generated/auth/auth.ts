/**
 * Generated by orval v7.16.1 ðŸº
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AuthUserResponse,
  AuthUserWithPermissionsResponse,
  BodyLoginAuthLoginPost,
  HTTPValidationError,
  LoginResponse,
  PasswordChangeRequest,
  PasswordChangeResponse,
  UserCreate,
  UserLogin,
  UserUpdate
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';




/**
 * Change password for the current authenticated user.

Verifies the current password, enforces minimal strength, and updates the hash.
 * @summary Change Password
 */
export const changePasswordAuthChangePasswordPost = (
    passwordChangeRequest: PasswordChangeRequest,
 signal?: AbortSignal
) => {


      return customFetch<PasswordChangeResponse>(
      {url: `/auth/change-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: passwordChangeRequest, signal
    },
      );
    }



export const getChangePasswordAuthChangePasswordPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changePasswordAuthChangePasswordPost>>, TError,{data: PasswordChangeRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof changePasswordAuthChangePasswordPost>>, TError,{data: PasswordChangeRequest}, TContext> => {

const mutationKey = ['changePasswordAuthChangePasswordPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof changePasswordAuthChangePasswordPost>>, {data: PasswordChangeRequest}> = (props) => {
          const {data} = props ?? {};

          return  changePasswordAuthChangePasswordPost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type ChangePasswordAuthChangePasswordPostMutationResult = NonNullable<Awaited<ReturnType<typeof changePasswordAuthChangePasswordPost>>>
    export type ChangePasswordAuthChangePasswordPostMutationBody = PasswordChangeRequest
    export type ChangePasswordAuthChangePasswordPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Change Password
 */
export const useChangePasswordAuthChangePasswordPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof changePasswordAuthChangePasswordPost>>, TError,{data: PasswordChangeRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof changePasswordAuthChangePasswordPost>>,
        TError,
        {data: PasswordChangeRequest},
        TContext
      > => {

      const mutationOptions = getChangePasswordAuthChangePasswordPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Login with username (email) and password.

Rate limited to prevent brute force attacks.

Args:
    form_data: OAuth2 form with username and password
    auth_service: Authentication service

Returns:
    LoginResponse: Access token metadata for the client

Raises:
    HTTPException: If credentials are invalid or rate limit exceeded
 * @summary Login
 */
export const loginAuthLoginPost = (
    bodyLoginAuthLoginPost: BodyLoginAuthLoginPost,
 signal?: AbortSignal
) => {

      const formUrlEncoded = new URLSearchParams();
if(bodyLoginAuthLoginPost.client_id !== undefined && bodyLoginAuthLoginPost.client_id !== null) {
 formUrlEncoded.append(`client_id`, bodyLoginAuthLoginPost.client_id)
 }
if(bodyLoginAuthLoginPost.client_secret !== undefined && bodyLoginAuthLoginPost.client_secret !== null) {
 formUrlEncoded.append(`client_secret`, bodyLoginAuthLoginPost.client_secret)
 }
if(bodyLoginAuthLoginPost.grant_type !== undefined && bodyLoginAuthLoginPost.grant_type !== null) {
 formUrlEncoded.append(`grant_type`, bodyLoginAuthLoginPost.grant_type)
 }
formUrlEncoded.append(`password`, bodyLoginAuthLoginPost.password)
if(bodyLoginAuthLoginPost.scope !== undefined) {
 formUrlEncoded.append(`scope`, bodyLoginAuthLoginPost.scope)
 }
formUrlEncoded.append(`username`, bodyLoginAuthLoginPost.username)

      return customFetch<LoginResponse>(
      {url: `/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/x-www-form-urlencoded', },
       data: formUrlEncoded, signal
    },
      );
    }



export const getLoginAuthLoginPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginAuthLoginPost>>, TError,{data: BodyLoginAuthLoginPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof loginAuthLoginPost>>, TError,{data: BodyLoginAuthLoginPost}, TContext> => {

const mutationKey = ['loginAuthLoginPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginAuthLoginPost>>, {data: BodyLoginAuthLoginPost}> = (props) => {
          const {data} = props ?? {};

          return  loginAuthLoginPost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type LoginAuthLoginPostMutationResult = NonNullable<Awaited<ReturnType<typeof loginAuthLoginPost>>>
    export type LoginAuthLoginPostMutationBody = BodyLoginAuthLoginPost
    export type LoginAuthLoginPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Login
 */
export const useLoginAuthLoginPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginAuthLoginPost>>, TError,{data: BodyLoginAuthLoginPost}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof loginAuthLoginPost>>,
        TError,
        {data: BodyLoginAuthLoginPost},
        TContext
      > => {

      const mutationOptions = getLoginAuthLoginPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Login with email and password, optionally converting guest searches.

This endpoint supports guest session conversion.

Args:
    login_data: Login credentials with optional guest_session_id
    auth_service: Authentication service
    db: Database session

Returns:
    LoginResponse: Access token metadata for the client

Raises:
    HTTPException: If credentials are invalid or rate limit exceeded
 * @summary Login With Session
 */
export const loginWithSessionAuthLoginWithSessionPost = (
    userLogin: UserLogin,
 signal?: AbortSignal
) => {


      return customFetch<LoginResponse>(
      {url: `/auth/login-with-session`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userLogin, signal
    },
      );
    }



export const getLoginWithSessionAuthLoginWithSessionPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginWithSessionAuthLoginWithSessionPost>>, TError,{data: UserLogin}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof loginWithSessionAuthLoginWithSessionPost>>, TError,{data: UserLogin}, TContext> => {

const mutationKey = ['loginWithSessionAuthLoginWithSessionPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginWithSessionAuthLoginWithSessionPost>>, {data: UserLogin}> = (props) => {
          const {data} = props ?? {};

          return  loginWithSessionAuthLoginWithSessionPost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type LoginWithSessionAuthLoginWithSessionPostMutationResult = NonNullable<Awaited<ReturnType<typeof loginWithSessionAuthLoginWithSessionPost>>>
    export type LoginWithSessionAuthLoginWithSessionPostMutationBody = UserLogin
    export type LoginWithSessionAuthLoginWithSessionPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Login With Session
 */
export const useLoginWithSessionAuthLoginWithSessionPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginWithSessionAuthLoginWithSessionPost>>, TError,{data: UserLogin}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof loginWithSessionAuthLoginWithSessionPost>>,
        TError,
        {data: UserLogin},
        TContext
      > => {

      const mutationOptions = getLoginWithSessionAuthLoginWithSessionPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get current user information with roles and permissions.

No additional rate limiting as this requires authentication.

Args:
    current_user: Current user email from JWT
    auth_service: Authentication service
    db: Database session

Returns:
    AuthUserWithPermissionsResponse: Current user data with roles and permissions

Raises:
    HTTPException: If user not found
 * @summary Read Users Me
 */
export const readUsersMeAuthMeGet = (

 signal?: AbortSignal
) => {


      return customFetch<AuthUserWithPermissionsResponse>(
      {url: `/auth/me`, method: 'GET', signal
    },
      );
    }




export const getReadUsersMeAuthMeGetQueryKey = () => {
    return [
    `/auth/me`
    ] as const;
    }


export const getReadUsersMeAuthMeGetQueryOptions = <TData = Awaited<ReturnType<typeof readUsersMeAuthMeGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUsersMeAuthMeGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getReadUsersMeAuthMeGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof readUsersMeAuthMeGet>>> = ({ signal }) => readUsersMeAuthMeGet(signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof readUsersMeAuthMeGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ReadUsersMeAuthMeGetQueryResult = NonNullable<Awaited<ReturnType<typeof readUsersMeAuthMeGet>>>
export type ReadUsersMeAuthMeGetQueryError = ErrorType<unknown>


export function useReadUsersMeAuthMeGet<TData = Awaited<ReturnType<typeof readUsersMeAuthMeGet>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUsersMeAuthMeGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof readUsersMeAuthMeGet>>,
          TError,
          Awaited<ReturnType<typeof readUsersMeAuthMeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadUsersMeAuthMeGet<TData = Awaited<ReturnType<typeof readUsersMeAuthMeGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUsersMeAuthMeGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof readUsersMeAuthMeGet>>,
          TError,
          Awaited<ReturnType<typeof readUsersMeAuthMeGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useReadUsersMeAuthMeGet<TData = Awaited<ReturnType<typeof readUsersMeAuthMeGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUsersMeAuthMeGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Users Me
 */

export function useReadUsersMeAuthMeGet<TData = Awaited<ReturnType<typeof readUsersMeAuthMeGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof readUsersMeAuthMeGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getReadUsersMeAuthMeGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update current user's profile (including timezone).

Args:
    user_update: Fields to update
    current_user: Current user email from JWT
    auth_service: Authentication service
    db: Database session

Returns:
    AuthUserWithPermissionsResponse: Updated user data

Raises:
    HTTPException: If user not found or update fails
 * @summary Update Current User
 */
export const updateCurrentUserAuthMePatch = (
    userUpdate: UserUpdate,
 ) => {


      return customFetch<AuthUserWithPermissionsResponse>(
      {url: `/auth/me`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: userUpdate
    },
      );
    }



export const getUpdateCurrentUserAuthMePatchMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCurrentUserAuthMePatch>>, TError,{data: UserUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateCurrentUserAuthMePatch>>, TError,{data: UserUpdate}, TContext> => {

const mutationKey = ['updateCurrentUserAuthMePatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCurrentUserAuthMePatch>>, {data: UserUpdate}> = (props) => {
          const {data} = props ?? {};

          return  updateCurrentUserAuthMePatch(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type UpdateCurrentUserAuthMePatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateCurrentUserAuthMePatch>>>
    export type UpdateCurrentUserAuthMePatchMutationBody = UserUpdate
    export type UpdateCurrentUserAuthMePatchMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Update Current User
 */
export const useUpdateCurrentUserAuthMePatch = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCurrentUserAuthMePatch>>, TError,{data: UserUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateCurrentUserAuthMePatch>>,
        TError,
        {data: UserUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateCurrentUserAuthMePatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Register a new user.

Rate limited to prevent spam registrations.

Args:
    payload: User creation data (including optional guest_session_id)
    auth_service: Authentication service
    db: Database session

Returns:
    AuthUserResponse: The created user

Raises:
    HTTPException: If email already registered or rate limit exceeded
 * @summary Register
 */
export const registerAuthRegisterPost = (
    userCreate: UserCreate,
 signal?: AbortSignal
) => {


      return customFetch<AuthUserResponse>(
      {url: `/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreate, signal
    },
      );
    }



export const getRegisterAuthRegisterPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerAuthRegisterPost>>, TError,{data: UserCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof registerAuthRegisterPost>>, TError,{data: UserCreate}, TContext> => {

const mutationKey = ['registerAuthRegisterPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerAuthRegisterPost>>, {data: UserCreate}> = (props) => {
          const {data} = props ?? {};

          return  registerAuthRegisterPost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type RegisterAuthRegisterPostMutationResult = NonNullable<Awaited<ReturnType<typeof registerAuthRegisterPost>>>
    export type RegisterAuthRegisterPostMutationBody = UserCreate
    export type RegisterAuthRegisterPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Register
 */
export const useRegisterAuthRegisterPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerAuthRegisterPost>>, TError,{data: UserCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof registerAuthRegisterPost>>,
        TError,
        {data: UserCreate},
        TContext
      > => {

      const mutationOptions = getRegisterAuthRegisterPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
