/**
 * Generated by orval v8.4.2 üç∫
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  CheckoutResponse,
  CreateCheckoutRequest,
  CreditBalanceResponse,
  DashboardLinkResponse,
  EarningsExportRequest,
  EarningsResponse,
  GetInstructorPayoutsApiV1PaymentsPayoutsGetParams,
  GetTransactionHistoryApiV1PaymentsTransactionsGetParams,
  HTTPValidationError,
  IdentityRefreshResponse,
  IdentitySessionResponse,
  InstantPayoutResponse,
  OnboardingResponse,
  OnboardingStatusResponse,
  PaymentDeleteResponse,
  PaymentMethodResponse,
  PayoutHistoryResponse,
  PayoutScheduleResponse,
  SavePaymentMethodRequest,
  SetPayoutScheduleApiV1PaymentsConnectPayoutSchedulePostParams,
  StartOnboardingApiV1PaymentsConnectOnboardPostParams,
  TransactionHistoryItem,
  WebhookResponse,
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Create a checkout/payment for a booking.

Args:
    payload: Checkout details including booking and payment method

Returns:
    CheckoutResponse with payment details

Raises:
    HTTPException: If checkout creation fails
 * @summary Create Checkout
 */
export const getCreateCheckoutApiV1PaymentsCheckoutPostUrl = () => {
  return `/api/v1/payments/checkout`;
};

export const createCheckoutApiV1PaymentsCheckoutPost = async (
  createCheckoutRequest: CreateCheckoutRequest,
  options?: RequestInit
): Promise<CheckoutResponse> => {
  return customFetch<CheckoutResponse>(getCreateCheckoutApiV1PaymentsCheckoutPostUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(createCheckoutRequest),
  });
};

export const getCreateCheckoutApiV1PaymentsCheckoutPostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCheckoutApiV1PaymentsCheckoutPost>>,
    TError,
    { data: CreateCheckoutRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createCheckoutApiV1PaymentsCheckoutPost>>,
  TError,
  { data: CreateCheckoutRequest },
  TContext
> => {
  const mutationKey = ['createCheckoutApiV1PaymentsCheckoutPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createCheckoutApiV1PaymentsCheckoutPost>>,
    { data: CreateCheckoutRequest }
  > = (props) => {
    const { data } = props ?? {};

    return createCheckoutApiV1PaymentsCheckoutPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateCheckoutApiV1PaymentsCheckoutPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createCheckoutApiV1PaymentsCheckoutPost>>
>;
export type CreateCheckoutApiV1PaymentsCheckoutPostMutationBody = CreateCheckoutRequest;
export type CreateCheckoutApiV1PaymentsCheckoutPostMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Create Checkout
 */
export const useCreateCheckoutApiV1PaymentsCheckoutPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createCheckoutApiV1PaymentsCheckoutPost>>,
      TError,
      { data: CreateCheckoutRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createCheckoutApiV1PaymentsCheckoutPost>>,
  TError,
  { data: CreateCheckoutRequest },
  TContext
> => {
  return useMutation(
    getCreateCheckoutApiV1PaymentsCheckoutPostMutationOptions(options),
    queryClient
  );
};
/**
 * Get a link to the Stripe Express dashboard for an instructor.

Returns:
    DashboardLinkResponse with dashboard URL

Raises:
    HTTPException: If dashboard link creation fails
 * @summary Get Dashboard Link
 */
export const getGetDashboardLinkApiV1PaymentsConnectDashboardGetUrl = () => {
  return `/api/v1/payments/connect/dashboard`;
};

export const getDashboardLinkApiV1PaymentsConnectDashboardGet = async (
  options?: RequestInit
): Promise<DashboardLinkResponse> => {
  return customFetch<DashboardLinkResponse>(
    getGetDashboardLinkApiV1PaymentsConnectDashboardGetUrl(),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetDashboardLinkApiV1PaymentsConnectDashboardGetQueryKey = () => {
  return [`/api/v1/payments/connect/dashboard`] as const;
};

export const getGetDashboardLinkApiV1PaymentsConnectDashboardGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getDashboardLinkApiV1PaymentsConnectDashboardGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getDashboardLinkApiV1PaymentsConnectDashboardGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetDashboardLinkApiV1PaymentsConnectDashboardGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDashboardLinkApiV1PaymentsConnectDashboardGet>>
  > = ({ signal }) =>
    getDashboardLinkApiV1PaymentsConnectDashboardGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getDashboardLinkApiV1PaymentsConnectDashboardGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetDashboardLinkApiV1PaymentsConnectDashboardGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDashboardLinkApiV1PaymentsConnectDashboardGet>>
>;
export type GetDashboardLinkApiV1PaymentsConnectDashboardGetQueryError = ErrorType<unknown>;

export function useGetDashboardLinkApiV1PaymentsConnectDashboardGet<
  TData = Awaited<ReturnType<typeof getDashboardLinkApiV1PaymentsConnectDashboardGet>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDashboardLinkApiV1PaymentsConnectDashboardGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDashboardLinkApiV1PaymentsConnectDashboardGet>>,
          TError,
          Awaited<ReturnType<typeof getDashboardLinkApiV1PaymentsConnectDashboardGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDashboardLinkApiV1PaymentsConnectDashboardGet<
  TData = Awaited<ReturnType<typeof getDashboardLinkApiV1PaymentsConnectDashboardGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDashboardLinkApiV1PaymentsConnectDashboardGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDashboardLinkApiV1PaymentsConnectDashboardGet>>,
          TError,
          Awaited<ReturnType<typeof getDashboardLinkApiV1PaymentsConnectDashboardGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetDashboardLinkApiV1PaymentsConnectDashboardGet<
  TData = Awaited<ReturnType<typeof getDashboardLinkApiV1PaymentsConnectDashboardGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDashboardLinkApiV1PaymentsConnectDashboardGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Dashboard Link
 */

export function useGetDashboardLinkApiV1PaymentsConnectDashboardGet<
  TData = Awaited<ReturnType<typeof getDashboardLinkApiV1PaymentsConnectDashboardGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDashboardLinkApiV1PaymentsConnectDashboardGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetDashboardLinkApiV1PaymentsConnectDashboardGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Trigger an instant payout for an instructor's connected account.

Uses Stripe's instant payout capability (account eligibility required). This does NOT aggregate platform funds; it
triggers Stripe to pay out the instructor's available balance instantly. We record a metric for adoption.
 * @summary Request Instant Payout
 */
export const getRequestInstantPayoutApiV1PaymentsConnectInstantPayoutPostUrl = () => {
  return `/api/v1/payments/connect/instant-payout`;
};

export const requestInstantPayoutApiV1PaymentsConnectInstantPayoutPost = async (
  options?: RequestInit
): Promise<InstantPayoutResponse> => {
  return customFetch<InstantPayoutResponse>(
    getRequestInstantPayoutApiV1PaymentsConnectInstantPayoutPostUrl(),
    {
      ...options,
      method: 'POST',
    }
  );
};

export const getRequestInstantPayoutApiV1PaymentsConnectInstantPayoutPostMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof requestInstantPayoutApiV1PaymentsConnectInstantPayoutPost>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof requestInstantPayoutApiV1PaymentsConnectInstantPayoutPost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['requestInstantPayoutApiV1PaymentsConnectInstantPayoutPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof requestInstantPayoutApiV1PaymentsConnectInstantPayoutPost>>,
    void
  > = () => {
    return requestInstantPayoutApiV1PaymentsConnectInstantPayoutPost(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RequestInstantPayoutApiV1PaymentsConnectInstantPayoutPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof requestInstantPayoutApiV1PaymentsConnectInstantPayoutPost>>
>;

export type RequestInstantPayoutApiV1PaymentsConnectInstantPayoutPostMutationError =
  ErrorType<unknown>;

/**
 * @summary Request Instant Payout
 */
export const useRequestInstantPayoutApiV1PaymentsConnectInstantPayoutPost = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof requestInstantPayoutApiV1PaymentsConnectInstantPayoutPost>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof requestInstantPayoutApiV1PaymentsConnectInstantPayoutPost>>,
  TError,
  void,
  TContext
> => {
  return useMutation(
    getRequestInstantPayoutApiV1PaymentsConnectInstantPayoutPostMutationOptions(options),
    queryClient
  );
};
/**
 * Start Stripe Connect onboarding for an instructor.

Creates a Stripe Express account and generates an onboarding link.
If the instructor already has an account, returns existing details.

Returns:
    OnboardingResponse with account ID and onboarding URL

Raises:
    HTTPException: If onboarding setup fails
 * @summary Start Onboarding
 */
export const getStartOnboardingApiV1PaymentsConnectOnboardPostUrl = (
  params?: StartOnboardingApiV1PaymentsConnectOnboardPostParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/payments/connect/onboard?${stringifiedParams}`
    : `/api/v1/payments/connect/onboard`;
};

export const startOnboardingApiV1PaymentsConnectOnboardPost = async (
  params?: StartOnboardingApiV1PaymentsConnectOnboardPostParams,
  options?: RequestInit
): Promise<OnboardingResponse> => {
  return customFetch<OnboardingResponse>(
    getStartOnboardingApiV1PaymentsConnectOnboardPostUrl(params),
    {
      ...options,
      method: 'POST',
    }
  );
};

export const getStartOnboardingApiV1PaymentsConnectOnboardPostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof startOnboardingApiV1PaymentsConnectOnboardPost>>,
    TError,
    { params?: StartOnboardingApiV1PaymentsConnectOnboardPostParams },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof startOnboardingApiV1PaymentsConnectOnboardPost>>,
  TError,
  { params?: StartOnboardingApiV1PaymentsConnectOnboardPostParams },
  TContext
> => {
  const mutationKey = ['startOnboardingApiV1PaymentsConnectOnboardPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof startOnboardingApiV1PaymentsConnectOnboardPost>>,
    { params?: StartOnboardingApiV1PaymentsConnectOnboardPostParams }
  > = (props) => {
    const { params } = props ?? {};

    return startOnboardingApiV1PaymentsConnectOnboardPost(params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type StartOnboardingApiV1PaymentsConnectOnboardPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof startOnboardingApiV1PaymentsConnectOnboardPost>>
>;

export type StartOnboardingApiV1PaymentsConnectOnboardPostMutationError =
  ErrorType<HTTPValidationError>;

/**
 * @summary Start Onboarding
 */
export const useStartOnboardingApiV1PaymentsConnectOnboardPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof startOnboardingApiV1PaymentsConnectOnboardPost>>,
      TError,
      { params?: StartOnboardingApiV1PaymentsConnectOnboardPostParams },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof startOnboardingApiV1PaymentsConnectOnboardPost>>,
  TError,
  { params?: StartOnboardingApiV1PaymentsConnectOnboardPostParams },
  TContext
> => {
  return useMutation(
    getStartOnboardingApiV1PaymentsConnectOnboardPostMutationOptions(options),
    queryClient
  );
};
/**
 * Set payout schedule for the current instructor's connected account.

Default: weekly on Tuesday. Valid anchors: monday..sunday.
 * @summary Set Payout Schedule
 */
export const getSetPayoutScheduleApiV1PaymentsConnectPayoutSchedulePostUrl = (
  params?: SetPayoutScheduleApiV1PaymentsConnectPayoutSchedulePostParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/payments/connect/payout-schedule?${stringifiedParams}`
    : `/api/v1/payments/connect/payout-schedule`;
};

export const setPayoutScheduleApiV1PaymentsConnectPayoutSchedulePost = async (
  params?: SetPayoutScheduleApiV1PaymentsConnectPayoutSchedulePostParams,
  options?: RequestInit
): Promise<PayoutScheduleResponse> => {
  return customFetch<PayoutScheduleResponse>(
    getSetPayoutScheduleApiV1PaymentsConnectPayoutSchedulePostUrl(params),
    {
      ...options,
      method: 'POST',
    }
  );
};

export const getSetPayoutScheduleApiV1PaymentsConnectPayoutSchedulePostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof setPayoutScheduleApiV1PaymentsConnectPayoutSchedulePost>>,
    TError,
    { params?: SetPayoutScheduleApiV1PaymentsConnectPayoutSchedulePostParams },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof setPayoutScheduleApiV1PaymentsConnectPayoutSchedulePost>>,
  TError,
  { params?: SetPayoutScheduleApiV1PaymentsConnectPayoutSchedulePostParams },
  TContext
> => {
  const mutationKey = ['setPayoutScheduleApiV1PaymentsConnectPayoutSchedulePost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof setPayoutScheduleApiV1PaymentsConnectPayoutSchedulePost>>,
    { params?: SetPayoutScheduleApiV1PaymentsConnectPayoutSchedulePostParams }
  > = (props) => {
    const { params } = props ?? {};

    return setPayoutScheduleApiV1PaymentsConnectPayoutSchedulePost(params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SetPayoutScheduleApiV1PaymentsConnectPayoutSchedulePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof setPayoutScheduleApiV1PaymentsConnectPayoutSchedulePost>>
>;

export type SetPayoutScheduleApiV1PaymentsConnectPayoutSchedulePostMutationError =
  ErrorType<HTTPValidationError>;

/**
 * @summary Set Payout Schedule
 */
export const useSetPayoutScheduleApiV1PaymentsConnectPayoutSchedulePost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof setPayoutScheduleApiV1PaymentsConnectPayoutSchedulePost>>,
      TError,
      { params?: SetPayoutScheduleApiV1PaymentsConnectPayoutSchedulePostParams },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof setPayoutScheduleApiV1PaymentsConnectPayoutSchedulePost>>,
  TError,
  { params?: SetPayoutScheduleApiV1PaymentsConnectPayoutSchedulePostParams },
  TContext
> => {
  return useMutation(
    getSetPayoutScheduleApiV1PaymentsConnectPayoutSchedulePostMutationOptions(options),
    queryClient
  );
};
/**
 * Get the onboarding status for an instructor's Stripe account.

Returns:
    OnboardingStatusResponse with account status details

Raises:
    HTTPException: If status check fails
 * @summary Get Onboarding Status
 */
export const getGetOnboardingStatusApiV1PaymentsConnectStatusGetUrl = () => {
  return `/api/v1/payments/connect/status`;
};

export const getOnboardingStatusApiV1PaymentsConnectStatusGet = async (
  options?: RequestInit
): Promise<OnboardingStatusResponse> => {
  return customFetch<OnboardingStatusResponse>(
    getGetOnboardingStatusApiV1PaymentsConnectStatusGetUrl(),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetOnboardingStatusApiV1PaymentsConnectStatusGetQueryKey = () => {
  return [`/api/v1/payments/connect/status`] as const;
};

export const getGetOnboardingStatusApiV1PaymentsConnectStatusGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getOnboardingStatusApiV1PaymentsConnectStatusGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getOnboardingStatusApiV1PaymentsConnectStatusGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetOnboardingStatusApiV1PaymentsConnectStatusGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getOnboardingStatusApiV1PaymentsConnectStatusGet>>
  > = ({ signal }) =>
    getOnboardingStatusApiV1PaymentsConnectStatusGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getOnboardingStatusApiV1PaymentsConnectStatusGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetOnboardingStatusApiV1PaymentsConnectStatusGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOnboardingStatusApiV1PaymentsConnectStatusGet>>
>;
export type GetOnboardingStatusApiV1PaymentsConnectStatusGetQueryError = ErrorType<unknown>;

export function useGetOnboardingStatusApiV1PaymentsConnectStatusGet<
  TData = Awaited<ReturnType<typeof getOnboardingStatusApiV1PaymentsConnectStatusGet>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOnboardingStatusApiV1PaymentsConnectStatusGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOnboardingStatusApiV1PaymentsConnectStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getOnboardingStatusApiV1PaymentsConnectStatusGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetOnboardingStatusApiV1PaymentsConnectStatusGet<
  TData = Awaited<ReturnType<typeof getOnboardingStatusApiV1PaymentsConnectStatusGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOnboardingStatusApiV1PaymentsConnectStatusGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOnboardingStatusApiV1PaymentsConnectStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getOnboardingStatusApiV1PaymentsConnectStatusGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetOnboardingStatusApiV1PaymentsConnectStatusGet<
  TData = Awaited<ReturnType<typeof getOnboardingStatusApiV1PaymentsConnectStatusGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOnboardingStatusApiV1PaymentsConnectStatusGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Onboarding Status
 */

export function useGetOnboardingStatusApiV1PaymentsConnectStatusGet<
  TData = Awaited<ReturnType<typeof getOnboardingStatusApiV1PaymentsConnectStatusGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOnboardingStatusApiV1PaymentsConnectStatusGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetOnboardingStatusApiV1PaymentsConnectStatusGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get user's credit balance

Returns available credits and expiration
 * @summary Get Credit Balance
 */
export const getGetCreditBalanceApiV1PaymentsCreditsGetUrl = () => {
  return `/api/v1/payments/credits`;
};

export const getCreditBalanceApiV1PaymentsCreditsGet = async (
  options?: RequestInit
): Promise<CreditBalanceResponse> => {
  return customFetch<CreditBalanceResponse>(getGetCreditBalanceApiV1PaymentsCreditsGetUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getGetCreditBalanceApiV1PaymentsCreditsGetQueryKey = () => {
  return [`/api/v1/payments/credits`] as const;
};

export const getGetCreditBalanceApiV1PaymentsCreditsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getCreditBalanceApiV1PaymentsCreditsGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getCreditBalanceApiV1PaymentsCreditsGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetCreditBalanceApiV1PaymentsCreditsGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getCreditBalanceApiV1PaymentsCreditsGet>>
  > = ({ signal }) => getCreditBalanceApiV1PaymentsCreditsGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getCreditBalanceApiV1PaymentsCreditsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetCreditBalanceApiV1PaymentsCreditsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCreditBalanceApiV1PaymentsCreditsGet>>
>;
export type GetCreditBalanceApiV1PaymentsCreditsGetQueryError = ErrorType<unknown>;

export function useGetCreditBalanceApiV1PaymentsCreditsGet<
  TData = Awaited<ReturnType<typeof getCreditBalanceApiV1PaymentsCreditsGet>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCreditBalanceApiV1PaymentsCreditsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCreditBalanceApiV1PaymentsCreditsGet>>,
          TError,
          Awaited<ReturnType<typeof getCreditBalanceApiV1PaymentsCreditsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCreditBalanceApiV1PaymentsCreditsGet<
  TData = Awaited<ReturnType<typeof getCreditBalanceApiV1PaymentsCreditsGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCreditBalanceApiV1PaymentsCreditsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCreditBalanceApiV1PaymentsCreditsGet>>,
          TError,
          Awaited<ReturnType<typeof getCreditBalanceApiV1PaymentsCreditsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetCreditBalanceApiV1PaymentsCreditsGet<
  TData = Awaited<ReturnType<typeof getCreditBalanceApiV1PaymentsCreditsGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCreditBalanceApiV1PaymentsCreditsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Credit Balance
 */

export function useGetCreditBalanceApiV1PaymentsCreditsGet<
  TData = Awaited<ReturnType<typeof getCreditBalanceApiV1PaymentsCreditsGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getCreditBalanceApiV1PaymentsCreditsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetCreditBalanceApiV1PaymentsCreditsGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get earnings statistics for an instructor.

Returns:
    Instructor earnings data

Raises:
    HTTPException: If earnings calculation fails
 * @summary Get Instructor Earnings
 */
export const getGetInstructorEarningsApiV1PaymentsEarningsGetUrl = () => {
  return `/api/v1/payments/earnings`;
};

export const getInstructorEarningsApiV1PaymentsEarningsGet = async (
  options?: RequestInit
): Promise<EarningsResponse> => {
  return customFetch<EarningsResponse>(getGetInstructorEarningsApiV1PaymentsEarningsGetUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getGetInstructorEarningsApiV1PaymentsEarningsGetQueryKey = () => {
  return [`/api/v1/payments/earnings`] as const;
};

export const getGetInstructorEarningsApiV1PaymentsEarningsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getInstructorEarningsApiV1PaymentsEarningsGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getInstructorEarningsApiV1PaymentsEarningsGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetInstructorEarningsApiV1PaymentsEarningsGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInstructorEarningsApiV1PaymentsEarningsGet>>
  > = ({ signal }) => getInstructorEarningsApiV1PaymentsEarningsGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInstructorEarningsApiV1PaymentsEarningsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInstructorEarningsApiV1PaymentsEarningsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInstructorEarningsApiV1PaymentsEarningsGet>>
>;
export type GetInstructorEarningsApiV1PaymentsEarningsGetQueryError = ErrorType<unknown>;

export function useGetInstructorEarningsApiV1PaymentsEarningsGet<
  TData = Awaited<ReturnType<typeof getInstructorEarningsApiV1PaymentsEarningsGet>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstructorEarningsApiV1PaymentsEarningsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstructorEarningsApiV1PaymentsEarningsGet>>,
          TError,
          Awaited<ReturnType<typeof getInstructorEarningsApiV1PaymentsEarningsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInstructorEarningsApiV1PaymentsEarningsGet<
  TData = Awaited<ReturnType<typeof getInstructorEarningsApiV1PaymentsEarningsGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstructorEarningsApiV1PaymentsEarningsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstructorEarningsApiV1PaymentsEarningsGet>>,
          TError,
          Awaited<ReturnType<typeof getInstructorEarningsApiV1PaymentsEarningsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInstructorEarningsApiV1PaymentsEarningsGet<
  TData = Awaited<ReturnType<typeof getInstructorEarningsApiV1PaymentsEarningsGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstructorEarningsApiV1PaymentsEarningsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Instructor Earnings
 */

export function useGetInstructorEarningsApiV1PaymentsEarningsGet<
  TData = Awaited<ReturnType<typeof getInstructorEarningsApiV1PaymentsEarningsGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstructorEarningsApiV1PaymentsEarningsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInstructorEarningsApiV1PaymentsEarningsGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Export instructor earnings history as CSV.
 * @summary Export Instructor Earnings
 */
export const getExportInstructorEarningsApiV1PaymentsEarningsExportPostUrl = () => {
  return `/api/v1/payments/earnings/export`;
};

export const exportInstructorEarningsApiV1PaymentsEarningsExportPost = async (
  earningsExportRequest: EarningsExportRequest,
  options?: RequestInit
): Promise<unknown> => {
  return customFetch<unknown>(getExportInstructorEarningsApiV1PaymentsEarningsExportPostUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(earningsExportRequest),
  });
};

export const getExportInstructorEarningsApiV1PaymentsEarningsExportPostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof exportInstructorEarningsApiV1PaymentsEarningsExportPost>>,
    TError,
    { data: EarningsExportRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof exportInstructorEarningsApiV1PaymentsEarningsExportPost>>,
  TError,
  { data: EarningsExportRequest },
  TContext
> => {
  const mutationKey = ['exportInstructorEarningsApiV1PaymentsEarningsExportPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof exportInstructorEarningsApiV1PaymentsEarningsExportPost>>,
    { data: EarningsExportRequest }
  > = (props) => {
    const { data } = props ?? {};

    return exportInstructorEarningsApiV1PaymentsEarningsExportPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ExportInstructorEarningsApiV1PaymentsEarningsExportPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof exportInstructorEarningsApiV1PaymentsEarningsExportPost>>
>;
export type ExportInstructorEarningsApiV1PaymentsEarningsExportPostMutationBody =
  EarningsExportRequest;
export type ExportInstructorEarningsApiV1PaymentsEarningsExportPostMutationError =
  ErrorType<HTTPValidationError>;

/**
 * @summary Export Instructor Earnings
 */
export const useExportInstructorEarningsApiV1PaymentsEarningsExportPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof exportInstructorEarningsApiV1PaymentsEarningsExportPost>>,
      TError,
      { data: EarningsExportRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof exportInstructorEarningsApiV1PaymentsEarningsExportPost>>,
  TError,
  { data: EarningsExportRequest },
  TContext
> => {
  return useMutation(
    getExportInstructorEarningsApiV1PaymentsEarningsExportPostMutationOptions(options),
    queryClient
  );
};
/**
 * Fetch latest Stripe Identity status and persist verification on success.

This avoids blocking general status calls and lets the UI trigger a one-off refresh
right after the modal/hosted flow returns.
 * @summary Refresh Identity Status
 */
export const getRefreshIdentityStatusApiV1PaymentsIdentityRefreshPostUrl = () => {
  return `/api/v1/payments/identity/refresh`;
};

export const refreshIdentityStatusApiV1PaymentsIdentityRefreshPost = async (
  options?: RequestInit
): Promise<IdentityRefreshResponse> => {
  return customFetch<IdentityRefreshResponse>(
    getRefreshIdentityStatusApiV1PaymentsIdentityRefreshPostUrl(),
    {
      ...options,
      method: 'POST',
    }
  );
};

export const getRefreshIdentityStatusApiV1PaymentsIdentityRefreshPostMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refreshIdentityStatusApiV1PaymentsIdentityRefreshPost>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof refreshIdentityStatusApiV1PaymentsIdentityRefreshPost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['refreshIdentityStatusApiV1PaymentsIdentityRefreshPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof refreshIdentityStatusApiV1PaymentsIdentityRefreshPost>>,
    void
  > = () => {
    return refreshIdentityStatusApiV1PaymentsIdentityRefreshPost(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RefreshIdentityStatusApiV1PaymentsIdentityRefreshPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof refreshIdentityStatusApiV1PaymentsIdentityRefreshPost>>
>;

export type RefreshIdentityStatusApiV1PaymentsIdentityRefreshPostMutationError = ErrorType<unknown>;

/**
 * @summary Refresh Identity Status
 */
export const useRefreshIdentityStatusApiV1PaymentsIdentityRefreshPost = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof refreshIdentityStatusApiV1PaymentsIdentityRefreshPost>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof refreshIdentityStatusApiV1PaymentsIdentityRefreshPost>>,
  TError,
  void,
  TContext
> => {
  return useMutation(
    getRefreshIdentityStatusApiV1PaymentsIdentityRefreshPostMutationOptions(options),
    queryClient
  );
};
/**
 * Create a Stripe Identity verification session for the current user.
 * @summary Create Identity Session
 */
export const getCreateIdentitySessionApiV1PaymentsIdentitySessionPostUrl = () => {
  return `/api/v1/payments/identity/session`;
};

export const createIdentitySessionApiV1PaymentsIdentitySessionPost = async (
  options?: RequestInit
): Promise<IdentitySessionResponse> => {
  return customFetch<IdentitySessionResponse>(
    getCreateIdentitySessionApiV1PaymentsIdentitySessionPostUrl(),
    {
      ...options,
      method: 'POST',
    }
  );
};

export const getCreateIdentitySessionApiV1PaymentsIdentitySessionPostMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createIdentitySessionApiV1PaymentsIdentitySessionPost>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createIdentitySessionApiV1PaymentsIdentitySessionPost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['createIdentitySessionApiV1PaymentsIdentitySessionPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createIdentitySessionApiV1PaymentsIdentitySessionPost>>,
    void
  > = () => {
    return createIdentitySessionApiV1PaymentsIdentitySessionPost(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateIdentitySessionApiV1PaymentsIdentitySessionPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createIdentitySessionApiV1PaymentsIdentitySessionPost>>
>;

export type CreateIdentitySessionApiV1PaymentsIdentitySessionPostMutationError = ErrorType<unknown>;

/**
 * @summary Create Identity Session
 */
export const useCreateIdentitySessionApiV1PaymentsIdentitySessionPost = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createIdentitySessionApiV1PaymentsIdentitySessionPost>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createIdentitySessionApiV1PaymentsIdentitySessionPost>>,
  TError,
  void,
  TContext
> => {
  return useMutation(
    getCreateIdentitySessionApiV1PaymentsIdentitySessionPostMutationOptions(options),
    queryClient
  );
};
/**
 * List all payment methods for a student.

Returns:
    List of PaymentMethodResponse objects

Raises:
    HTTPException: If payment method listing fails
 * @summary List Payment Methods
 */
export const getListPaymentMethodsApiV1PaymentsMethodsGetUrl = () => {
  return `/api/v1/payments/methods`;
};

export const listPaymentMethodsApiV1PaymentsMethodsGet = async (
  options?: RequestInit
): Promise<PaymentMethodResponse[]> => {
  return customFetch<PaymentMethodResponse[]>(getListPaymentMethodsApiV1PaymentsMethodsGetUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getListPaymentMethodsApiV1PaymentsMethodsGetQueryKey = () => {
  return [`/api/v1/payments/methods`] as const;
};

export const getListPaymentMethodsApiV1PaymentsMethodsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listPaymentMethodsApiV1PaymentsMethodsGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof listPaymentMethodsApiV1PaymentsMethodsGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListPaymentMethodsApiV1PaymentsMethodsGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listPaymentMethodsApiV1PaymentsMethodsGet>>
  > = ({ signal }) => listPaymentMethodsApiV1PaymentsMethodsGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listPaymentMethodsApiV1PaymentsMethodsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListPaymentMethodsApiV1PaymentsMethodsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listPaymentMethodsApiV1PaymentsMethodsGet>>
>;
export type ListPaymentMethodsApiV1PaymentsMethodsGetQueryError = ErrorType<unknown>;

export function useListPaymentMethodsApiV1PaymentsMethodsGet<
  TData = Awaited<ReturnType<typeof listPaymentMethodsApiV1PaymentsMethodsGet>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listPaymentMethodsApiV1PaymentsMethodsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPaymentMethodsApiV1PaymentsMethodsGet>>,
          TError,
          Awaited<ReturnType<typeof listPaymentMethodsApiV1PaymentsMethodsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListPaymentMethodsApiV1PaymentsMethodsGet<
  TData = Awaited<ReturnType<typeof listPaymentMethodsApiV1PaymentsMethodsGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listPaymentMethodsApiV1PaymentsMethodsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPaymentMethodsApiV1PaymentsMethodsGet>>,
          TError,
          Awaited<ReturnType<typeof listPaymentMethodsApiV1PaymentsMethodsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListPaymentMethodsApiV1PaymentsMethodsGet<
  TData = Awaited<ReturnType<typeof listPaymentMethodsApiV1PaymentsMethodsGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listPaymentMethodsApiV1PaymentsMethodsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List Payment Methods
 */

export function useListPaymentMethodsApiV1PaymentsMethodsGet<
  TData = Awaited<ReturnType<typeof listPaymentMethodsApiV1PaymentsMethodsGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listPaymentMethodsApiV1PaymentsMethodsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListPaymentMethodsApiV1PaymentsMethodsGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Save a payment method for a student.

Args:
    payload: Payment method details

Returns:
    PaymentMethodResponse with saved payment method details

Raises:
    HTTPException: If payment method saving fails
 * @summary Save Payment Method
 */
export const getSavePaymentMethodApiV1PaymentsMethodsPostUrl = () => {
  return `/api/v1/payments/methods`;
};

export const savePaymentMethodApiV1PaymentsMethodsPost = async (
  savePaymentMethodRequest: SavePaymentMethodRequest,
  options?: RequestInit
): Promise<PaymentMethodResponse> => {
  return customFetch<PaymentMethodResponse>(getSavePaymentMethodApiV1PaymentsMethodsPostUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(savePaymentMethodRequest),
  });
};

export const getSavePaymentMethodApiV1PaymentsMethodsPostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof savePaymentMethodApiV1PaymentsMethodsPost>>,
    TError,
    { data: SavePaymentMethodRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof savePaymentMethodApiV1PaymentsMethodsPost>>,
  TError,
  { data: SavePaymentMethodRequest },
  TContext
> => {
  const mutationKey = ['savePaymentMethodApiV1PaymentsMethodsPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof savePaymentMethodApiV1PaymentsMethodsPost>>,
    { data: SavePaymentMethodRequest }
  > = (props) => {
    const { data } = props ?? {};

    return savePaymentMethodApiV1PaymentsMethodsPost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type SavePaymentMethodApiV1PaymentsMethodsPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof savePaymentMethodApiV1PaymentsMethodsPost>>
>;
export type SavePaymentMethodApiV1PaymentsMethodsPostMutationBody = SavePaymentMethodRequest;
export type SavePaymentMethodApiV1PaymentsMethodsPostMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Save Payment Method
 */
export const useSavePaymentMethodApiV1PaymentsMethodsPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof savePaymentMethodApiV1PaymentsMethodsPost>>,
      TError,
      { data: SavePaymentMethodRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof savePaymentMethodApiV1PaymentsMethodsPost>>,
  TError,
  { data: SavePaymentMethodRequest },
  TContext
> => {
  return useMutation(
    getSavePaymentMethodApiV1PaymentsMethodsPostMutationOptions(options),
    queryClient
  );
};
/**
 * Delete a payment method for a student.

Args:
    method_id: Payment method ID to delete

Returns:
    Success confirmation

Raises:
    HTTPException: If payment method deletion fails
 * @summary Delete Payment Method
 */
export const getDeletePaymentMethodApiV1PaymentsMethodsMethodIdDeleteUrl = (methodId: string) => {
  return `/api/v1/payments/methods/${methodId}`;
};

export const deletePaymentMethodApiV1PaymentsMethodsMethodIdDelete = async (
  methodId: string,
  options?: RequestInit
): Promise<PaymentDeleteResponse> => {
  return customFetch<PaymentDeleteResponse>(
    getDeletePaymentMethodApiV1PaymentsMethodsMethodIdDeleteUrl(methodId),
    {
      ...options,
      method: 'DELETE',
    }
  );
};

export const getDeletePaymentMethodApiV1PaymentsMethodsMethodIdDeleteMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deletePaymentMethodApiV1PaymentsMethodsMethodIdDelete>>,
    TError,
    { methodId: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deletePaymentMethodApiV1PaymentsMethodsMethodIdDelete>>,
  TError,
  { methodId: string },
  TContext
> => {
  const mutationKey = ['deletePaymentMethodApiV1PaymentsMethodsMethodIdDelete'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deletePaymentMethodApiV1PaymentsMethodsMethodIdDelete>>,
    { methodId: string }
  > = (props) => {
    const { methodId } = props ?? {};

    return deletePaymentMethodApiV1PaymentsMethodsMethodIdDelete(methodId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeletePaymentMethodApiV1PaymentsMethodsMethodIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deletePaymentMethodApiV1PaymentsMethodsMethodIdDelete>>
>;

export type DeletePaymentMethodApiV1PaymentsMethodsMethodIdDeleteMutationError =
  ErrorType<HTTPValidationError>;

/**
 * @summary Delete Payment Method
 */
export const useDeletePaymentMethodApiV1PaymentsMethodsMethodIdDelete = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deletePaymentMethodApiV1PaymentsMethodsMethodIdDelete>>,
      TError,
      { methodId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deletePaymentMethodApiV1PaymentsMethodsMethodIdDelete>>,
  TError,
  { methodId: string },
  TContext
> => {
  return useMutation(
    getDeletePaymentMethodApiV1PaymentsMethodsMethodIdDeleteMutationOptions(options),
    queryClient
  );
};
/**
 * Get payout history for an instructor.

Returns Stripe payout events recorded for the instructor's connected account.

Returns:
    PayoutHistoryResponse with list of payouts and totals

Raises:
    HTTPException: If fetching payouts fails
 * @summary Get Instructor Payouts
 */
export const getGetInstructorPayoutsApiV1PaymentsPayoutsGetUrl = (
  params?: GetInstructorPayoutsApiV1PaymentsPayoutsGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/payments/payouts?${stringifiedParams}`
    : `/api/v1/payments/payouts`;
};

export const getInstructorPayoutsApiV1PaymentsPayoutsGet = async (
  params?: GetInstructorPayoutsApiV1PaymentsPayoutsGetParams,
  options?: RequestInit
): Promise<PayoutHistoryResponse> => {
  return customFetch<PayoutHistoryResponse>(
    getGetInstructorPayoutsApiV1PaymentsPayoutsGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetInstructorPayoutsApiV1PaymentsPayoutsGetQueryKey = (
  params?: GetInstructorPayoutsApiV1PaymentsPayoutsGetParams
) => {
  return [`/api/v1/payments/payouts`, ...(params ? [params] : [])] as const;
};

export const getGetInstructorPayoutsApiV1PaymentsPayoutsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getInstructorPayoutsApiV1PaymentsPayoutsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetInstructorPayoutsApiV1PaymentsPayoutsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstructorPayoutsApiV1PaymentsPayoutsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetInstructorPayoutsApiV1PaymentsPayoutsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInstructorPayoutsApiV1PaymentsPayoutsGet>>
  > = ({ signal }) =>
    getInstructorPayoutsApiV1PaymentsPayoutsGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getInstructorPayoutsApiV1PaymentsPayoutsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetInstructorPayoutsApiV1PaymentsPayoutsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInstructorPayoutsApiV1PaymentsPayoutsGet>>
>;
export type GetInstructorPayoutsApiV1PaymentsPayoutsGetQueryError = ErrorType<HTTPValidationError>;

export function useGetInstructorPayoutsApiV1PaymentsPayoutsGet<
  TData = Awaited<ReturnType<typeof getInstructorPayoutsApiV1PaymentsPayoutsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: undefined | GetInstructorPayoutsApiV1PaymentsPayoutsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstructorPayoutsApiV1PaymentsPayoutsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstructorPayoutsApiV1PaymentsPayoutsGet>>,
          TError,
          Awaited<ReturnType<typeof getInstructorPayoutsApiV1PaymentsPayoutsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInstructorPayoutsApiV1PaymentsPayoutsGet<
  TData = Awaited<ReturnType<typeof getInstructorPayoutsApiV1PaymentsPayoutsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetInstructorPayoutsApiV1PaymentsPayoutsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstructorPayoutsApiV1PaymentsPayoutsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstructorPayoutsApiV1PaymentsPayoutsGet>>,
          TError,
          Awaited<ReturnType<typeof getInstructorPayoutsApiV1PaymentsPayoutsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetInstructorPayoutsApiV1PaymentsPayoutsGet<
  TData = Awaited<ReturnType<typeof getInstructorPayoutsApiV1PaymentsPayoutsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetInstructorPayoutsApiV1PaymentsPayoutsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstructorPayoutsApiV1PaymentsPayoutsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Instructor Payouts
 */

export function useGetInstructorPayoutsApiV1PaymentsPayoutsGet<
  TData = Awaited<ReturnType<typeof getInstructorPayoutsApiV1PaymentsPayoutsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetInstructorPayoutsApiV1PaymentsPayoutsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInstructorPayoutsApiV1PaymentsPayoutsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetInstructorPayoutsApiV1PaymentsPayoutsGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get user's transaction history

Returns list of completed payments with booking details
 * @summary Get Transaction History
 */
export const getGetTransactionHistoryApiV1PaymentsTransactionsGetUrl = (
  params?: GetTransactionHistoryApiV1PaymentsTransactionsGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/payments/transactions?${stringifiedParams}`
    : `/api/v1/payments/transactions`;
};

export const getTransactionHistoryApiV1PaymentsTransactionsGet = async (
  params?: GetTransactionHistoryApiV1PaymentsTransactionsGetParams,
  options?: RequestInit
): Promise<TransactionHistoryItem[]> => {
  return customFetch<TransactionHistoryItem[]>(
    getGetTransactionHistoryApiV1PaymentsTransactionsGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetTransactionHistoryApiV1PaymentsTransactionsGetQueryKey = (
  params?: GetTransactionHistoryApiV1PaymentsTransactionsGetParams
) => {
  return [`/api/v1/payments/transactions`, ...(params ? [params] : [])] as const;
};

export const getGetTransactionHistoryApiV1PaymentsTransactionsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getTransactionHistoryApiV1PaymentsTransactionsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetTransactionHistoryApiV1PaymentsTransactionsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTransactionHistoryApiV1PaymentsTransactionsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetTransactionHistoryApiV1PaymentsTransactionsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTransactionHistoryApiV1PaymentsTransactionsGet>>
  > = ({ signal }) =>
    getTransactionHistoryApiV1PaymentsTransactionsGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getTransactionHistoryApiV1PaymentsTransactionsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTransactionHistoryApiV1PaymentsTransactionsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTransactionHistoryApiV1PaymentsTransactionsGet>>
>;
export type GetTransactionHistoryApiV1PaymentsTransactionsGetQueryError =
  ErrorType<HTTPValidationError>;

export function useGetTransactionHistoryApiV1PaymentsTransactionsGet<
  TData = Awaited<ReturnType<typeof getTransactionHistoryApiV1PaymentsTransactionsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: undefined | GetTransactionHistoryApiV1PaymentsTransactionsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTransactionHistoryApiV1PaymentsTransactionsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransactionHistoryApiV1PaymentsTransactionsGet>>,
          TError,
          Awaited<ReturnType<typeof getTransactionHistoryApiV1PaymentsTransactionsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTransactionHistoryApiV1PaymentsTransactionsGet<
  TData = Awaited<ReturnType<typeof getTransactionHistoryApiV1PaymentsTransactionsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetTransactionHistoryApiV1PaymentsTransactionsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTransactionHistoryApiV1PaymentsTransactionsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransactionHistoryApiV1PaymentsTransactionsGet>>,
          TError,
          Awaited<ReturnType<typeof getTransactionHistoryApiV1PaymentsTransactionsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTransactionHistoryApiV1PaymentsTransactionsGet<
  TData = Awaited<ReturnType<typeof getTransactionHistoryApiV1PaymentsTransactionsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetTransactionHistoryApiV1PaymentsTransactionsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTransactionHistoryApiV1PaymentsTransactionsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Transaction History
 */

export function useGetTransactionHistoryApiV1PaymentsTransactionsGet<
  TData = Awaited<ReturnType<typeof getTransactionHistoryApiV1PaymentsTransactionsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: GetTransactionHistoryApiV1PaymentsTransactionsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTransactionHistoryApiV1PaymentsTransactionsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTransactionHistoryApiV1PaymentsTransactionsGetQueryOptions(
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Handle Stripe webhook events from both platform and connected accounts.

Works with both local development (single secret) and deployed environments (multiple secrets).
Tries each configured webhook secret until one successfully verifies the signature.

Returns:
    Success confirmation (always returns 200 to prevent Stripe retries)

Note:
    This endpoint has no authentication as it uses webhook signature verification
 * @summary Handle Stripe Webhook
 */
export const getHandleStripeWebhookApiV1PaymentsWebhooksStripePostUrl = () => {
  return `/api/v1/payments/webhooks/stripe`;
};

export const handleStripeWebhookApiV1PaymentsWebhooksStripePost = async (
  options?: RequestInit
): Promise<WebhookResponse> => {
  return customFetch<WebhookResponse>(getHandleStripeWebhookApiV1PaymentsWebhooksStripePostUrl(), {
    ...options,
    method: 'POST',
  });
};

export const getHandleStripeWebhookApiV1PaymentsWebhooksStripePostMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof handleStripeWebhookApiV1PaymentsWebhooksStripePost>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof handleStripeWebhookApiV1PaymentsWebhooksStripePost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['handleStripeWebhookApiV1PaymentsWebhooksStripePost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof handleStripeWebhookApiV1PaymentsWebhooksStripePost>>,
    void
  > = () => {
    return handleStripeWebhookApiV1PaymentsWebhooksStripePost(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type HandleStripeWebhookApiV1PaymentsWebhooksStripePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof handleStripeWebhookApiV1PaymentsWebhooksStripePost>>
>;

export type HandleStripeWebhookApiV1PaymentsWebhooksStripePostMutationError = ErrorType<unknown>;

/**
 * @summary Handle Stripe Webhook
 */
export const useHandleStripeWebhookApiV1PaymentsWebhooksStripePost = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof handleStripeWebhookApiV1PaymentsWebhooksStripePost>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof handleStripeWebhookApiV1PaymentsWebhooksStripePost>>,
  TError,
  void,
  TContext
> => {
  return useMutation(
    getHandleStripeWebhookApiV1PaymentsWebhooksStripePostMutationOptions(options),
    queryClient
  );
};
