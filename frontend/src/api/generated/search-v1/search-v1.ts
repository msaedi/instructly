/**
 * Generated by orval v8.4.0 üç∫
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  HTTPValidationError,
  LogSearchClickApiV1SearchClickPostParams,
  NLSearchResponse,
  NlSearchApiV1SearchGetParams,
  PopularQueriesApiV1SearchAnalyticsPopularGetParams,
  PopularQueriesResponse,
  SearchClickRequest,
  SearchClickResponse,
  SearchConfigResetResponse,
  SearchConfigResponse,
  SearchConfigUpdate,
  SearchHealthResponse,
  SearchMetricsApiV1SearchAnalyticsMetricsGetParams,
  SearchMetricsResponse,
  ZeroResultQueriesApiV1SearchAnalyticsZeroResultsGetParams,
  ZeroResultQueriesResponse,
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Natural language search for instructors and services.

Full pipeline search that combines:
- Query parsing (regex + LLM)
- Semantic embedding
- Hybrid vector + text retrieval
- Constraint filtering (price, location, availability)
- Multi-signal ranking

Supports queries like:
- "piano lessons in brooklyn"
- "cheap guitar lessons tomorrow"
- "math tutoring for kids after 5pm"

Args:
    q: Natural language search query
    lat: User latitude (optional, must provide with lng)
    lng: User longitude (optional, must provide with lat)
    region: Region code for location and price threshold lookups (default: nyc)
    limit: Maximum results to return (1-50, default 20)
    response: FastAPI response object for headers
    db: Database session
    cache_service: Cache service for result caching

Returns:
    Search results with ranked instructors and full metadata
 * @summary Nl Search
 */
export const getNlSearchApiV1SearchGetUrl = (params: NlSearchApiV1SearchGetParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/search?${stringifiedParams}` : `/api/v1/search`;
};

export const nlSearchApiV1SearchGet = async (
  params: NlSearchApiV1SearchGetParams,
  options?: RequestInit
): Promise<NLSearchResponse> => {
  return customFetch<NLSearchResponse>(getNlSearchApiV1SearchGetUrl(params), {
    ...options,
    method: 'GET',
  });
};

export const getNlSearchApiV1SearchGetQueryKey = (params?: NlSearchApiV1SearchGetParams) => {
  return [`/api/v1/search`, ...(params ? [params] : [])] as const;
};

export const getNlSearchApiV1SearchGetQueryOptions = <
  TData = Awaited<ReturnType<typeof nlSearchApiV1SearchGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: NlSearchApiV1SearchGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof nlSearchApiV1SearchGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getNlSearchApiV1SearchGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof nlSearchApiV1SearchGet>>> = ({ signal }) =>
    nlSearchApiV1SearchGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof nlSearchApiV1SearchGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type NlSearchApiV1SearchGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof nlSearchApiV1SearchGet>>
>;
export type NlSearchApiV1SearchGetQueryError = ErrorType<HTTPValidationError>;

export function useNlSearchApiV1SearchGet<
  TData = Awaited<ReturnType<typeof nlSearchApiV1SearchGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: NlSearchApiV1SearchGetParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof nlSearchApiV1SearchGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof nlSearchApiV1SearchGet>>,
          TError,
          Awaited<ReturnType<typeof nlSearchApiV1SearchGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useNlSearchApiV1SearchGet<
  TData = Awaited<ReturnType<typeof nlSearchApiV1SearchGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: NlSearchApiV1SearchGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof nlSearchApiV1SearchGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof nlSearchApiV1SearchGet>>,
          TError,
          Awaited<ReturnType<typeof nlSearchApiV1SearchGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useNlSearchApiV1SearchGet<
  TData = Awaited<ReturnType<typeof nlSearchApiV1SearchGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: NlSearchApiV1SearchGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof nlSearchApiV1SearchGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Nl Search
 */

export function useNlSearchApiV1SearchGet<
  TData = Awaited<ReturnType<typeof nlSearchApiV1SearchGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: NlSearchApiV1SearchGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof nlSearchApiV1SearchGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getNlSearchApiV1SearchGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get aggregate search metrics for the last N days. Requires admin access.

Returns metrics including:
- Total searches
- Average latency (p50, p95)
- Average results per search
- Zero result rate
- Cache hit rate
- Degradation rate
 * @summary Search Metrics
 */
export const getSearchMetricsApiV1SearchAnalyticsMetricsGetUrl = (
  params?: SearchMetricsApiV1SearchAnalyticsMetricsGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/search/analytics/metrics?${stringifiedParams}`
    : `/api/v1/search/analytics/metrics`;
};

export const searchMetricsApiV1SearchAnalyticsMetricsGet = async (
  params?: SearchMetricsApiV1SearchAnalyticsMetricsGetParams,
  options?: RequestInit
): Promise<SearchMetricsResponse> => {
  return customFetch<SearchMetricsResponse>(
    getSearchMetricsApiV1SearchAnalyticsMetricsGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getSearchMetricsApiV1SearchAnalyticsMetricsGetQueryKey = (
  params?: SearchMetricsApiV1SearchAnalyticsMetricsGetParams
) => {
  return [`/api/v1/search/analytics/metrics`, ...(params ? [params] : [])] as const;
};

export const getSearchMetricsApiV1SearchAnalyticsMetricsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof searchMetricsApiV1SearchAnalyticsMetricsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: SearchMetricsApiV1SearchAnalyticsMetricsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchMetricsApiV1SearchAnalyticsMetricsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getSearchMetricsApiV1SearchAnalyticsMetricsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof searchMetricsApiV1SearchAnalyticsMetricsGet>>
  > = ({ signal }) =>
    searchMetricsApiV1SearchAnalyticsMetricsGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchMetricsApiV1SearchAnalyticsMetricsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchMetricsApiV1SearchAnalyticsMetricsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchMetricsApiV1SearchAnalyticsMetricsGet>>
>;
export type SearchMetricsApiV1SearchAnalyticsMetricsGetQueryError = ErrorType<HTTPValidationError>;

export function useSearchMetricsApiV1SearchAnalyticsMetricsGet<
  TData = Awaited<ReturnType<typeof searchMetricsApiV1SearchAnalyticsMetricsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: undefined | SearchMetricsApiV1SearchAnalyticsMetricsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchMetricsApiV1SearchAnalyticsMetricsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchMetricsApiV1SearchAnalyticsMetricsGet>>,
          TError,
          Awaited<ReturnType<typeof searchMetricsApiV1SearchAnalyticsMetricsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchMetricsApiV1SearchAnalyticsMetricsGet<
  TData = Awaited<ReturnType<typeof searchMetricsApiV1SearchAnalyticsMetricsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: SearchMetricsApiV1SearchAnalyticsMetricsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchMetricsApiV1SearchAnalyticsMetricsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchMetricsApiV1SearchAnalyticsMetricsGet>>,
          TError,
          Awaited<ReturnType<typeof searchMetricsApiV1SearchAnalyticsMetricsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchMetricsApiV1SearchAnalyticsMetricsGet<
  TData = Awaited<ReturnType<typeof searchMetricsApiV1SearchAnalyticsMetricsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: SearchMetricsApiV1SearchAnalyticsMetricsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchMetricsApiV1SearchAnalyticsMetricsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Search Metrics
 */

export function useSearchMetricsApiV1SearchAnalyticsMetricsGet<
  TData = Awaited<ReturnType<typeof searchMetricsApiV1SearchAnalyticsMetricsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: SearchMetricsApiV1SearchAnalyticsMetricsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof searchMetricsApiV1SearchAnalyticsMetricsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSearchMetricsApiV1SearchAnalyticsMetricsGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get most popular search queries. Requires admin access.
 * @summary Popular Queries
 */
export const getPopularQueriesApiV1SearchAnalyticsPopularGetUrl = (
  params?: PopularQueriesApiV1SearchAnalyticsPopularGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/search/analytics/popular?${stringifiedParams}`
    : `/api/v1/search/analytics/popular`;
};

export const popularQueriesApiV1SearchAnalyticsPopularGet = async (
  params?: PopularQueriesApiV1SearchAnalyticsPopularGetParams,
  options?: RequestInit
): Promise<PopularQueriesResponse> => {
  return customFetch<PopularQueriesResponse>(
    getPopularQueriesApiV1SearchAnalyticsPopularGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getPopularQueriesApiV1SearchAnalyticsPopularGetQueryKey = (
  params?: PopularQueriesApiV1SearchAnalyticsPopularGetParams
) => {
  return [`/api/v1/search/analytics/popular`, ...(params ? [params] : [])] as const;
};

export const getPopularQueriesApiV1SearchAnalyticsPopularGetQueryOptions = <
  TData = Awaited<ReturnType<typeof popularQueriesApiV1SearchAnalyticsPopularGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: PopularQueriesApiV1SearchAnalyticsPopularGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof popularQueriesApiV1SearchAnalyticsPopularGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPopularQueriesApiV1SearchAnalyticsPopularGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof popularQueriesApiV1SearchAnalyticsPopularGet>>
  > = ({ signal }) =>
    popularQueriesApiV1SearchAnalyticsPopularGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof popularQueriesApiV1SearchAnalyticsPopularGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PopularQueriesApiV1SearchAnalyticsPopularGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof popularQueriesApiV1SearchAnalyticsPopularGet>>
>;
export type PopularQueriesApiV1SearchAnalyticsPopularGetQueryError = ErrorType<HTTPValidationError>;

export function usePopularQueriesApiV1SearchAnalyticsPopularGet<
  TData = Awaited<ReturnType<typeof popularQueriesApiV1SearchAnalyticsPopularGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: undefined | PopularQueriesApiV1SearchAnalyticsPopularGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof popularQueriesApiV1SearchAnalyticsPopularGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof popularQueriesApiV1SearchAnalyticsPopularGet>>,
          TError,
          Awaited<ReturnType<typeof popularQueriesApiV1SearchAnalyticsPopularGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function usePopularQueriesApiV1SearchAnalyticsPopularGet<
  TData = Awaited<ReturnType<typeof popularQueriesApiV1SearchAnalyticsPopularGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: PopularQueriesApiV1SearchAnalyticsPopularGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof popularQueriesApiV1SearchAnalyticsPopularGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof popularQueriesApiV1SearchAnalyticsPopularGet>>,
          TError,
          Awaited<ReturnType<typeof popularQueriesApiV1SearchAnalyticsPopularGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function usePopularQueriesApiV1SearchAnalyticsPopularGet<
  TData = Awaited<ReturnType<typeof popularQueriesApiV1SearchAnalyticsPopularGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: PopularQueriesApiV1SearchAnalyticsPopularGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof popularQueriesApiV1SearchAnalyticsPopularGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Popular Queries
 */

export function usePopularQueriesApiV1SearchAnalyticsPopularGet<
  TData = Awaited<ReturnType<typeof popularQueriesApiV1SearchAnalyticsPopularGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: PopularQueriesApiV1SearchAnalyticsPopularGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof popularQueriesApiV1SearchAnalyticsPopularGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getPopularQueriesApiV1SearchAnalyticsPopularGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Get queries that returned zero results. Requires admin access.
 * @summary Zero Result Queries
 */
export const getZeroResultQueriesApiV1SearchAnalyticsZeroResultsGetUrl = (
  params?: ZeroResultQueriesApiV1SearchAnalyticsZeroResultsGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/search/analytics/zero-results?${stringifiedParams}`
    : `/api/v1/search/analytics/zero-results`;
};

export const zeroResultQueriesApiV1SearchAnalyticsZeroResultsGet = async (
  params?: ZeroResultQueriesApiV1SearchAnalyticsZeroResultsGetParams,
  options?: RequestInit
): Promise<ZeroResultQueriesResponse> => {
  return customFetch<ZeroResultQueriesResponse>(
    getZeroResultQueriesApiV1SearchAnalyticsZeroResultsGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getZeroResultQueriesApiV1SearchAnalyticsZeroResultsGetQueryKey = (
  params?: ZeroResultQueriesApiV1SearchAnalyticsZeroResultsGetParams
) => {
  return [`/api/v1/search/analytics/zero-results`, ...(params ? [params] : [])] as const;
};

export const getZeroResultQueriesApiV1SearchAnalyticsZeroResultsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof zeroResultQueriesApiV1SearchAnalyticsZeroResultsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: ZeroResultQueriesApiV1SearchAnalyticsZeroResultsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof zeroResultQueriesApiV1SearchAnalyticsZeroResultsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getZeroResultQueriesApiV1SearchAnalyticsZeroResultsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof zeroResultQueriesApiV1SearchAnalyticsZeroResultsGet>>
  > = ({ signal }) =>
    zeroResultQueriesApiV1SearchAnalyticsZeroResultsGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof zeroResultQueriesApiV1SearchAnalyticsZeroResultsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ZeroResultQueriesApiV1SearchAnalyticsZeroResultsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof zeroResultQueriesApiV1SearchAnalyticsZeroResultsGet>>
>;
export type ZeroResultQueriesApiV1SearchAnalyticsZeroResultsGetQueryError =
  ErrorType<HTTPValidationError>;

export function useZeroResultQueriesApiV1SearchAnalyticsZeroResultsGet<
  TData = Awaited<ReturnType<typeof zeroResultQueriesApiV1SearchAnalyticsZeroResultsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: undefined | ZeroResultQueriesApiV1SearchAnalyticsZeroResultsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof zeroResultQueriesApiV1SearchAnalyticsZeroResultsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof zeroResultQueriesApiV1SearchAnalyticsZeroResultsGet>>,
          TError,
          Awaited<ReturnType<typeof zeroResultQueriesApiV1SearchAnalyticsZeroResultsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useZeroResultQueriesApiV1SearchAnalyticsZeroResultsGet<
  TData = Awaited<ReturnType<typeof zeroResultQueriesApiV1SearchAnalyticsZeroResultsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: ZeroResultQueriesApiV1SearchAnalyticsZeroResultsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof zeroResultQueriesApiV1SearchAnalyticsZeroResultsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof zeroResultQueriesApiV1SearchAnalyticsZeroResultsGet>>,
          TError,
          Awaited<ReturnType<typeof zeroResultQueriesApiV1SearchAnalyticsZeroResultsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useZeroResultQueriesApiV1SearchAnalyticsZeroResultsGet<
  TData = Awaited<ReturnType<typeof zeroResultQueriesApiV1SearchAnalyticsZeroResultsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: ZeroResultQueriesApiV1SearchAnalyticsZeroResultsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof zeroResultQueriesApiV1SearchAnalyticsZeroResultsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Zero Result Queries
 */

export function useZeroResultQueriesApiV1SearchAnalyticsZeroResultsGet<
  TData = Awaited<ReturnType<typeof zeroResultQueriesApiV1SearchAnalyticsZeroResultsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: ZeroResultQueriesApiV1SearchAnalyticsZeroResultsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof zeroResultQueriesApiV1SearchAnalyticsZeroResultsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getZeroResultQueriesApiV1SearchAnalyticsZeroResultsGetQueryOptions(
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Log a click on a search result for conversion tracking.

Call this endpoint when a user interacts with a search result.
Authentication is optional (best-effort).
 * @summary Log Search Click
 */
export const getLogSearchClickApiV1SearchClickPostUrl = (
  params?: LogSearchClickApiV1SearchClickPostParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/search/click?${stringifiedParams}`
    : `/api/v1/search/click`;
};

export const logSearchClickApiV1SearchClickPost = async (
  searchClickRequestNull: SearchClickRequest | null,
  params?: LogSearchClickApiV1SearchClickPostParams,
  options?: RequestInit
): Promise<SearchClickResponse> => {
  return customFetch<SearchClickResponse>(getLogSearchClickApiV1SearchClickPostUrl(params), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(searchClickRequestNull),
  });
};

export const getLogSearchClickApiV1SearchClickPostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof logSearchClickApiV1SearchClickPost>>,
    TError,
    { data: SearchClickRequest | null; params?: LogSearchClickApiV1SearchClickPostParams },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof logSearchClickApiV1SearchClickPost>>,
  TError,
  { data: SearchClickRequest | null; params?: LogSearchClickApiV1SearchClickPostParams },
  TContext
> => {
  const mutationKey = ['logSearchClickApiV1SearchClickPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof logSearchClickApiV1SearchClickPost>>,
    { data: SearchClickRequest | null; params?: LogSearchClickApiV1SearchClickPostParams }
  > = (props) => {
    const { data, params } = props ?? {};

    return logSearchClickApiV1SearchClickPost(data, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type LogSearchClickApiV1SearchClickPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof logSearchClickApiV1SearchClickPost>>
>;
export type LogSearchClickApiV1SearchClickPostMutationBody = SearchClickRequest | null;
export type LogSearchClickApiV1SearchClickPostMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Log Search Click
 */
export const useLogSearchClickApiV1SearchClickPost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof logSearchClickApiV1SearchClickPost>>,
      TError,
      { data: SearchClickRequest | null; params?: LogSearchClickApiV1SearchClickPostParams },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof logSearchClickApiV1SearchClickPost>>,
  TError,
  { data: SearchClickRequest | null; params?: LogSearchClickApiV1SearchClickPostParams },
  TContext
> => {
  return useMutation(getLogSearchClickApiV1SearchClickPostMutationOptions(options), queryClient);
};
/**
 * Get current NL search configuration. Requires admin access.

Returns the currently active models and timeouts along with
available options for the admin UI.
 * @summary Get Config
 */
export const getGetConfigApiV1SearchConfigGetUrl = () => {
  return `/api/v1/search/config`;
};

export const getConfigApiV1SearchConfigGet = async (
  options?: RequestInit
): Promise<SearchConfigResponse> => {
  return customFetch<SearchConfigResponse>(getGetConfigApiV1SearchConfigGetUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getGetConfigApiV1SearchConfigGetQueryKey = () => {
  return [`/api/v1/search/config`] as const;
};

export const getGetConfigApiV1SearchConfigGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getConfigApiV1SearchConfigGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getConfigApiV1SearchConfigGet>>, TError, TData>
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetConfigApiV1SearchConfigGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getConfigApiV1SearchConfigGet>>> = ({
    signal,
  }) => getConfigApiV1SearchConfigGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getConfigApiV1SearchConfigGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetConfigApiV1SearchConfigGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getConfigApiV1SearchConfigGet>>
>;
export type GetConfigApiV1SearchConfigGetQueryError = ErrorType<unknown>;

export function useGetConfigApiV1SearchConfigGet<
  TData = Awaited<ReturnType<typeof getConfigApiV1SearchConfigGet>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getConfigApiV1SearchConfigGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfigApiV1SearchConfigGet>>,
          TError,
          Awaited<ReturnType<typeof getConfigApiV1SearchConfigGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetConfigApiV1SearchConfigGet<
  TData = Awaited<ReturnType<typeof getConfigApiV1SearchConfigGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getConfigApiV1SearchConfigGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getConfigApiV1SearchConfigGet>>,
          TError,
          Awaited<ReturnType<typeof getConfigApiV1SearchConfigGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetConfigApiV1SearchConfigGet<
  TData = Awaited<ReturnType<typeof getConfigApiV1SearchConfigGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getConfigApiV1SearchConfigGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Config
 */

export function useGetConfigApiV1SearchConfigGet<
  TData = Awaited<ReturnType<typeof getConfigApiV1SearchConfigGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getConfigApiV1SearchConfigGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetConfigApiV1SearchConfigGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Update NL search configuration at runtime. Requires admin access.

Changes are temporary (not persisted to environment).
Useful for testing different models without redeployment.
Server restart will revert to environment defaults.

Note: Embedding model cannot be changed at runtime as it requires
re-generating all embeddings in the database.
 * @summary Update Config
 */
export const getUpdateConfigApiV1SearchConfigPutUrl = () => {
  return `/api/v1/search/config`;
};

export const updateConfigApiV1SearchConfigPut = async (
  searchConfigUpdate: SearchConfigUpdate,
  options?: RequestInit
): Promise<SearchConfigResponse> => {
  return customFetch<SearchConfigResponse>(getUpdateConfigApiV1SearchConfigPutUrl(), {
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(searchConfigUpdate),
  });
};

export const getUpdateConfigApiV1SearchConfigPutMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateConfigApiV1SearchConfigPut>>,
    TError,
    { data: SearchConfigUpdate },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateConfigApiV1SearchConfigPut>>,
  TError,
  { data: SearchConfigUpdate },
  TContext
> => {
  const mutationKey = ['updateConfigApiV1SearchConfigPut'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateConfigApiV1SearchConfigPut>>,
    { data: SearchConfigUpdate }
  > = (props) => {
    const { data } = props ?? {};

    return updateConfigApiV1SearchConfigPut(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateConfigApiV1SearchConfigPutMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateConfigApiV1SearchConfigPut>>
>;
export type UpdateConfigApiV1SearchConfigPutMutationBody = SearchConfigUpdate;
export type UpdateConfigApiV1SearchConfigPutMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Update Config
 */
export const useUpdateConfigApiV1SearchConfigPut = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateConfigApiV1SearchConfigPut>>,
      TError,
      { data: SearchConfigUpdate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateConfigApiV1SearchConfigPut>>,
  TError,
  { data: SearchConfigUpdate },
  TContext
> => {
  return useMutation(getUpdateConfigApiV1SearchConfigPutMutationOptions(options), queryClient);
};
/**
 * Reset NL search configuration to environment defaults. Requires admin access.

Use this to revert any runtime changes made via PUT /config.
 * @summary Reset Config
 */
export const getResetConfigApiV1SearchConfigResetPostUrl = () => {
  return `/api/v1/search/config/reset`;
};

export const resetConfigApiV1SearchConfigResetPost = async (
  options?: RequestInit
): Promise<SearchConfigResetResponse> => {
  return customFetch<SearchConfigResetResponse>(getResetConfigApiV1SearchConfigResetPostUrl(), {
    ...options,
    method: 'POST',
  });
};

export const getResetConfigApiV1SearchConfigResetPostMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resetConfigApiV1SearchConfigResetPost>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof resetConfigApiV1SearchConfigResetPost>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ['resetConfigApiV1SearchConfigResetPost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resetConfigApiV1SearchConfigResetPost>>,
    void
  > = () => {
    return resetConfigApiV1SearchConfigResetPost(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ResetConfigApiV1SearchConfigResetPostMutationResult = NonNullable<
  Awaited<ReturnType<typeof resetConfigApiV1SearchConfigResetPost>>
>;

export type ResetConfigApiV1SearchConfigResetPostMutationError = ErrorType<unknown>;

/**
 * @summary Reset Config
 */
export const useResetConfigApiV1SearchConfigResetPost = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof resetConfigApiV1SearchConfigResetPost>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof resetConfigApiV1SearchConfigResetPost>>,
  TError,
  void,
  TContext
> => {
  return useMutation(getResetConfigApiV1SearchConfigResetPostMutationOptions(options), queryClient);
};
/**
 * Health check for search service components.

Returns status of:
- Cache service availability
- Parsing circuit breaker state
- Embedding circuit breaker state

Returns:
    Health status with component details
 * @summary Search Health
 */
export const getSearchHealthApiV1SearchHealthGetUrl = () => {
  return `/api/v1/search/health`;
};

export const searchHealthApiV1SearchHealthGet = async (
  options?: RequestInit
): Promise<SearchHealthResponse> => {
  return customFetch<SearchHealthResponse>(getSearchHealthApiV1SearchHealthGetUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getSearchHealthApiV1SearchHealthGetQueryKey = () => {
  return [`/api/v1/search/health`] as const;
};

export const getSearchHealthApiV1SearchHealthGetQueryOptions = <
  TData = Awaited<ReturnType<typeof searchHealthApiV1SearchHealthGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof searchHealthApiV1SearchHealthGet>>, TError, TData>
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getSearchHealthApiV1SearchHealthGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchHealthApiV1SearchHealthGet>>> = ({
    signal,
  }) => searchHealthApiV1SearchHealthGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof searchHealthApiV1SearchHealthGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SearchHealthApiV1SearchHealthGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchHealthApiV1SearchHealthGet>>
>;
export type SearchHealthApiV1SearchHealthGetQueryError = ErrorType<unknown>;

export function useSearchHealthApiV1SearchHealthGet<
  TData = Awaited<ReturnType<typeof searchHealthApiV1SearchHealthGet>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchHealthApiV1SearchHealthGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchHealthApiV1SearchHealthGet>>,
          TError,
          Awaited<ReturnType<typeof searchHealthApiV1SearchHealthGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchHealthApiV1SearchHealthGet<
  TData = Awaited<ReturnType<typeof searchHealthApiV1SearchHealthGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchHealthApiV1SearchHealthGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchHealthApiV1SearchHealthGet>>,
          TError,
          Awaited<ReturnType<typeof searchHealthApiV1SearchHealthGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useSearchHealthApiV1SearchHealthGet<
  TData = Awaited<ReturnType<typeof searchHealthApiV1SearchHealthGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchHealthApiV1SearchHealthGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Search Health
 */

export function useSearchHealthApiV1SearchHealthGet<
  TData = Awaited<ReturnType<typeof searchHealthApiV1SearchHealthGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchHealthApiV1SearchHealthGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getSearchHealthApiV1SearchHealthGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}
