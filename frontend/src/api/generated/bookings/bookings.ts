/**
 * Generated by orval v7.16.1 ðŸº
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AvailabilityCheckRequest,
  AvailabilityCheckResponse,
  BookingCancel,
  BookingConfirmPayment,
  BookingCreate,
  BookingCreateResponse,
  BookingPaymentMethodUpdate,
  BookingPreviewResponse,
  BookingRescheduleRequest,
  BookingResponse,
  BookingStatsResponse,
  BookingUpdate,
  GetBookingsBookingsGetParams,
  GetUpcomingBookingsBookingsUpcomingGetParams,
  HTTPValidationError,
  PaginatedResponseBookingResponse,
  PaginatedResponseUpcomingBookingResponse,
  SendRemindersResponse
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';




/**
 * Get bookings for the current user with advanced filtering.

Parameters:
- status: Filter by specific booking status
- upcoming/upcoming_only: Only return future bookings (accepts both parameter names)
- exclude_future_confirmed: Exclude future confirmed bookings (for History tab)
- include_past_confirmed: Include past confirmed bookings (for BookAgain)
- page/per_page: Pagination parameters

Returns: Standardized PaginatedResponse with BookingResponse items
 * @summary Get Bookings
 */
export const getBookingsBookingsGet = (
    params?: GetBookingsBookingsGetParams,
 signal?: AbortSignal
) => {


      return customFetch<PaginatedResponseBookingResponse>(
      {url: `/bookings/`, method: 'GET',
        params, signal
    },
      );
    }




export const getGetBookingsBookingsGetQueryKey = (params?: GetBookingsBookingsGetParams,) => {
    return [
    `/bookings/`, ...(params ? [params]: [])
    ] as const;
    }


export const getGetBookingsBookingsGetQueryOptions = <TData = Awaited<ReturnType<typeof getBookingsBookingsGet>>, TError = ErrorType<HTTPValidationError>>(params?: GetBookingsBookingsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingsBookingsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBookingsBookingsGetQueryKey(params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBookingsBookingsGet>>> = ({ signal }) => getBookingsBookingsGet(params, signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBookingsBookingsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBookingsBookingsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getBookingsBookingsGet>>>
export type GetBookingsBookingsGetQueryError = ErrorType<HTTPValidationError>


export function useGetBookingsBookingsGet<TData = Awaited<ReturnType<typeof getBookingsBookingsGet>>, TError = ErrorType<HTTPValidationError>>(
 params: undefined |  GetBookingsBookingsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingsBookingsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookingsBookingsGet>>,
          TError,
          Awaited<ReturnType<typeof getBookingsBookingsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBookingsBookingsGet<TData = Awaited<ReturnType<typeof getBookingsBookingsGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetBookingsBookingsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingsBookingsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookingsBookingsGet>>,
          TError,
          Awaited<ReturnType<typeof getBookingsBookingsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBookingsBookingsGet<TData = Awaited<ReturnType<typeof getBookingsBookingsGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetBookingsBookingsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingsBookingsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Bookings
 */

export function useGetBookingsBookingsGet<TData = Awaited<ReturnType<typeof getBookingsBookingsGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetBookingsBookingsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingsBookingsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBookingsBookingsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a booking with payment setup (Phase 2.1).

Two-step flow:
1. Creates booking with 'pending_payment' status
2. Returns SetupIntent client_secret for card collection
3. Frontend collects card details
4. Call /bookings/{id}/confirm-payment to complete

CLEAN ARCHITECTURE: Uses instructor_id, date, and time range.
No slot references. Bookings are self-contained.

Rate limited per user to prevent booking spam.
 * @summary Create Booking
 */
export const createBookingBookingsPost = (
    bookingCreate: BookingCreate,
 signal?: AbortSignal
) => {


      return customFetch<BookingCreateResponse>(
      {url: `/bookings/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bookingCreate, signal
    },
      );
    }



export const getCreateBookingBookingsPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBookingBookingsPost>>, TError,{data: BookingCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createBookingBookingsPost>>, TError,{data: BookingCreate}, TContext> => {

const mutationKey = ['createBookingBookingsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBookingBookingsPost>>, {data: BookingCreate}> = (props) => {
          const {data} = props ?? {};

          return  createBookingBookingsPost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type CreateBookingBookingsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createBookingBookingsPost>>>
    export type CreateBookingBookingsPostMutationBody = BookingCreate
    export type CreateBookingBookingsPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Create Booking
 */
export const useCreateBookingBookingsPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBookingBookingsPost>>, TError,{data: BookingCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBookingBookingsPost>>,
        TError,
        {data: BookingCreate},
        TContext
      > => {

      const mutationOptions = getCreateBookingBookingsPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Check if a time range is available for booking.

CLEAN ARCHITECTURE: Uses time-based checking.
No slot references. Direct time conflict checking.

Rate limited to prevent abuse of expensive availability checks.
 * @summary Check Availability
 */
export const checkAvailabilityBookingsCheckAvailabilityPost = (
    availabilityCheckRequest: AvailabilityCheckRequest,
 signal?: AbortSignal
) => {


      return customFetch<AvailabilityCheckResponse>(
      {url: `/bookings/check-availability`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: availabilityCheckRequest, signal
    },
      );
    }



export const getCheckAvailabilityBookingsCheckAvailabilityPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkAvailabilityBookingsCheckAvailabilityPost>>, TError,{data: AvailabilityCheckRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof checkAvailabilityBookingsCheckAvailabilityPost>>, TError,{data: AvailabilityCheckRequest}, TContext> => {

const mutationKey = ['checkAvailabilityBookingsCheckAvailabilityPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof checkAvailabilityBookingsCheckAvailabilityPost>>, {data: AvailabilityCheckRequest}> = (props) => {
          const {data} = props ?? {};

          return  checkAvailabilityBookingsCheckAvailabilityPost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type CheckAvailabilityBookingsCheckAvailabilityPostMutationResult = NonNullable<Awaited<ReturnType<typeof checkAvailabilityBookingsCheckAvailabilityPost>>>
    export type CheckAvailabilityBookingsCheckAvailabilityPostMutationBody = AvailabilityCheckRequest
    export type CheckAvailabilityBookingsCheckAvailabilityPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Check Availability
 */
export const useCheckAvailabilityBookingsCheckAvailabilityPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof checkAvailabilityBookingsCheckAvailabilityPost>>, TError,{data: AvailabilityCheckRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof checkAvailabilityBookingsCheckAvailabilityPost>>,
        TError,
        {data: AvailabilityCheckRequest},
        TContext
      > => {

      const mutationOptions = getCheckAvailabilityBookingsCheckAvailabilityPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Send 24-hour reminder emails for tomorrow's bookings.

Should be called by scheduled job/cron.
Rate limited to prevent email spam.

Requires: MANAGE_ALL_BOOKINGS permission (admin only)
 * @summary Send Reminder Emails
 */
export const sendReminderEmailsBookingsSendRemindersPost = (

 signal?: AbortSignal
) => {


      return customFetch<SendRemindersResponse>(
      {url: `/bookings/send-reminders`, method: 'POST', signal
    },
      );
    }



export const getSendReminderEmailsBookingsSendRemindersPostMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendReminderEmailsBookingsSendRemindersPost>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof sendReminderEmailsBookingsSendRemindersPost>>, TError,void, TContext> => {

const mutationKey = ['sendReminderEmailsBookingsSendRemindersPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof sendReminderEmailsBookingsSendRemindersPost>>, void> = () => {


          return  sendReminderEmailsBookingsSendRemindersPost()
        }




  return  { mutationFn, ...mutationOptions }}

    export type SendReminderEmailsBookingsSendRemindersPostMutationResult = NonNullable<Awaited<ReturnType<typeof sendReminderEmailsBookingsSendRemindersPost>>>

    export type SendReminderEmailsBookingsSendRemindersPostMutationError = ErrorType<unknown>

    /**
 * @summary Send Reminder Emails
 */
export const useSendReminderEmailsBookingsSendRemindersPost = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof sendReminderEmailsBookingsSendRemindersPost>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof sendReminderEmailsBookingsSendRemindersPost>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getSendReminderEmailsBookingsSendRemindersPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get booking statistics for instructors.
 * @summary Get Booking Stats
 */
export const getBookingStatsBookingsStatsGet = (

 signal?: AbortSignal
) => {


      return customFetch<BookingStatsResponse>(
      {url: `/bookings/stats`, method: 'GET', signal
    },
      );
    }




export const getGetBookingStatsBookingsStatsGetQueryKey = () => {
    return [
    `/bookings/stats`
    ] as const;
    }


export const getGetBookingStatsBookingsStatsGetQueryOptions = <TData = Awaited<ReturnType<typeof getBookingStatsBookingsStatsGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingStatsBookingsStatsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBookingStatsBookingsStatsGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBookingStatsBookingsStatsGet>>> = ({ signal }) => getBookingStatsBookingsStatsGet(signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBookingStatsBookingsStatsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBookingStatsBookingsStatsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getBookingStatsBookingsStatsGet>>>
export type GetBookingStatsBookingsStatsGetQueryError = ErrorType<unknown>


export function useGetBookingStatsBookingsStatsGet<TData = Awaited<ReturnType<typeof getBookingStatsBookingsStatsGet>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingStatsBookingsStatsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookingStatsBookingsStatsGet>>,
          TError,
          Awaited<ReturnType<typeof getBookingStatsBookingsStatsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBookingStatsBookingsStatsGet<TData = Awaited<ReturnType<typeof getBookingStatsBookingsStatsGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingStatsBookingsStatsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookingStatsBookingsStatsGet>>,
          TError,
          Awaited<ReturnType<typeof getBookingStatsBookingsStatsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBookingStatsBookingsStatsGet<TData = Awaited<ReturnType<typeof getBookingStatsBookingsStatsGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingStatsBookingsStatsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Booking Stats
 */

export function useGetBookingStatsBookingsStatsGet<TData = Awaited<ReturnType<typeof getBookingStatsBookingsStatsGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingStatsBookingsStatsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBookingStatsBookingsStatsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get upcoming bookings for dashboard widget.
 * @summary Get Upcoming Bookings
 */
export const getUpcomingBookingsBookingsUpcomingGet = (
    params?: GetUpcomingBookingsBookingsUpcomingGetParams,
 signal?: AbortSignal
) => {


      return customFetch<PaginatedResponseUpcomingBookingResponse>(
      {url: `/bookings/upcoming`, method: 'GET',
        params, signal
    },
      );
    }




export const getGetUpcomingBookingsBookingsUpcomingGetQueryKey = (params?: GetUpcomingBookingsBookingsUpcomingGetParams,) => {
    return [
    `/bookings/upcoming`, ...(params ? [params]: [])
    ] as const;
    }


export const getGetUpcomingBookingsBookingsUpcomingGetQueryOptions = <TData = Awaited<ReturnType<typeof getUpcomingBookingsBookingsUpcomingGet>>, TError = ErrorType<HTTPValidationError>>(params?: GetUpcomingBookingsBookingsUpcomingGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingBookingsBookingsUpcomingGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUpcomingBookingsBookingsUpcomingGetQueryKey(params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUpcomingBookingsBookingsUpcomingGet>>> = ({ signal }) => getUpcomingBookingsBookingsUpcomingGet(params, signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUpcomingBookingsBookingsUpcomingGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUpcomingBookingsBookingsUpcomingGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUpcomingBookingsBookingsUpcomingGet>>>
export type GetUpcomingBookingsBookingsUpcomingGetQueryError = ErrorType<HTTPValidationError>


export function useGetUpcomingBookingsBookingsUpcomingGet<TData = Awaited<ReturnType<typeof getUpcomingBookingsBookingsUpcomingGet>>, TError = ErrorType<HTTPValidationError>>(
 params: undefined |  GetUpcomingBookingsBookingsUpcomingGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingBookingsBookingsUpcomingGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUpcomingBookingsBookingsUpcomingGet>>,
          TError,
          Awaited<ReturnType<typeof getUpcomingBookingsBookingsUpcomingGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUpcomingBookingsBookingsUpcomingGet<TData = Awaited<ReturnType<typeof getUpcomingBookingsBookingsUpcomingGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetUpcomingBookingsBookingsUpcomingGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingBookingsBookingsUpcomingGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUpcomingBookingsBookingsUpcomingGet>>,
          TError,
          Awaited<ReturnType<typeof getUpcomingBookingsBookingsUpcomingGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUpcomingBookingsBookingsUpcomingGet<TData = Awaited<ReturnType<typeof getUpcomingBookingsBookingsUpcomingGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetUpcomingBookingsBookingsUpcomingGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingBookingsBookingsUpcomingGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Upcoming Bookings
 */

export function useGetUpcomingBookingsBookingsUpcomingGet<TData = Awaited<ReturnType<typeof getUpcomingBookingsBookingsUpcomingGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetUpcomingBookingsBookingsUpcomingGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingBookingsBookingsUpcomingGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUpcomingBookingsBookingsUpcomingGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get full booking details with privacy protection for students.
 * @summary Get Booking Details
 */
export const getBookingDetailsBookingsBookingIdGet = (
    bookingId: string,
 signal?: AbortSignal
) => {


      return customFetch<BookingResponse>(
      {url: `/bookings/${bookingId}`, method: 'GET', signal
    },
      );
    }




export const getGetBookingDetailsBookingsBookingIdGetQueryKey = (bookingId?: string,) => {
    return [
    `/bookings/${bookingId}`
    ] as const;
    }


export const getGetBookingDetailsBookingsBookingIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getBookingDetailsBookingsBookingIdGet>>, TError = ErrorType<HTTPValidationError>>(bookingId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingDetailsBookingsBookingIdGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBookingDetailsBookingsBookingIdGetQueryKey(bookingId);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBookingDetailsBookingsBookingIdGet>>> = ({ signal }) => getBookingDetailsBookingsBookingIdGet(bookingId, signal);





   return  { queryKey, queryFn, enabled: !!(bookingId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBookingDetailsBookingsBookingIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBookingDetailsBookingsBookingIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getBookingDetailsBookingsBookingIdGet>>>
export type GetBookingDetailsBookingsBookingIdGetQueryError = ErrorType<HTTPValidationError>


export function useGetBookingDetailsBookingsBookingIdGet<TData = Awaited<ReturnType<typeof getBookingDetailsBookingsBookingIdGet>>, TError = ErrorType<HTTPValidationError>>(
 bookingId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingDetailsBookingsBookingIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookingDetailsBookingsBookingIdGet>>,
          TError,
          Awaited<ReturnType<typeof getBookingDetailsBookingsBookingIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBookingDetailsBookingsBookingIdGet<TData = Awaited<ReturnType<typeof getBookingDetailsBookingsBookingIdGet>>, TError = ErrorType<HTTPValidationError>>(
 bookingId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingDetailsBookingsBookingIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookingDetailsBookingsBookingIdGet>>,
          TError,
          Awaited<ReturnType<typeof getBookingDetailsBookingsBookingIdGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBookingDetailsBookingsBookingIdGet<TData = Awaited<ReturnType<typeof getBookingDetailsBookingsBookingIdGet>>, TError = ErrorType<HTTPValidationError>>(
 bookingId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingDetailsBookingsBookingIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Booking Details
 */

export function useGetBookingDetailsBookingsBookingIdGet<TData = Awaited<ReturnType<typeof getBookingDetailsBookingsBookingIdGet>>, TError = ErrorType<HTTPValidationError>>(
 bookingId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingDetailsBookingsBookingIdGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBookingDetailsBookingsBookingIdGetQueryOptions(bookingId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update booking details (instructor only).
 * @summary Update Booking
 */
export const updateBookingBookingsBookingIdPatch = (
    bookingId: string,
    bookingUpdate: BookingUpdate,
 ) => {


      return customFetch<BookingResponse>(
      {url: `/bookings/${bookingId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: bookingUpdate
    },
      );
    }



export const getUpdateBookingBookingsBookingIdPatchMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBookingBookingsBookingIdPatch>>, TError,{bookingId: string;data: BookingUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBookingBookingsBookingIdPatch>>, TError,{bookingId: string;data: BookingUpdate}, TContext> => {

const mutationKey = ['updateBookingBookingsBookingIdPatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBookingBookingsBookingIdPatch>>, {bookingId: string;data: BookingUpdate}> = (props) => {
          const {bookingId,data} = props ?? {};

          return  updateBookingBookingsBookingIdPatch(bookingId,data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type UpdateBookingBookingsBookingIdPatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateBookingBookingsBookingIdPatch>>>
    export type UpdateBookingBookingsBookingIdPatchMutationBody = BookingUpdate
    export type UpdateBookingBookingsBookingIdPatchMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Update Booking
 */
export const useUpdateBookingBookingsBookingIdPatch = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBookingBookingsBookingIdPatch>>, TError,{bookingId: string;data: BookingUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBookingBookingsBookingIdPatch>>,
        TError,
        {bookingId: string;data: BookingUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateBookingBookingsBookingIdPatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Cancel a booking.
 * @summary Cancel Booking
 */
export const cancelBookingBookingsBookingIdCancelPost = (
    bookingId: string,
    bookingCancel: BookingCancel,
 signal?: AbortSignal
) => {


      return customFetch<BookingResponse>(
      {url: `/bookings/${bookingId}/cancel`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bookingCancel, signal
    },
      );
    }



export const getCancelBookingBookingsBookingIdCancelPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelBookingBookingsBookingIdCancelPost>>, TError,{bookingId: string;data: BookingCancel}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof cancelBookingBookingsBookingIdCancelPost>>, TError,{bookingId: string;data: BookingCancel}, TContext> => {

const mutationKey = ['cancelBookingBookingsBookingIdCancelPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof cancelBookingBookingsBookingIdCancelPost>>, {bookingId: string;data: BookingCancel}> = (props) => {
          const {bookingId,data} = props ?? {};

          return  cancelBookingBookingsBookingIdCancelPost(bookingId,data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type CancelBookingBookingsBookingIdCancelPostMutationResult = NonNullable<Awaited<ReturnType<typeof cancelBookingBookingsBookingIdCancelPost>>>
    export type CancelBookingBookingsBookingIdCancelPostMutationBody = BookingCancel
    export type CancelBookingBookingsBookingIdCancelPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Cancel Booking
 */
export const useCancelBookingBookingsBookingIdCancelPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof cancelBookingBookingsBookingIdCancelPost>>, TError,{bookingId: string;data: BookingCancel}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof cancelBookingBookingsBookingIdCancelPost>>,
        TError,
        {bookingId: string;data: BookingCancel},
        TContext
      > => {

      const mutationOptions = getCancelBookingBookingsBookingIdCancelPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Mark a booking as completed.

Requires: COMPLETE_BOOKINGS permission (instructor only)
 * @summary Complete Booking
 */
export const completeBookingBookingsBookingIdCompletePost = (
    bookingId: string,
 signal?: AbortSignal
) => {


      return customFetch<BookingResponse>(
      {url: `/bookings/${bookingId}/complete`, method: 'POST', signal
    },
      );
    }



export const getCompleteBookingBookingsBookingIdCompletePostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeBookingBookingsBookingIdCompletePost>>, TError,{bookingId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof completeBookingBookingsBookingIdCompletePost>>, TError,{bookingId: string}, TContext> => {

const mutationKey = ['completeBookingBookingsBookingIdCompletePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof completeBookingBookingsBookingIdCompletePost>>, {bookingId: string}> = (props) => {
          const {bookingId} = props ?? {};

          return  completeBookingBookingsBookingIdCompletePost(bookingId,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type CompleteBookingBookingsBookingIdCompletePostMutationResult = NonNullable<Awaited<ReturnType<typeof completeBookingBookingsBookingIdCompletePost>>>

    export type CompleteBookingBookingsBookingIdCompletePostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Complete Booking
 */
export const useCompleteBookingBookingsBookingIdCompletePost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof completeBookingBookingsBookingIdCompletePost>>, TError,{bookingId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof completeBookingBookingsBookingIdCompletePost>>,
        TError,
        {bookingId: string},
        TContext
      > => {

      const mutationOptions = getCompleteBookingBookingsBookingIdCompletePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Confirm payment method for a booking (Phase 2.1).

Called after frontend collects card details via SetupIntent.
This completes the booking creation flow:
1. Saves payment method to booking
2. Schedules authorization based on lesson timing
3. Updates booking status from 'pending_payment' to 'confirmed'

Args:
    booking_id: The booking to confirm payment for
    payment_data: Payment method ID and save preference

Returns:
    Updated BookingResponse with confirmed status
 * @summary Confirm Booking Payment
 */
export const confirmBookingPaymentBookingsBookingIdConfirmPaymentPost = (
    bookingId: string,
    bookingConfirmPayment: BookingConfirmPayment,
 signal?: AbortSignal
) => {


      return customFetch<BookingResponse>(
      {url: `/bookings/${bookingId}/confirm-payment`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bookingConfirmPayment, signal
    },
      );
    }



export const getConfirmBookingPaymentBookingsBookingIdConfirmPaymentPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof confirmBookingPaymentBookingsBookingIdConfirmPaymentPost>>, TError,{bookingId: string;data: BookingConfirmPayment}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof confirmBookingPaymentBookingsBookingIdConfirmPaymentPost>>, TError,{bookingId: string;data: BookingConfirmPayment}, TContext> => {

const mutationKey = ['confirmBookingPaymentBookingsBookingIdConfirmPaymentPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof confirmBookingPaymentBookingsBookingIdConfirmPaymentPost>>, {bookingId: string;data: BookingConfirmPayment}> = (props) => {
          const {bookingId,data} = props ?? {};

          return  confirmBookingPaymentBookingsBookingIdConfirmPaymentPost(bookingId,data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type ConfirmBookingPaymentBookingsBookingIdConfirmPaymentPostMutationResult = NonNullable<Awaited<ReturnType<typeof confirmBookingPaymentBookingsBookingIdConfirmPaymentPost>>>
    export type ConfirmBookingPaymentBookingsBookingIdConfirmPaymentPostMutationBody = BookingConfirmPayment
    export type ConfirmBookingPaymentBookingsBookingIdConfirmPaymentPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Confirm Booking Payment
 */
export const useConfirmBookingPaymentBookingsBookingIdConfirmPaymentPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof confirmBookingPaymentBookingsBookingIdConfirmPaymentPost>>, TError,{bookingId: string;data: BookingConfirmPayment}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof confirmBookingPaymentBookingsBookingIdConfirmPaymentPost>>,
        TError,
        {bookingId: string;data: BookingConfirmPayment},
        TContext
      > => {

      const mutationOptions = getConfirmBookingPaymentBookingsBookingIdConfirmPaymentPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Update booking payment method and retry authorization immediately.

- Verifies ownership (student)
- Saves payment method (optional set_as_default)
- Retries authorization off-session (immediate if <24h)
 * @summary Update Booking Payment Method
 */
export const updateBookingPaymentMethodBookingsBookingIdPaymentMethodPatch = (
    bookingId: string,
    bookingPaymentMethodUpdate: BookingPaymentMethodUpdate,
 ) => {


      return customFetch<BookingResponse>(
      {url: `/bookings/${bookingId}/payment-method`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: bookingPaymentMethodUpdate
    },
      );
    }



export const getUpdateBookingPaymentMethodBookingsBookingIdPaymentMethodPatchMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBookingPaymentMethodBookingsBookingIdPaymentMethodPatch>>, TError,{bookingId: string;data: BookingPaymentMethodUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateBookingPaymentMethodBookingsBookingIdPaymentMethodPatch>>, TError,{bookingId: string;data: BookingPaymentMethodUpdate}, TContext> => {

const mutationKey = ['updateBookingPaymentMethodBookingsBookingIdPaymentMethodPatch'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBookingPaymentMethodBookingsBookingIdPaymentMethodPatch>>, {bookingId: string;data: BookingPaymentMethodUpdate}> = (props) => {
          const {bookingId,data} = props ?? {};

          return  updateBookingPaymentMethodBookingsBookingIdPaymentMethodPatch(bookingId,data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type UpdateBookingPaymentMethodBookingsBookingIdPaymentMethodPatchMutationResult = NonNullable<Awaited<ReturnType<typeof updateBookingPaymentMethodBookingsBookingIdPaymentMethodPatch>>>
    export type UpdateBookingPaymentMethodBookingsBookingIdPaymentMethodPatchMutationBody = BookingPaymentMethodUpdate
    export type UpdateBookingPaymentMethodBookingsBookingIdPaymentMethodPatchMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Update Booking Payment Method
 */
export const useUpdateBookingPaymentMethodBookingsBookingIdPaymentMethodPatch = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBookingPaymentMethodBookingsBookingIdPaymentMethodPatch>>, TError,{bookingId: string;data: BookingPaymentMethodUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBookingPaymentMethodBookingsBookingIdPaymentMethodPatch>>,
        TError,
        {bookingId: string;data: BookingPaymentMethodUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateBookingPaymentMethodBookingsBookingIdPaymentMethodPatchMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get preview information for a booking.

Clean implementation - returns only meaningful data.
 * @summary Get Booking Preview
 */
export const getBookingPreviewBookingsBookingIdPreviewGet = (
    bookingId: string,
 signal?: AbortSignal
) => {


      return customFetch<BookingPreviewResponse>(
      {url: `/bookings/${bookingId}/preview`, method: 'GET', signal
    },
      );
    }




export const getGetBookingPreviewBookingsBookingIdPreviewGetQueryKey = (bookingId?: string,) => {
    return [
    `/bookings/${bookingId}/preview`
    ] as const;
    }


export const getGetBookingPreviewBookingsBookingIdPreviewGetQueryOptions = <TData = Awaited<ReturnType<typeof getBookingPreviewBookingsBookingIdPreviewGet>>, TError = ErrorType<HTTPValidationError>>(bookingId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingPreviewBookingsBookingIdPreviewGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBookingPreviewBookingsBookingIdPreviewGetQueryKey(bookingId);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBookingPreviewBookingsBookingIdPreviewGet>>> = ({ signal }) => getBookingPreviewBookingsBookingIdPreviewGet(bookingId, signal);





   return  { queryKey, queryFn, enabled: !!(bookingId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBookingPreviewBookingsBookingIdPreviewGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetBookingPreviewBookingsBookingIdPreviewGetQueryResult = NonNullable<Awaited<ReturnType<typeof getBookingPreviewBookingsBookingIdPreviewGet>>>
export type GetBookingPreviewBookingsBookingIdPreviewGetQueryError = ErrorType<HTTPValidationError>


export function useGetBookingPreviewBookingsBookingIdPreviewGet<TData = Awaited<ReturnType<typeof getBookingPreviewBookingsBookingIdPreviewGet>>, TError = ErrorType<HTTPValidationError>>(
 bookingId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingPreviewBookingsBookingIdPreviewGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookingPreviewBookingsBookingIdPreviewGet>>,
          TError,
          Awaited<ReturnType<typeof getBookingPreviewBookingsBookingIdPreviewGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBookingPreviewBookingsBookingIdPreviewGet<TData = Awaited<ReturnType<typeof getBookingPreviewBookingsBookingIdPreviewGet>>, TError = ErrorType<HTTPValidationError>>(
 bookingId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingPreviewBookingsBookingIdPreviewGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBookingPreviewBookingsBookingIdPreviewGet>>,
          TError,
          Awaited<ReturnType<typeof getBookingPreviewBookingsBookingIdPreviewGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetBookingPreviewBookingsBookingIdPreviewGet<TData = Awaited<ReturnType<typeof getBookingPreviewBookingsBookingIdPreviewGet>>, TError = ErrorType<HTTPValidationError>>(
 bookingId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingPreviewBookingsBookingIdPreviewGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Booking Preview
 */

export function useGetBookingPreviewBookingsBookingIdPreviewGet<TData = Awaited<ReturnType<typeof getBookingPreviewBookingsBookingIdPreviewGet>>, TError = ErrorType<HTTPValidationError>>(
 bookingId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getBookingPreviewBookingsBookingIdPreviewGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetBookingPreviewBookingsBookingIdPreviewGetQueryOptions(bookingId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Reschedule flow (server-orchestrated):
- Validates access to the original booking
- Cancels the original booking according to policy (releasing/capturing as needed)
- Creates a new booking with the requested time (using original instructor/service unless overridden)
- Links audit events via payment history; returns the new booking

Note: This keeps UI simple and makes payment windows naturally align to the new schedule.
 * @summary Reschedule Booking
 */
export const rescheduleBookingBookingsBookingIdReschedulePost = (
    bookingId: string,
    bookingRescheduleRequest: BookingRescheduleRequest,
 signal?: AbortSignal
) => {


      return customFetch<BookingResponse>(
      {url: `/bookings/${bookingId}/reschedule`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bookingRescheduleRequest, signal
    },
      );
    }



export const getRescheduleBookingBookingsBookingIdReschedulePostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rescheduleBookingBookingsBookingIdReschedulePost>>, TError,{bookingId: string;data: BookingRescheduleRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof rescheduleBookingBookingsBookingIdReschedulePost>>, TError,{bookingId: string;data: BookingRescheduleRequest}, TContext> => {

const mutationKey = ['rescheduleBookingBookingsBookingIdReschedulePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof rescheduleBookingBookingsBookingIdReschedulePost>>, {bookingId: string;data: BookingRescheduleRequest}> = (props) => {
          const {bookingId,data} = props ?? {};

          return  rescheduleBookingBookingsBookingIdReschedulePost(bookingId,data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type RescheduleBookingBookingsBookingIdReschedulePostMutationResult = NonNullable<Awaited<ReturnType<typeof rescheduleBookingBookingsBookingIdReschedulePost>>>
    export type RescheduleBookingBookingsBookingIdReschedulePostMutationBody = BookingRescheduleRequest
    export type RescheduleBookingBookingsBookingIdReschedulePostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Reschedule Booking
 */
export const useRescheduleBookingBookingsBookingIdReschedulePost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof rescheduleBookingBookingsBookingIdReschedulePost>>, TError,{bookingId: string;data: BookingRescheduleRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof rescheduleBookingBookingsBookingIdReschedulePost>>,
        TError,
        {bookingId: string;data: BookingRescheduleRequest},
        TContext
      > => {

      const mutationOptions = getRescheduleBookingBookingsBookingIdReschedulePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
