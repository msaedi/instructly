/**
 * Generated by orval v7.16.1 ðŸº
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BookingResponse,
  DisputeCompletionInstructorsBookingsBookingIdDisputePostParams,
  GetCompletedBookingsInstructorsBookingsCompletedGetParams,
  GetPendingCompletionBookingsInstructorsBookingsPendingCompletionGetParams,
  GetUpcomingBookingsInstructorsBookingsUpcomingGetParams,
  HTTPValidationError,
  ListInstructorBookingsInstructorsBookingsGetParams,
  MarkLessonCompleteInstructorsBookingsBookingIdCompletePostParams,
  PaginatedResponseBookingResponse
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';




/**
 * @summary List Instructor Bookings
 */
export const listInstructorBookingsInstructorsBookingsGet = (
    params?: ListInstructorBookingsInstructorsBookingsGetParams,
 signal?: AbortSignal
) => {


      return customFetch<PaginatedResponseBookingResponse>(
      {url: `/instructors/bookings/`, method: 'GET',
        params, signal
    },
      );
    }




export const getListInstructorBookingsInstructorsBookingsGetQueryKey = (params?: ListInstructorBookingsInstructorsBookingsGetParams,) => {
    return [
    `/instructors/bookings/`, ...(params ? [params]: [])
    ] as const;
    }


export const getListInstructorBookingsInstructorsBookingsGetQueryOptions = <TData = Awaited<ReturnType<typeof listInstructorBookingsInstructorsBookingsGet>>, TError = ErrorType<HTTPValidationError>>(params?: ListInstructorBookingsInstructorsBookingsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listInstructorBookingsInstructorsBookingsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListInstructorBookingsInstructorsBookingsGetQueryKey(params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof listInstructorBookingsInstructorsBookingsGet>>> = ({ signal }) => listInstructorBookingsInstructorsBookingsGet(params, signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listInstructorBookingsInstructorsBookingsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListInstructorBookingsInstructorsBookingsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listInstructorBookingsInstructorsBookingsGet>>>
export type ListInstructorBookingsInstructorsBookingsGetQueryError = ErrorType<HTTPValidationError>


export function useListInstructorBookingsInstructorsBookingsGet<TData = Awaited<ReturnType<typeof listInstructorBookingsInstructorsBookingsGet>>, TError = ErrorType<HTTPValidationError>>(
 params: undefined |  ListInstructorBookingsInstructorsBookingsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listInstructorBookingsInstructorsBookingsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listInstructorBookingsInstructorsBookingsGet>>,
          TError,
          Awaited<ReturnType<typeof listInstructorBookingsInstructorsBookingsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListInstructorBookingsInstructorsBookingsGet<TData = Awaited<ReturnType<typeof listInstructorBookingsInstructorsBookingsGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: ListInstructorBookingsInstructorsBookingsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listInstructorBookingsInstructorsBookingsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listInstructorBookingsInstructorsBookingsGet>>,
          TError,
          Awaited<ReturnType<typeof listInstructorBookingsInstructorsBookingsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListInstructorBookingsInstructorsBookingsGet<TData = Awaited<ReturnType<typeof listInstructorBookingsInstructorsBookingsGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: ListInstructorBookingsInstructorsBookingsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listInstructorBookingsInstructorsBookingsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Instructor Bookings
 */

export function useListInstructorBookingsInstructorsBookingsGet<TData = Awaited<ReturnType<typeof listInstructorBookingsInstructorsBookingsGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: ListInstructorBookingsInstructorsBookingsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listInstructorBookingsInstructorsBookingsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListInstructorBookingsInstructorsBookingsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get instructor's completed bookings.

Args:
    limit: Maximum number of results
    offset: Pagination offset

Returns:
    List of completed bookings
 * @summary Get Completed Bookings
 */
export const getCompletedBookingsInstructorsBookingsCompletedGet = (
    params?: GetCompletedBookingsInstructorsBookingsCompletedGetParams,
 signal?: AbortSignal
) => {


      return customFetch<PaginatedResponseBookingResponse>(
      {url: `/instructors/bookings/completed`, method: 'GET',
        params, signal
    },
      );
    }




export const getGetCompletedBookingsInstructorsBookingsCompletedGetQueryKey = (params?: GetCompletedBookingsInstructorsBookingsCompletedGetParams,) => {
    return [
    `/instructors/bookings/completed`, ...(params ? [params]: [])
    ] as const;
    }


export const getGetCompletedBookingsInstructorsBookingsCompletedGetQueryOptions = <TData = Awaited<ReturnType<typeof getCompletedBookingsInstructorsBookingsCompletedGet>>, TError = ErrorType<HTTPValidationError>>(params?: GetCompletedBookingsInstructorsBookingsCompletedGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompletedBookingsInstructorsBookingsCompletedGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCompletedBookingsInstructorsBookingsCompletedGetQueryKey(params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCompletedBookingsInstructorsBookingsCompletedGet>>> = ({ signal }) => getCompletedBookingsInstructorsBookingsCompletedGet(params, signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCompletedBookingsInstructorsBookingsCompletedGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCompletedBookingsInstructorsBookingsCompletedGetQueryResult = NonNullable<Awaited<ReturnType<typeof getCompletedBookingsInstructorsBookingsCompletedGet>>>
export type GetCompletedBookingsInstructorsBookingsCompletedGetQueryError = ErrorType<HTTPValidationError>


export function useGetCompletedBookingsInstructorsBookingsCompletedGet<TData = Awaited<ReturnType<typeof getCompletedBookingsInstructorsBookingsCompletedGet>>, TError = ErrorType<HTTPValidationError>>(
 params: undefined |  GetCompletedBookingsInstructorsBookingsCompletedGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompletedBookingsInstructorsBookingsCompletedGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompletedBookingsInstructorsBookingsCompletedGet>>,
          TError,
          Awaited<ReturnType<typeof getCompletedBookingsInstructorsBookingsCompletedGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCompletedBookingsInstructorsBookingsCompletedGet<TData = Awaited<ReturnType<typeof getCompletedBookingsInstructorsBookingsCompletedGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetCompletedBookingsInstructorsBookingsCompletedGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompletedBookingsInstructorsBookingsCompletedGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCompletedBookingsInstructorsBookingsCompletedGet>>,
          TError,
          Awaited<ReturnType<typeof getCompletedBookingsInstructorsBookingsCompletedGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCompletedBookingsInstructorsBookingsCompletedGet<TData = Awaited<ReturnType<typeof getCompletedBookingsInstructorsBookingsCompletedGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetCompletedBookingsInstructorsBookingsCompletedGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompletedBookingsInstructorsBookingsCompletedGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Completed Bookings
 */

export function useGetCompletedBookingsInstructorsBookingsCompletedGet<TData = Awaited<ReturnType<typeof getCompletedBookingsInstructorsBookingsCompletedGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetCompletedBookingsInstructorsBookingsCompletedGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCompletedBookingsInstructorsBookingsCompletedGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCompletedBookingsInstructorsBookingsCompletedGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all bookings that are pending completion by the instructor.

Returns bookings that:
- Are confirmed status
- Have ended (based on date/time)
- Haven't been marked complete yet
 * @summary Get Pending Completion Bookings
 */
export const getPendingCompletionBookingsInstructorsBookingsPendingCompletionGet = (
    params?: GetPendingCompletionBookingsInstructorsBookingsPendingCompletionGetParams,
 signal?: AbortSignal
) => {


      return customFetch<PaginatedResponseBookingResponse>(
      {url: `/instructors/bookings/pending-completion`, method: 'GET',
        params, signal
    },
      );
    }




export const getGetPendingCompletionBookingsInstructorsBookingsPendingCompletionGetQueryKey = (params?: GetPendingCompletionBookingsInstructorsBookingsPendingCompletionGetParams,) => {
    return [
    `/instructors/bookings/pending-completion`, ...(params ? [params]: [])
    ] as const;
    }


export const getGetPendingCompletionBookingsInstructorsBookingsPendingCompletionGetQueryOptions = <TData = Awaited<ReturnType<typeof getPendingCompletionBookingsInstructorsBookingsPendingCompletionGet>>, TError = ErrorType<HTTPValidationError>>(params?: GetPendingCompletionBookingsInstructorsBookingsPendingCompletionGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingCompletionBookingsInstructorsBookingsPendingCompletionGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPendingCompletionBookingsInstructorsBookingsPendingCompletionGetQueryKey(params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPendingCompletionBookingsInstructorsBookingsPendingCompletionGet>>> = ({ signal }) => getPendingCompletionBookingsInstructorsBookingsPendingCompletionGet(params, signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPendingCompletionBookingsInstructorsBookingsPendingCompletionGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetPendingCompletionBookingsInstructorsBookingsPendingCompletionGetQueryResult = NonNullable<Awaited<ReturnType<typeof getPendingCompletionBookingsInstructorsBookingsPendingCompletionGet>>>
export type GetPendingCompletionBookingsInstructorsBookingsPendingCompletionGetQueryError = ErrorType<HTTPValidationError>


export function useGetPendingCompletionBookingsInstructorsBookingsPendingCompletionGet<TData = Awaited<ReturnType<typeof getPendingCompletionBookingsInstructorsBookingsPendingCompletionGet>>, TError = ErrorType<HTTPValidationError>>(
 params: undefined |  GetPendingCompletionBookingsInstructorsBookingsPendingCompletionGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingCompletionBookingsInstructorsBookingsPendingCompletionGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingCompletionBookingsInstructorsBookingsPendingCompletionGet>>,
          TError,
          Awaited<ReturnType<typeof getPendingCompletionBookingsInstructorsBookingsPendingCompletionGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPendingCompletionBookingsInstructorsBookingsPendingCompletionGet<TData = Awaited<ReturnType<typeof getPendingCompletionBookingsInstructorsBookingsPendingCompletionGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetPendingCompletionBookingsInstructorsBookingsPendingCompletionGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingCompletionBookingsInstructorsBookingsPendingCompletionGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPendingCompletionBookingsInstructorsBookingsPendingCompletionGet>>,
          TError,
          Awaited<ReturnType<typeof getPendingCompletionBookingsInstructorsBookingsPendingCompletionGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetPendingCompletionBookingsInstructorsBookingsPendingCompletionGet<TData = Awaited<ReturnType<typeof getPendingCompletionBookingsInstructorsBookingsPendingCompletionGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetPendingCompletionBookingsInstructorsBookingsPendingCompletionGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingCompletionBookingsInstructorsBookingsPendingCompletionGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Pending Completion Bookings
 */

export function useGetPendingCompletionBookingsInstructorsBookingsPendingCompletionGet<TData = Awaited<ReturnType<typeof getPendingCompletionBookingsInstructorsBookingsPendingCompletionGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetPendingCompletionBookingsInstructorsBookingsPendingCompletionGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPendingCompletionBookingsInstructorsBookingsPendingCompletionGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetPendingCompletionBookingsInstructorsBookingsPendingCompletionGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Return instructor's upcoming confirmed bookings.
 * @summary Get Upcoming Bookings
 */
export const getUpcomingBookingsInstructorsBookingsUpcomingGet = (
    params?: GetUpcomingBookingsInstructorsBookingsUpcomingGetParams,
 signal?: AbortSignal
) => {


      return customFetch<PaginatedResponseBookingResponse>(
      {url: `/instructors/bookings/upcoming`, method: 'GET',
        params, signal
    },
      );
    }




export const getGetUpcomingBookingsInstructorsBookingsUpcomingGetQueryKey = (params?: GetUpcomingBookingsInstructorsBookingsUpcomingGetParams,) => {
    return [
    `/instructors/bookings/upcoming`, ...(params ? [params]: [])
    ] as const;
    }


export const getGetUpcomingBookingsInstructorsBookingsUpcomingGetQueryOptions = <TData = Awaited<ReturnType<typeof getUpcomingBookingsInstructorsBookingsUpcomingGet>>, TError = ErrorType<HTTPValidationError>>(params?: GetUpcomingBookingsInstructorsBookingsUpcomingGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingBookingsInstructorsBookingsUpcomingGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUpcomingBookingsInstructorsBookingsUpcomingGetQueryKey(params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUpcomingBookingsInstructorsBookingsUpcomingGet>>> = ({ signal }) => getUpcomingBookingsInstructorsBookingsUpcomingGet(params, signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUpcomingBookingsInstructorsBookingsUpcomingGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetUpcomingBookingsInstructorsBookingsUpcomingGetQueryResult = NonNullable<Awaited<ReturnType<typeof getUpcomingBookingsInstructorsBookingsUpcomingGet>>>
export type GetUpcomingBookingsInstructorsBookingsUpcomingGetQueryError = ErrorType<HTTPValidationError>


export function useGetUpcomingBookingsInstructorsBookingsUpcomingGet<TData = Awaited<ReturnType<typeof getUpcomingBookingsInstructorsBookingsUpcomingGet>>, TError = ErrorType<HTTPValidationError>>(
 params: undefined |  GetUpcomingBookingsInstructorsBookingsUpcomingGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingBookingsInstructorsBookingsUpcomingGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUpcomingBookingsInstructorsBookingsUpcomingGet>>,
          TError,
          Awaited<ReturnType<typeof getUpcomingBookingsInstructorsBookingsUpcomingGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUpcomingBookingsInstructorsBookingsUpcomingGet<TData = Awaited<ReturnType<typeof getUpcomingBookingsInstructorsBookingsUpcomingGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetUpcomingBookingsInstructorsBookingsUpcomingGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingBookingsInstructorsBookingsUpcomingGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUpcomingBookingsInstructorsBookingsUpcomingGet>>,
          TError,
          Awaited<ReturnType<typeof getUpcomingBookingsInstructorsBookingsUpcomingGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetUpcomingBookingsInstructorsBookingsUpcomingGet<TData = Awaited<ReturnType<typeof getUpcomingBookingsInstructorsBookingsUpcomingGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetUpcomingBookingsInstructorsBookingsUpcomingGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingBookingsInstructorsBookingsUpcomingGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Upcoming Bookings
 */

export function useGetUpcomingBookingsInstructorsBookingsUpcomingGet<TData = Awaited<ReturnType<typeof getUpcomingBookingsInstructorsBookingsUpcomingGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetUpcomingBookingsInstructorsBookingsUpcomingGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUpcomingBookingsInstructorsBookingsUpcomingGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetUpcomingBookingsInstructorsBookingsUpcomingGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Mark a lesson as completed by the instructor.

This triggers the 24-hour payment capture timer. The payment will be
captured 24 hours after this endpoint is called, giving the student
time to dispute if needed.

Args:
    booking_id: The booking to mark as complete
    notes: Optional completion notes from instructor

Returns:
    Updated booking information

Raises:
    404: Booking not found
    422: Booking cannot be marked complete (wrong status, not instructor's booking)
 * @summary Mark Lesson Complete
 */
export const markLessonCompleteInstructorsBookingsBookingIdCompletePost = (
    bookingId: string,
    params?: MarkLessonCompleteInstructorsBookingsBookingIdCompletePostParams,
 signal?: AbortSignal
) => {


      return customFetch<BookingResponse>(
      {url: `/instructors/bookings/${bookingId}/complete`, method: 'POST',
        params, signal
    },
      );
    }



export const getMarkLessonCompleteInstructorsBookingsBookingIdCompletePostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof markLessonCompleteInstructorsBookingsBookingIdCompletePost>>, TError,{bookingId: string;params?: MarkLessonCompleteInstructorsBookingsBookingIdCompletePostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof markLessonCompleteInstructorsBookingsBookingIdCompletePost>>, TError,{bookingId: string;params?: MarkLessonCompleteInstructorsBookingsBookingIdCompletePostParams}, TContext> => {

const mutationKey = ['markLessonCompleteInstructorsBookingsBookingIdCompletePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof markLessonCompleteInstructorsBookingsBookingIdCompletePost>>, {bookingId: string;params?: MarkLessonCompleteInstructorsBookingsBookingIdCompletePostParams}> = (props) => {
          const {bookingId,params} = props ?? {};

          return  markLessonCompleteInstructorsBookingsBookingIdCompletePost(bookingId,params,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type MarkLessonCompleteInstructorsBookingsBookingIdCompletePostMutationResult = NonNullable<Awaited<ReturnType<typeof markLessonCompleteInstructorsBookingsBookingIdCompletePost>>>

    export type MarkLessonCompleteInstructorsBookingsBookingIdCompletePostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Mark Lesson Complete
 */
export const useMarkLessonCompleteInstructorsBookingsBookingIdCompletePost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof markLessonCompleteInstructorsBookingsBookingIdCompletePost>>, TError,{bookingId: string;params?: MarkLessonCompleteInstructorsBookingsBookingIdCompletePostParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof markLessonCompleteInstructorsBookingsBookingIdCompletePost>>,
        TError,
        {bookingId: string;params?: MarkLessonCompleteInstructorsBookingsBookingIdCompletePostParams},
        TContext
      > => {

      const mutationOptions = getMarkLessonCompleteInstructorsBookingsBookingIdCompletePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Dispute a lesson completion as an instructor.

Used when a student marks a lesson as complete but the instructor disagrees.
This pauses payment capture pending resolution.

Args:
    booking_id: The booking to dispute
    reason: Reason for disputing the completion

Returns:
    Updated booking information
 * @summary Dispute Completion
 */
export const disputeCompletionInstructorsBookingsBookingIdDisputePost = (
    bookingId: string,
    params: DisputeCompletionInstructorsBookingsBookingIdDisputePostParams,
 signal?: AbortSignal
) => {


      return customFetch<BookingResponse>(
      {url: `/instructors/bookings/${bookingId}/dispute`, method: 'POST',
        params, signal
    },
      );
    }



export const getDisputeCompletionInstructorsBookingsBookingIdDisputePostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof disputeCompletionInstructorsBookingsBookingIdDisputePost>>, TError,{bookingId: string;params: DisputeCompletionInstructorsBookingsBookingIdDisputePostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof disputeCompletionInstructorsBookingsBookingIdDisputePost>>, TError,{bookingId: string;params: DisputeCompletionInstructorsBookingsBookingIdDisputePostParams}, TContext> => {

const mutationKey = ['disputeCompletionInstructorsBookingsBookingIdDisputePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof disputeCompletionInstructorsBookingsBookingIdDisputePost>>, {bookingId: string;params: DisputeCompletionInstructorsBookingsBookingIdDisputePostParams}> = (props) => {
          const {bookingId,params} = props ?? {};

          return  disputeCompletionInstructorsBookingsBookingIdDisputePost(bookingId,params,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type DisputeCompletionInstructorsBookingsBookingIdDisputePostMutationResult = NonNullable<Awaited<ReturnType<typeof disputeCompletionInstructorsBookingsBookingIdDisputePost>>>

    export type DisputeCompletionInstructorsBookingsBookingIdDisputePostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Dispute Completion
 */
export const useDisputeCompletionInstructorsBookingsBookingIdDisputePost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof disputeCompletionInstructorsBookingsBookingIdDisputePost>>, TError,{bookingId: string;params: DisputeCompletionInstructorsBookingsBookingIdDisputePostParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof disputeCompletionInstructorsBookingsBookingIdDisputePost>>,
        TError,
        {bookingId: string;params: DisputeCompletionInstructorsBookingsBookingIdDisputePostParams},
        TContext
      > => {

      const mutationOptions = getDisputeCompletionInstructorsBookingsBookingIdDisputePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
