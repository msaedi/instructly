/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  AddressCreate,
  AddressDeleteResponse,
  AddressListResponse,
  AddressResponse,
  AddressUpdate,
  AutocompleteResponse,
  CoverageFeatureCollectionResponse,
  GetBulkCoverageGeojsonApiV1AddressesCoverageBulkGetParams,
  HTTPValidationError,
  IsNycZipApiV1AddressesZipIsNycGetParams,
  ListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGetParams,
  NYCZipCheckResponse,
  NeighborhoodsListResponse,
  PlaceDetails,
  PlaceDetailsApiV1AddressesPlacesDetailsGetParams,
  PlacesAutocompleteApiV1AddressesPlacesAutocompleteGetParams,
  ServiceAreasResponse,
  ServiceAreasUpdateRequest,
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Return GeoJSON FeatureCollection of neighborhoods served by the given instructors.

'ids' is a comma-separated list of instructor user IDs.
 * @summary Get Bulk Coverage Geojson
 */
export const getGetBulkCoverageGeojsonApiV1AddressesCoverageBulkGetUrl = (
  params: GetBulkCoverageGeojsonApiV1AddressesCoverageBulkGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/addresses/coverage/bulk?${stringifiedParams}`
    : `/api/v1/addresses/coverage/bulk`;
};

export const getBulkCoverageGeojsonApiV1AddressesCoverageBulkGet = async (
  params: GetBulkCoverageGeojsonApiV1AddressesCoverageBulkGetParams,
  options?: RequestInit
): Promise<CoverageFeatureCollectionResponse> => {
  return customFetch<CoverageFeatureCollectionResponse>(
    getGetBulkCoverageGeojsonApiV1AddressesCoverageBulkGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetBulkCoverageGeojsonApiV1AddressesCoverageBulkGetQueryKey = (
  params?: GetBulkCoverageGeojsonApiV1AddressesCoverageBulkGetParams
) => {
  return [`/api/v1/addresses/coverage/bulk`, ...(params ? [params] : [])] as const;
};

export const getGetBulkCoverageGeojsonApiV1AddressesCoverageBulkGetQueryOptions = <
  TData = Awaited<ReturnType<typeof getBulkCoverageGeojsonApiV1AddressesCoverageBulkGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetBulkCoverageGeojsonApiV1AddressesCoverageBulkGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBulkCoverageGeojsonApiV1AddressesCoverageBulkGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetBulkCoverageGeojsonApiV1AddressesCoverageBulkGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getBulkCoverageGeojsonApiV1AddressesCoverageBulkGet>>
  > = ({ signal }) =>
    getBulkCoverageGeojsonApiV1AddressesCoverageBulkGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBulkCoverageGeojsonApiV1AddressesCoverageBulkGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBulkCoverageGeojsonApiV1AddressesCoverageBulkGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBulkCoverageGeojsonApiV1AddressesCoverageBulkGet>>
>;
export type GetBulkCoverageGeojsonApiV1AddressesCoverageBulkGetQueryError =
  ErrorType<HTTPValidationError>;

export function useGetBulkCoverageGeojsonApiV1AddressesCoverageBulkGet<
  TData = Awaited<ReturnType<typeof getBulkCoverageGeojsonApiV1AddressesCoverageBulkGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetBulkCoverageGeojsonApiV1AddressesCoverageBulkGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBulkCoverageGeojsonApiV1AddressesCoverageBulkGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBulkCoverageGeojsonApiV1AddressesCoverageBulkGet>>,
          TError,
          Awaited<ReturnType<typeof getBulkCoverageGeojsonApiV1AddressesCoverageBulkGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBulkCoverageGeojsonApiV1AddressesCoverageBulkGet<
  TData = Awaited<ReturnType<typeof getBulkCoverageGeojsonApiV1AddressesCoverageBulkGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetBulkCoverageGeojsonApiV1AddressesCoverageBulkGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBulkCoverageGeojsonApiV1AddressesCoverageBulkGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getBulkCoverageGeojsonApiV1AddressesCoverageBulkGet>>,
          TError,
          Awaited<ReturnType<typeof getBulkCoverageGeojsonApiV1AddressesCoverageBulkGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBulkCoverageGeojsonApiV1AddressesCoverageBulkGet<
  TData = Awaited<ReturnType<typeof getBulkCoverageGeojsonApiV1AddressesCoverageBulkGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetBulkCoverageGeojsonApiV1AddressesCoverageBulkGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBulkCoverageGeojsonApiV1AddressesCoverageBulkGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Bulk Coverage Geojson
 */

export function useGetBulkCoverageGeojsonApiV1AddressesCoverageBulkGet<
  TData = Awaited<ReturnType<typeof getBulkCoverageGeojsonApiV1AddressesCoverageBulkGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: GetBulkCoverageGeojsonApiV1AddressesCoverageBulkGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getBulkCoverageGeojsonApiV1AddressesCoverageBulkGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetBulkCoverageGeojsonApiV1AddressesCoverageBulkGetQueryOptions(
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * List all addresses for the current user.
 * @summary List My Addresses
 */
export const getListMyAddressesApiV1AddressesMeGetUrl = () => {
  return `/api/v1/addresses/me`;
};

export const listMyAddressesApiV1AddressesMeGet = async (
  options?: RequestInit
): Promise<AddressListResponse> => {
  return customFetch<AddressListResponse>(getListMyAddressesApiV1AddressesMeGetUrl(), {
    ...options,
    method: 'GET',
  });
};

export const getListMyAddressesApiV1AddressesMeGetQueryKey = () => {
  return [`/api/v1/addresses/me`] as const;
};

export const getListMyAddressesApiV1AddressesMeGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listMyAddressesApiV1AddressesMeGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof listMyAddressesApiV1AddressesMeGet>>, TError, TData>
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListMyAddressesApiV1AddressesMeGetQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listMyAddressesApiV1AddressesMeGet>>> = ({
    signal,
  }) => listMyAddressesApiV1AddressesMeGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listMyAddressesApiV1AddressesMeGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListMyAddressesApiV1AddressesMeGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listMyAddressesApiV1AddressesMeGet>>
>;
export type ListMyAddressesApiV1AddressesMeGetQueryError = ErrorType<unknown>;

export function useListMyAddressesApiV1AddressesMeGet<
  TData = Awaited<ReturnType<typeof listMyAddressesApiV1AddressesMeGet>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listMyAddressesApiV1AddressesMeGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listMyAddressesApiV1AddressesMeGet>>,
          TError,
          Awaited<ReturnType<typeof listMyAddressesApiV1AddressesMeGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListMyAddressesApiV1AddressesMeGet<
  TData = Awaited<ReturnType<typeof listMyAddressesApiV1AddressesMeGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listMyAddressesApiV1AddressesMeGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listMyAddressesApiV1AddressesMeGet>>,
          TError,
          Awaited<ReturnType<typeof listMyAddressesApiV1AddressesMeGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListMyAddressesApiV1AddressesMeGet<
  TData = Awaited<ReturnType<typeof listMyAddressesApiV1AddressesMeGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listMyAddressesApiV1AddressesMeGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List My Addresses
 */

export function useListMyAddressesApiV1AddressesMeGet<
  TData = Awaited<ReturnType<typeof listMyAddressesApiV1AddressesMeGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listMyAddressesApiV1AddressesMeGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListMyAddressesApiV1AddressesMeGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Create a new address for the current user.
 * @summary Create My Address
 */
export const getCreateMyAddressApiV1AddressesMePostUrl = () => {
  return `/api/v1/addresses/me`;
};

export const createMyAddressApiV1AddressesMePost = async (
  addressCreate: AddressCreate,
  options?: RequestInit
): Promise<AddressResponse> => {
  return customFetch<AddressResponse>(getCreateMyAddressApiV1AddressesMePostUrl(), {
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(addressCreate),
  });
};

export const getCreateMyAddressApiV1AddressesMePostMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createMyAddressApiV1AddressesMePost>>,
    TError,
    { data: AddressCreate },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createMyAddressApiV1AddressesMePost>>,
  TError,
  { data: AddressCreate },
  TContext
> => {
  const mutationKey = ['createMyAddressApiV1AddressesMePost'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createMyAddressApiV1AddressesMePost>>,
    { data: AddressCreate }
  > = (props) => {
    const { data } = props ?? {};

    return createMyAddressApiV1AddressesMePost(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateMyAddressApiV1AddressesMePostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createMyAddressApiV1AddressesMePost>>
>;
export type CreateMyAddressApiV1AddressesMePostMutationBody = AddressCreate;
export type CreateMyAddressApiV1AddressesMePostMutationError = ErrorType<HTTPValidationError>;

/**
 * @summary Create My Address
 */
export const useCreateMyAddressApiV1AddressesMePost = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createMyAddressApiV1AddressesMePost>>,
      TError,
      { data: AddressCreate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof createMyAddressApiV1AddressesMePost>>,
  TError,
  { data: AddressCreate },
  TContext
> => {
  return useMutation(getCreateMyAddressApiV1AddressesMePostMutationOptions(options), queryClient);
};
/**
 * Delete an address for the current user.
 * @summary Delete My Address
 */
export const getDeleteMyAddressApiV1AddressesMeAddressIdDeleteUrl = (addressId: string) => {
  return `/api/v1/addresses/me/${addressId}`;
};

export const deleteMyAddressApiV1AddressesMeAddressIdDelete = async (
  addressId: string,
  options?: RequestInit
): Promise<AddressDeleteResponse> => {
  return customFetch<AddressDeleteResponse>(
    getDeleteMyAddressApiV1AddressesMeAddressIdDeleteUrl(addressId),
    {
      ...options,
      method: 'DELETE',
    }
  );
};

export const getDeleteMyAddressApiV1AddressesMeAddressIdDeleteMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteMyAddressApiV1AddressesMeAddressIdDelete>>,
    TError,
    { addressId: string },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteMyAddressApiV1AddressesMeAddressIdDelete>>,
  TError,
  { addressId: string },
  TContext
> => {
  const mutationKey = ['deleteMyAddressApiV1AddressesMeAddressIdDelete'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteMyAddressApiV1AddressesMeAddressIdDelete>>,
    { addressId: string }
  > = (props) => {
    const { addressId } = props ?? {};

    return deleteMyAddressApiV1AddressesMeAddressIdDelete(addressId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteMyAddressApiV1AddressesMeAddressIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteMyAddressApiV1AddressesMeAddressIdDelete>>
>;

export type DeleteMyAddressApiV1AddressesMeAddressIdDeleteMutationError =
  ErrorType<HTTPValidationError>;

/**
 * @summary Delete My Address
 */
export const useDeleteMyAddressApiV1AddressesMeAddressIdDelete = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteMyAddressApiV1AddressesMeAddressIdDelete>>,
      TError,
      { addressId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof deleteMyAddressApiV1AddressesMeAddressIdDelete>>,
  TError,
  { addressId: string },
  TContext
> => {
  return useMutation(
    getDeleteMyAddressApiV1AddressesMeAddressIdDeleteMutationOptions(options),
    queryClient
  );
};
/**
 * Update an existing address for the current user.
 * @summary Update My Address
 */
export const getUpdateMyAddressApiV1AddressesMeAddressIdPatchUrl = (addressId: string) => {
  return `/api/v1/addresses/me/${addressId}`;
};

export const updateMyAddressApiV1AddressesMeAddressIdPatch = async (
  addressId: string,
  addressUpdate: AddressUpdate,
  options?: RequestInit
): Promise<AddressResponse> => {
  return customFetch<AddressResponse>(
    getUpdateMyAddressApiV1AddressesMeAddressIdPatchUrl(addressId),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(addressUpdate),
    }
  );
};

export const getUpdateMyAddressApiV1AddressesMeAddressIdPatchMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMyAddressApiV1AddressesMeAddressIdPatch>>,
    TError,
    { addressId: string; data: AddressUpdate },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateMyAddressApiV1AddressesMeAddressIdPatch>>,
  TError,
  { addressId: string; data: AddressUpdate },
  TContext
> => {
  const mutationKey = ['updateMyAddressApiV1AddressesMeAddressIdPatch'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMyAddressApiV1AddressesMeAddressIdPatch>>,
    { addressId: string; data: AddressUpdate }
  > = (props) => {
    const { addressId, data } = props ?? {};

    return updateMyAddressApiV1AddressesMeAddressIdPatch(addressId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateMyAddressApiV1AddressesMeAddressIdPatchMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateMyAddressApiV1AddressesMeAddressIdPatch>>
>;
export type UpdateMyAddressApiV1AddressesMeAddressIdPatchMutationBody = AddressUpdate;
export type UpdateMyAddressApiV1AddressesMeAddressIdPatchMutationError =
  ErrorType<HTTPValidationError>;

/**
 * @summary Update My Address
 */
export const useUpdateMyAddressApiV1AddressesMeAddressIdPatch = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateMyAddressApiV1AddressesMeAddressIdPatch>>,
      TError,
      { addressId: string; data: AddressUpdate },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof updateMyAddressApiV1AddressesMeAddressIdPatch>>,
  TError,
  { addressId: string; data: AddressUpdate },
  TContext
> => {
  return useMutation(
    getUpdateMyAddressApiV1AddressesMeAddressIdPatchMutationOptions(options),
    queryClient
  );
};
/**
 * Provider-agnostic autocomplete passthrough.

Uses the configured provider to retrieve suggestions.
 * @summary Places Autocomplete
 */
export const getPlacesAutocompleteApiV1AddressesPlacesAutocompleteGetUrl = (
  params: PlacesAutocompleteApiV1AddressesPlacesAutocompleteGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/addresses/places/autocomplete?${stringifiedParams}`
    : `/api/v1/addresses/places/autocomplete`;
};

export const placesAutocompleteApiV1AddressesPlacesAutocompleteGet = async (
  params: PlacesAutocompleteApiV1AddressesPlacesAutocompleteGetParams,
  options?: RequestInit
): Promise<AutocompleteResponse> => {
  return customFetch<AutocompleteResponse>(
    getPlacesAutocompleteApiV1AddressesPlacesAutocompleteGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getPlacesAutocompleteApiV1AddressesPlacesAutocompleteGetQueryKey = (
  params?: PlacesAutocompleteApiV1AddressesPlacesAutocompleteGetParams
) => {
  return [`/api/v1/addresses/places/autocomplete`, ...(params ? [params] : [])] as const;
};

export const getPlacesAutocompleteApiV1AddressesPlacesAutocompleteGetQueryOptions = <
  TData = Awaited<ReturnType<typeof placesAutocompleteApiV1AddressesPlacesAutocompleteGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: PlacesAutocompleteApiV1AddressesPlacesAutocompleteGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof placesAutocompleteApiV1AddressesPlacesAutocompleteGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getPlacesAutocompleteApiV1AddressesPlacesAutocompleteGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof placesAutocompleteApiV1AddressesPlacesAutocompleteGet>>
  > = ({ signal }) =>
    placesAutocompleteApiV1AddressesPlacesAutocompleteGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof placesAutocompleteApiV1AddressesPlacesAutocompleteGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlacesAutocompleteApiV1AddressesPlacesAutocompleteGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof placesAutocompleteApiV1AddressesPlacesAutocompleteGet>>
>;
export type PlacesAutocompleteApiV1AddressesPlacesAutocompleteGetQueryError =
  ErrorType<HTTPValidationError>;

export function usePlacesAutocompleteApiV1AddressesPlacesAutocompleteGet<
  TData = Awaited<ReturnType<typeof placesAutocompleteApiV1AddressesPlacesAutocompleteGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: PlacesAutocompleteApiV1AddressesPlacesAutocompleteGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof placesAutocompleteApiV1AddressesPlacesAutocompleteGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof placesAutocompleteApiV1AddressesPlacesAutocompleteGet>>,
          TError,
          Awaited<ReturnType<typeof placesAutocompleteApiV1AddressesPlacesAutocompleteGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function usePlacesAutocompleteApiV1AddressesPlacesAutocompleteGet<
  TData = Awaited<ReturnType<typeof placesAutocompleteApiV1AddressesPlacesAutocompleteGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: PlacesAutocompleteApiV1AddressesPlacesAutocompleteGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof placesAutocompleteApiV1AddressesPlacesAutocompleteGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof placesAutocompleteApiV1AddressesPlacesAutocompleteGet>>,
          TError,
          Awaited<ReturnType<typeof placesAutocompleteApiV1AddressesPlacesAutocompleteGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function usePlacesAutocompleteApiV1AddressesPlacesAutocompleteGet<
  TData = Awaited<ReturnType<typeof placesAutocompleteApiV1AddressesPlacesAutocompleteGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: PlacesAutocompleteApiV1AddressesPlacesAutocompleteGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof placesAutocompleteApiV1AddressesPlacesAutocompleteGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Places Autocomplete
 */

export function usePlacesAutocompleteApiV1AddressesPlacesAutocompleteGet<
  TData = Awaited<ReturnType<typeof placesAutocompleteApiV1AddressesPlacesAutocompleteGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: PlacesAutocompleteApiV1AddressesPlacesAutocompleteGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof placesAutocompleteApiV1AddressesPlacesAutocompleteGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getPlacesAutocompleteApiV1AddressesPlacesAutocompleteGetQueryOptions(
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Return normalized place details for a selected suggestion.

Frontend uses this to auto-fill form fields without exposing provider payloads.
 * @summary Place Details
 */
export const getPlaceDetailsApiV1AddressesPlacesDetailsGetUrl = (
  params: PlaceDetailsApiV1AddressesPlacesDetailsGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/addresses/places/details?${stringifiedParams}`
    : `/api/v1/addresses/places/details`;
};

export const placeDetailsApiV1AddressesPlacesDetailsGet = async (
  params: PlaceDetailsApiV1AddressesPlacesDetailsGetParams,
  options?: RequestInit
): Promise<PlaceDetails> => {
  return customFetch<PlaceDetails>(getPlaceDetailsApiV1AddressesPlacesDetailsGetUrl(params), {
    ...options,
    method: 'GET',
  });
};

export const getPlaceDetailsApiV1AddressesPlacesDetailsGetQueryKey = (
  params?: PlaceDetailsApiV1AddressesPlacesDetailsGetParams
) => {
  return [`/api/v1/addresses/places/details`, ...(params ? [params] : [])] as const;
};

export const getPlaceDetailsApiV1AddressesPlacesDetailsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof placeDetailsApiV1AddressesPlacesDetailsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: PlaceDetailsApiV1AddressesPlacesDetailsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof placeDetailsApiV1AddressesPlacesDetailsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getPlaceDetailsApiV1AddressesPlacesDetailsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof placeDetailsApiV1AddressesPlacesDetailsGet>>
  > = ({ signal }) =>
    placeDetailsApiV1AddressesPlacesDetailsGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof placeDetailsApiV1AddressesPlacesDetailsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PlaceDetailsApiV1AddressesPlacesDetailsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof placeDetailsApiV1AddressesPlacesDetailsGet>>
>;
export type PlaceDetailsApiV1AddressesPlacesDetailsGetQueryError = ErrorType<HTTPValidationError>;

export function usePlaceDetailsApiV1AddressesPlacesDetailsGet<
  TData = Awaited<ReturnType<typeof placeDetailsApiV1AddressesPlacesDetailsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: PlaceDetailsApiV1AddressesPlacesDetailsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof placeDetailsApiV1AddressesPlacesDetailsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof placeDetailsApiV1AddressesPlacesDetailsGet>>,
          TError,
          Awaited<ReturnType<typeof placeDetailsApiV1AddressesPlacesDetailsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function usePlaceDetailsApiV1AddressesPlacesDetailsGet<
  TData = Awaited<ReturnType<typeof placeDetailsApiV1AddressesPlacesDetailsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: PlaceDetailsApiV1AddressesPlacesDetailsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof placeDetailsApiV1AddressesPlacesDetailsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof placeDetailsApiV1AddressesPlacesDetailsGet>>,
          TError,
          Awaited<ReturnType<typeof placeDetailsApiV1AddressesPlacesDetailsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function usePlaceDetailsApiV1AddressesPlacesDetailsGet<
  TData = Awaited<ReturnType<typeof placeDetailsApiV1AddressesPlacesDetailsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: PlaceDetailsApiV1AddressesPlacesDetailsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof placeDetailsApiV1AddressesPlacesDetailsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Place Details
 */

export function usePlaceDetailsApiV1AddressesPlacesDetailsGet<
  TData = Awaited<ReturnType<typeof placeDetailsApiV1AddressesPlacesDetailsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: PlaceDetailsApiV1AddressesPlacesDetailsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof placeDetailsApiV1AddressesPlacesDetailsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getPlaceDetailsApiV1AddressesPlacesDetailsGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * List neighborhoods for a region type.
 * @summary List Neighborhoods
 */
export const getListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGetUrl = (
  params?: ListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/addresses/regions/neighborhoods?${stringifiedParams}`
    : `/api/v1/addresses/regions/neighborhoods`;
};

export const listNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet = async (
  params?: ListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGetParams,
  options?: RequestInit
): Promise<NeighborhoodsListResponse> => {
  return customFetch<NeighborhoodsListResponse>(
    getListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGetUrl(params),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGetQueryKey = (
  params?: ListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGetParams
) => {
  return [`/api/v1/addresses/regions/neighborhoods`, ...(params ? [params] : [])] as const;
};

export const getListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: ListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGetQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet>>
  > = ({ signal }) =>
    listNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet>>
>;
export type ListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGetQueryError =
  ErrorType<HTTPValidationError>;

export function useListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet<
  TData = Awaited<ReturnType<typeof listNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: undefined | ListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGetParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet>>,
          TError,
          Awaited<ReturnType<typeof listNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet<
  TData = Awaited<ReturnType<typeof listNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: ListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet>>,
          TError,
          Awaited<ReturnType<typeof listNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet<
  TData = Awaited<ReturnType<typeof listNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: ListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List Neighborhoods
 */

export function useListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet<
  TData = Awaited<ReturnType<typeof listNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params?: ListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listNeighborhoodsApiV1AddressesRegionsNeighborhoodsGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListNeighborhoodsApiV1AddressesRegionsNeighborhoodsGetQueryOptions(
    params,
    options
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * List service areas for the current instructor.
 * @summary List My Service Areas
 */
export const getListMyServiceAreasApiV1AddressesServiceAreasMeGetUrl = () => {
  return `/api/v1/addresses/service-areas/me`;
};

export const listMyServiceAreasApiV1AddressesServiceAreasMeGet = async (
  options?: RequestInit
): Promise<ServiceAreasResponse> => {
  return customFetch<ServiceAreasResponse>(
    getListMyServiceAreasApiV1AddressesServiceAreasMeGetUrl(),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getListMyServiceAreasApiV1AddressesServiceAreasMeGetQueryKey = () => {
  return [`/api/v1/addresses/service-areas/me`] as const;
};

export const getListMyServiceAreasApiV1AddressesServiceAreasMeGetQueryOptions = <
  TData = Awaited<ReturnType<typeof listMyServiceAreasApiV1AddressesServiceAreasMeGet>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof listMyServiceAreasApiV1AddressesServiceAreasMeGet>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof customFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getListMyServiceAreasApiV1AddressesServiceAreasMeGetQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listMyServiceAreasApiV1AddressesServiceAreasMeGet>>
  > = ({ signal }) =>
    listMyServiceAreasApiV1AddressesServiceAreasMeGet({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listMyServiceAreasApiV1AddressesServiceAreasMeGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListMyServiceAreasApiV1AddressesServiceAreasMeGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof listMyServiceAreasApiV1AddressesServiceAreasMeGet>>
>;
export type ListMyServiceAreasApiV1AddressesServiceAreasMeGetQueryError = ErrorType<unknown>;

export function useListMyServiceAreasApiV1AddressesServiceAreasMeGet<
  TData = Awaited<ReturnType<typeof listMyServiceAreasApiV1AddressesServiceAreasMeGet>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listMyServiceAreasApiV1AddressesServiceAreasMeGet>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listMyServiceAreasApiV1AddressesServiceAreasMeGet>>,
          TError,
          Awaited<ReturnType<typeof listMyServiceAreasApiV1AddressesServiceAreasMeGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListMyServiceAreasApiV1AddressesServiceAreasMeGet<
  TData = Awaited<ReturnType<typeof listMyServiceAreasApiV1AddressesServiceAreasMeGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listMyServiceAreasApiV1AddressesServiceAreasMeGet>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listMyServiceAreasApiV1AddressesServiceAreasMeGet>>,
          TError,
          Awaited<ReturnType<typeof listMyServiceAreasApiV1AddressesServiceAreasMeGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListMyServiceAreasApiV1AddressesServiceAreasMeGet<
  TData = Awaited<ReturnType<typeof listMyServiceAreasApiV1AddressesServiceAreasMeGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listMyServiceAreasApiV1AddressesServiceAreasMeGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List My Service Areas
 */

export function useListMyServiceAreasApiV1AddressesServiceAreasMeGet<
  TData = Awaited<ReturnType<typeof listMyServiceAreasApiV1AddressesServiceAreasMeGet>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof listMyServiceAreasApiV1AddressesServiceAreasMeGet>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListMyServiceAreasApiV1AddressesServiceAreasMeGetQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Replace all service areas for the current instructor.
 * @summary Replace My Service Areas
 */
export const getReplaceMyServiceAreasApiV1AddressesServiceAreasMePutUrl = () => {
  return `/api/v1/addresses/service-areas/me`;
};

export const replaceMyServiceAreasApiV1AddressesServiceAreasMePut = async (
  serviceAreasUpdateRequest: ServiceAreasUpdateRequest,
  options?: RequestInit
): Promise<ServiceAreasResponse> => {
  return customFetch<ServiceAreasResponse>(
    getReplaceMyServiceAreasApiV1AddressesServiceAreasMePutUrl(),
    {
      ...options,
      method: 'PUT',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(serviceAreasUpdateRequest),
    }
  );
};

export const getReplaceMyServiceAreasApiV1AddressesServiceAreasMePutMutationOptions = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof replaceMyServiceAreasApiV1AddressesServiceAreasMePut>>,
    TError,
    { data: ServiceAreasUpdateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof replaceMyServiceAreasApiV1AddressesServiceAreasMePut>>,
  TError,
  { data: ServiceAreasUpdateRequest },
  TContext
> => {
  const mutationKey = ['replaceMyServiceAreasApiV1AddressesServiceAreasMePut'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof replaceMyServiceAreasApiV1AddressesServiceAreasMePut>>,
    { data: ServiceAreasUpdateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return replaceMyServiceAreasApiV1AddressesServiceAreasMePut(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type ReplaceMyServiceAreasApiV1AddressesServiceAreasMePutMutationResult = NonNullable<
  Awaited<ReturnType<typeof replaceMyServiceAreasApiV1AddressesServiceAreasMePut>>
>;
export type ReplaceMyServiceAreasApiV1AddressesServiceAreasMePutMutationBody =
  ServiceAreasUpdateRequest;
export type ReplaceMyServiceAreasApiV1AddressesServiceAreasMePutMutationError =
  ErrorType<HTTPValidationError>;

/**
 * @summary Replace My Service Areas
 */
export const useReplaceMyServiceAreasApiV1AddressesServiceAreasMePut = <
  TError = ErrorType<HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof replaceMyServiceAreasApiV1AddressesServiceAreasMePut>>,
      TError,
      { data: ServiceAreasUpdateRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof replaceMyServiceAreasApiV1AddressesServiceAreasMePut>>,
  TError,
  { data: ServiceAreasUpdateRequest },
  TContext
> => {
  return useMutation(
    getReplaceMyServiceAreasApiV1AddressesServiceAreasMePutMutationOptions(options),
    queryClient
  );
};
/**
 * Lightweight NYC ZIP check.

Args:
    zip: Five-digit ZIP code.

Returns:
    { "is_nyc": bool, "borough": Optional[str] }

Notes:
    - This endpoint is deterministic and does not require geocoding APIs.
    - It is sufficient for onboarding gating; deeper enrichment occurs when
      we create an address with lat/lng.
 * @summary Is Nyc Zip
 */
export const getIsNycZipApiV1AddressesZipIsNycGetUrl = (
  params: IsNycZipApiV1AddressesZipIsNycGetParams
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/api/v1/addresses/zip/is-nyc?${stringifiedParams}`
    : `/api/v1/addresses/zip/is-nyc`;
};

export const isNycZipApiV1AddressesZipIsNycGet = async (
  params: IsNycZipApiV1AddressesZipIsNycGetParams,
  options?: RequestInit
): Promise<NYCZipCheckResponse> => {
  return customFetch<NYCZipCheckResponse>(getIsNycZipApiV1AddressesZipIsNycGetUrl(params), {
    ...options,
    method: 'GET',
  });
};

export const getIsNycZipApiV1AddressesZipIsNycGetQueryKey = (
  params?: IsNycZipApiV1AddressesZipIsNycGetParams
) => {
  return [`/api/v1/addresses/zip/is-nyc`, ...(params ? [params] : [])] as const;
};

export const getIsNycZipApiV1AddressesZipIsNycGetQueryOptions = <
  TData = Awaited<ReturnType<typeof isNycZipApiV1AddressesZipIsNycGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: IsNycZipApiV1AddressesZipIsNycGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof isNycZipApiV1AddressesZipIsNycGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getIsNycZipApiV1AddressesZipIsNycGetQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof isNycZipApiV1AddressesZipIsNycGet>>> = ({
    signal,
  }) => isNycZipApiV1AddressesZipIsNycGet(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof isNycZipApiV1AddressesZipIsNycGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type IsNycZipApiV1AddressesZipIsNycGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof isNycZipApiV1AddressesZipIsNycGet>>
>;
export type IsNycZipApiV1AddressesZipIsNycGetQueryError = ErrorType<HTTPValidationError>;

export function useIsNycZipApiV1AddressesZipIsNycGet<
  TData = Awaited<ReturnType<typeof isNycZipApiV1AddressesZipIsNycGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: IsNycZipApiV1AddressesZipIsNycGetParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof isNycZipApiV1AddressesZipIsNycGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof isNycZipApiV1AddressesZipIsNycGet>>,
          TError,
          Awaited<ReturnType<typeof isNycZipApiV1AddressesZipIsNycGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useIsNycZipApiV1AddressesZipIsNycGet<
  TData = Awaited<ReturnType<typeof isNycZipApiV1AddressesZipIsNycGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: IsNycZipApiV1AddressesZipIsNycGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof isNycZipApiV1AddressesZipIsNycGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof isNycZipApiV1AddressesZipIsNycGet>>,
          TError,
          Awaited<ReturnType<typeof isNycZipApiV1AddressesZipIsNycGet>>
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useIsNycZipApiV1AddressesZipIsNycGet<
  TData = Awaited<ReturnType<typeof isNycZipApiV1AddressesZipIsNycGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: IsNycZipApiV1AddressesZipIsNycGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof isNycZipApiV1AddressesZipIsNycGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Is Nyc Zip
 */

export function useIsNycZipApiV1AddressesZipIsNycGet<
  TData = Awaited<ReturnType<typeof isNycZipApiV1AddressesZipIsNycGet>>,
  TError = ErrorType<HTTPValidationError>,
>(
  params: IsNycZipApiV1AddressesZipIsNycGetParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof isNycZipApiV1AddressesZipIsNycGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getIsNycZipApiV1AddressesZipIsNycGetQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}
