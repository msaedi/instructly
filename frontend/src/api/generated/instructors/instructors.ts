/**
 * Generated by orval v8.4.1 üç∫
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  BackgroundCheckInviteRequest,
  BackgroundCheckInviteResponse,
  BackgroundCheckStatusResponse,
  ConsentPayload,
  ConsentResponse,
  HTTPValidationError,
  MockStatusResponse,
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Persist the instructor's consent acknowledgement for FCRA compliance.
 * @summary Record Background Check Consent
 */
export const getRecordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPostUrl = (
  instructorId: string
) => {
  return `/api/v1/instructors/${instructorId}/bgc/consent`;
};

export const recordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPost = async (
  instructorId: string,
  consentPayload: ConsentPayload,
  options?: RequestInit
): Promise<ConsentResponse> => {
  return customFetch<ConsentResponse>(
    getRecordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPostUrl(instructorId),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(consentPayload),
    }
  );
};

export const getRecordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPostMutationOptions =
  <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof recordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPost>
      >,
      TError,
      { instructorId: string; data: ConsentPayload },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof recordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPost>
    >,
    TError,
    { instructorId: string; data: ConsentPayload },
    TContext
  > => {
    const mutationKey = ['recordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPost'];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof recordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPost>
      >,
      { instructorId: string; data: ConsentPayload }
    > = (props) => {
      const { instructorId, data } = props ?? {};

      return recordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPost(
        instructorId,
        data,
        requestOptions
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type RecordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof recordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPost>
    >
  >;
export type RecordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPostMutationBody =
  ConsentPayload;
export type RecordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Record Background Check Consent
 */
export const useRecordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof recordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPost>
      >,
      TError,
      { instructorId: string; data: ConsentPayload },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<
    ReturnType<typeof recordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPost>
  >,
  TError,
  { instructorId: string; data: ConsentPayload },
  TContext
> => {
  return useMutation(
    getRecordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPostMutationOptions(
      options
    ),
    queryClient
  );
};
/**
 * @summary Trigger Background Check Invite
 */
export const getTriggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePostUrl = (
  instructorId: string
) => {
  return `/api/v1/instructors/${instructorId}/bgc/invite`;
};

export const triggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePost = async (
  instructorId: string,
  backgroundCheckInviteRequest: BackgroundCheckInviteRequest,
  options?: RequestInit
): Promise<BackgroundCheckInviteResponse> => {
  return customFetch<BackgroundCheckInviteResponse>(
    getTriggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePostUrl(instructorId),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(backgroundCheckInviteRequest),
    }
  );
};

export const getTriggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePostMutationOptions =
  <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof triggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePost>
      >,
      TError,
      { instructorId: string; data: BackgroundCheckInviteRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof triggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePost>
    >,
    TError,
    { instructorId: string; data: BackgroundCheckInviteRequest },
    TContext
  > => {
    const mutationKey = ['triggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePost'];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof triggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePost>
      >,
      { instructorId: string; data: BackgroundCheckInviteRequest }
    > = (props) => {
      const { instructorId, data } = props ?? {};

      return triggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePost(
        instructorId,
        data,
        requestOptions
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type TriggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof triggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePost>
    >
  >;
export type TriggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePostMutationBody =
  BackgroundCheckInviteRequest;
export type TriggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Trigger Background Check Invite
 */
export const useTriggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof triggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePost>
      >,
      TError,
      { instructorId: string; data: BackgroundCheckInviteRequest },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof triggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePost>>,
  TError,
  { instructorId: string; data: BackgroundCheckInviteRequest },
  TContext
> => {
  return useMutation(
    getTriggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePostMutationOptions(
      options
    ),
    queryClient
  );
};
/**
 * Non-production helper to mark background check as passed.
 * @summary Mock Background Check Pass
 */
export const getMockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPostUrl = (
  instructorId: string
) => {
  return `/api/v1/instructors/${instructorId}/bgc/mock/pass`;
};

export const mockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPost = async (
  instructorId: string,
  options?: RequestInit
): Promise<MockStatusResponse> => {
  return customFetch<MockStatusResponse>(
    getMockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPostUrl(instructorId),
    {
      ...options,
      method: 'POST',
    }
  );
};

export const getMockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPostMutationOptions =
  <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof mockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPost>
      >,
      TError,
      { instructorId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<ReturnType<typeof mockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPost>>,
    TError,
    { instructorId: string },
    TContext
  > => {
    const mutationKey = ['mockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPost'];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof mockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPost>
      >,
      { instructorId: string }
    > = (props) => {
      const { instructorId } = props ?? {};

      return mockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPost(
        instructorId,
        requestOptions
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type MockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof mockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPost>>
  >;

export type MockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Mock Background Check Pass
 */
export const useMockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof mockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPost>
      >,
      TError,
      { instructorId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof mockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPost>>,
  TError,
  { instructorId: string },
  TContext
> => {
  return useMutation(
    getMockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPostMutationOptions(options),
    queryClient
  );
};
/**
 * Non-production helper to reset background check metadata.
 * @summary Mock Background Check Reset
 */
export const getMockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPostUrl = (
  instructorId: string
) => {
  return `/api/v1/instructors/${instructorId}/bgc/mock/reset`;
};

export const mockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPost = async (
  instructorId: string,
  options?: RequestInit
): Promise<MockStatusResponse> => {
  return customFetch<MockStatusResponse>(
    getMockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPostUrl(instructorId),
    {
      ...options,
      method: 'POST',
    }
  );
};

export const getMockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPostMutationOptions =
  <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof mockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPost>
      >,
      TError,
      { instructorId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof mockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPost>
    >,
    TError,
    { instructorId: string },
    TContext
  > => {
    const mutationKey = ['mockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPost'];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof mockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPost>
      >,
      { instructorId: string }
    > = (props) => {
      const { instructorId } = props ?? {};

      return mockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPost(
        instructorId,
        requestOptions
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type MockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof mockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPost>>
  >;

export type MockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Mock Background Check Reset
 */
export const useMockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof mockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPost>
      >,
      TError,
      { instructorId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof mockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPost>>,
  TError,
  { instructorId: string },
  TContext
> => {
  return useMutation(
    getMockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPostMutationOptions(options),
    queryClient
  );
};
/**
 * Non-production helper to mark background check as under review.
 * @summary Mock Background Check Review
 */
export const getMockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPostUrl = (
  instructorId: string
) => {
  return `/api/v1/instructors/${instructorId}/bgc/mock/review`;
};

export const mockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPost = async (
  instructorId: string,
  options?: RequestInit
): Promise<MockStatusResponse> => {
  return customFetch<MockStatusResponse>(
    getMockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPostUrl(instructorId),
    {
      ...options,
      method: 'POST',
    }
  );
};

export const getMockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPostMutationOptions =
  <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof mockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPost>
      >,
      TError,
      { instructorId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof mockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPost>
    >,
    TError,
    { instructorId: string },
    TContext
  > => {
    const mutationKey = ['mockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPost'];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof mockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPost>
      >,
      { instructorId: string }
    > = (props) => {
      const { instructorId } = props ?? {};

      return mockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPost(
        instructorId,
        requestOptions
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type MockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof mockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPost>
    >
  >;

export type MockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Mock Background Check Review
 */
export const useMockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof mockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPost>
      >,
      TError,
      { instructorId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<
    ReturnType<typeof mockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPost>
  >,
  TError,
  { instructorId: string },
  TContext
> => {
  return useMutation(
    getMockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPostMutationOptions(
      options
    ),
    queryClient
  );
};
/**
 * @summary Trigger Background Check Recheck
 */
export const getTriggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPostUrl = (
  instructorId: string
) => {
  return `/api/v1/instructors/${instructorId}/bgc/recheck`;
};

export const triggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPost = async (
  instructorId: string,
  options?: RequestInit
): Promise<BackgroundCheckInviteResponse> => {
  return customFetch<BackgroundCheckInviteResponse>(
    getTriggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPostUrl(instructorId),
    {
      ...options,
      method: 'POST',
    }
  );
};

export const getTriggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPostMutationOptions =
  <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof triggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPost>
      >,
      TError,
      { instructorId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof triggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPost>
    >,
    TError,
    { instructorId: string },
    TContext
  > => {
    const mutationKey = ['triggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPost'];
    const { mutation: mutationOptions, request: requestOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey }, request: undefined };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof triggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPost>
      >,
      { instructorId: string }
    > = (props) => {
      const { instructorId } = props ?? {};

      return triggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPost(
        instructorId,
        requestOptions
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type TriggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof triggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPost>
    >
  >;

export type TriggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Trigger Background Check Recheck
 */
export const useTriggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof triggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPost>
      >,
      TError,
      { instructorId: string },
      TContext
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<
    ReturnType<typeof triggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPost>
  >,
  TError,
  { instructorId: string },
  TContext
> => {
  return useMutation(
    getTriggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPostMutationOptions(
      options
    ),
    queryClient
  );
};
/**
 * @summary Get Background Check Status
 */
export const getGetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGetUrl = (
  instructorId: string
) => {
  return `/api/v1/instructors/${instructorId}/bgc/status`;
};

export const getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet = async (
  instructorId: string,
  options?: RequestInit
): Promise<BackgroundCheckStatusResponse> => {
  return customFetch<BackgroundCheckStatusResponse>(
    getGetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGetUrl(instructorId),
    {
      ...options,
      method: 'GET',
    }
  );
};

export const getGetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGetQueryKey = (
  instructorId: string
) => {
  return [`/api/v1/instructors/${instructorId}/bgc/status`] as const;
};

export const getGetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
  >,
  TError = ErrorType<void | HTTPValidationError>,
>(
  instructorId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGetQueryKey(instructorId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>>
  > = ({ signal }) =>
    getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet(instructorId, {
      signal,
      ...requestOptions,
    });

  return { queryKey, queryFn, enabled: !!instructorId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>>
  >;
export type GetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGetQueryError =
  ErrorType<void | HTTPValidationError>;

export function useGetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet<
  TData = Awaited<
    ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
  >,
  TError = ErrorType<void | HTTPValidationError>,
>(
  instructorId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet<
  TData = Awaited<
    ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
  >,
  TError = ErrorType<void | HTTPValidationError>,
>(
  instructorId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
          >
        >,
        'initialData'
      >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet<
  TData = Awaited<
    ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
  >,
  TError = ErrorType<void | HTTPValidationError>,
>(
  instructorId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Background Check Status
 */

export function useGetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet<
  TData = Awaited<
    ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
  >,
  TError = ErrorType<void | HTTPValidationError>,
>(
  instructorId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
        >,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customFetch>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions =
    getGetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGetQueryOptions(
      instructorId,
      options
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  return { ...query, queryKey: queryOptions.queryKey };
}
