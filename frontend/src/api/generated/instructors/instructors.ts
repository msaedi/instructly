/**
 * Generated by orval v7.16.1 ðŸº
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  BackgroundCheckInviteRequest,
  BackgroundCheckInviteResponse,
  BackgroundCheckStatusResponse,
  ConsentPayload,
  ConsentResponse,
  HTTPValidationError,
  MockStatusResponse,
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';

/**
 * Persist the instructor's consent acknowledgement for FCRA compliance.
 * @summary Record Background Check Consent
 */
export const recordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPost = (
  instructorId: string,
  consentPayload: ConsentPayload,
  signal?: AbortSignal
) => {
  return customFetch<ConsentResponse>({
    url: `/api/v1/instructors/${instructorId}/bgc/consent`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: consentPayload,
    signal,
  });
};

export const getRecordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPostMutationOptions =
  <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof recordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPost>
      >,
      TError,
      { instructorId: string; data: ConsentPayload },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof recordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPost>
    >,
    TError,
    { instructorId: string; data: ConsentPayload },
    TContext
  > => {
    const mutationKey = ['recordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPost'];
    const { mutation: mutationOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof recordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPost>
      >,
      { instructorId: string; data: ConsentPayload }
    > = (props) => {
      const { instructorId, data } = props ?? {};

      return recordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPost(
        instructorId,
        data
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type RecordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof recordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPost>
    >
  >;
export type RecordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPostMutationBody =
  ConsentPayload;
export type RecordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Record Background Check Consent
 */
export const useRecordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof recordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPost>
      >,
      TError,
      { instructorId: string; data: ConsentPayload },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<
    ReturnType<typeof recordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPost>
  >,
  TError,
  { instructorId: string; data: ConsentPayload },
  TContext
> => {
  const mutationOptions =
    getRecordBackgroundCheckConsentApiV1InstructorsInstructorIdBgcConsentPostMutationOptions(
      options
    );

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Trigger Background Check Invite
 */
export const triggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePost = (
  instructorId: string,
  backgroundCheckInviteRequest: BackgroundCheckInviteRequest,
  signal?: AbortSignal
) => {
  return customFetch<BackgroundCheckInviteResponse>({
    url: `/api/v1/instructors/${instructorId}/bgc/invite`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: backgroundCheckInviteRequest,
    signal,
  });
};

export const getTriggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePostMutationOptions =
  <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof triggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePost>
      >,
      TError,
      { instructorId: string; data: BackgroundCheckInviteRequest },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof triggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePost>
    >,
    TError,
    { instructorId: string; data: BackgroundCheckInviteRequest },
    TContext
  > => {
    const mutationKey = ['triggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePost'];
    const { mutation: mutationOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof triggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePost>
      >,
      { instructorId: string; data: BackgroundCheckInviteRequest }
    > = (props) => {
      const { instructorId, data } = props ?? {};

      return triggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePost(
        instructorId,
        data
      );
    };

    return { mutationFn, ...mutationOptions };
  };

export type TriggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof triggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePost>
    >
  >;
export type TriggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePostMutationBody =
  BackgroundCheckInviteRequest;
export type TriggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Trigger Background Check Invite
 */
export const useTriggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof triggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePost>
      >,
      TError,
      { instructorId: string; data: BackgroundCheckInviteRequest },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof triggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePost>>,
  TError,
  { instructorId: string; data: BackgroundCheckInviteRequest },
  TContext
> => {
  const mutationOptions =
    getTriggerBackgroundCheckInviteApiV1InstructorsInstructorIdBgcInvitePostMutationOptions(
      options
    );

  return useMutation(mutationOptions, queryClient);
};
/**
 * Non-production helper to mark background check as passed.
 * @summary Mock Background Check Pass
 */
export const mockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPost = (
  instructorId: string,
  signal?: AbortSignal
) => {
  return customFetch<MockStatusResponse>({
    url: `/api/v1/instructors/${instructorId}/bgc/mock/pass`,
    method: 'POST',
    signal,
  });
};

export const getMockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPostMutationOptions =
  <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof mockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPost>
      >,
      TError,
      { instructorId: string },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<ReturnType<typeof mockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPost>>,
    TError,
    { instructorId: string },
    TContext
  > => {
    const mutationKey = ['mockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPost'];
    const { mutation: mutationOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof mockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPost>
      >,
      { instructorId: string }
    > = (props) => {
      const { instructorId } = props ?? {};

      return mockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPost(instructorId);
    };

    return { mutationFn, ...mutationOptions };
  };

export type MockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof mockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPost>>
  >;

export type MockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Mock Background Check Pass
 */
export const useMockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof mockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPost>
      >,
      TError,
      { instructorId: string },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof mockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPost>>,
  TError,
  { instructorId: string },
  TContext
> => {
  const mutationOptions =
    getMockBackgroundCheckPassApiV1InstructorsInstructorIdBgcMockPassPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Non-production helper to reset background check metadata.
 * @summary Mock Background Check Reset
 */
export const mockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPost = (
  instructorId: string,
  signal?: AbortSignal
) => {
  return customFetch<MockStatusResponse>({
    url: `/api/v1/instructors/${instructorId}/bgc/mock/reset`,
    method: 'POST',
    signal,
  });
};

export const getMockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPostMutationOptions =
  <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof mockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPost>
      >,
      TError,
      { instructorId: string },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof mockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPost>
    >,
    TError,
    { instructorId: string },
    TContext
  > => {
    const mutationKey = ['mockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPost'];
    const { mutation: mutationOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof mockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPost>
      >,
      { instructorId: string }
    > = (props) => {
      const { instructorId } = props ?? {};

      return mockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPost(instructorId);
    };

    return { mutationFn, ...mutationOptions };
  };

export type MockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPostMutationResult =
  NonNullable<
    Awaited<ReturnType<typeof mockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPost>>
  >;

export type MockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Mock Background Check Reset
 */
export const useMockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof mockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPost>
      >,
      TError,
      { instructorId: string },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof mockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPost>>,
  TError,
  { instructorId: string },
  TContext
> => {
  const mutationOptions =
    getMockBackgroundCheckResetApiV1InstructorsInstructorIdBgcMockResetPostMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Non-production helper to mark background check as under review.
 * @summary Mock Background Check Review
 */
export const mockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPost = (
  instructorId: string,
  signal?: AbortSignal
) => {
  return customFetch<MockStatusResponse>({
    url: `/api/v1/instructors/${instructorId}/bgc/mock/review`,
    method: 'POST',
    signal,
  });
};

export const getMockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPostMutationOptions =
  <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof mockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPost>
      >,
      TError,
      { instructorId: string },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof mockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPost>
    >,
    TError,
    { instructorId: string },
    TContext
  > => {
    const mutationKey = ['mockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPost'];
    const { mutation: mutationOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof mockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPost>
      >,
      { instructorId: string }
    > = (props) => {
      const { instructorId } = props ?? {};

      return mockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPost(instructorId);
    };

    return { mutationFn, ...mutationOptions };
  };

export type MockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof mockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPost>
    >
  >;

export type MockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Mock Background Check Review
 */
export const useMockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof mockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPost>
      >,
      TError,
      { instructorId: string },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<
    ReturnType<typeof mockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPost>
  >,
  TError,
  { instructorId: string },
  TContext
> => {
  const mutationOptions =
    getMockBackgroundCheckReviewApiV1InstructorsInstructorIdBgcMockReviewPostMutationOptions(
      options
    );

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Trigger Background Check Recheck
 */
export const triggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPost = (
  instructorId: string,
  signal?: AbortSignal
) => {
  return customFetch<BackgroundCheckInviteResponse>({
    url: `/api/v1/instructors/${instructorId}/bgc/recheck`,
    method: 'POST',
    signal,
  });
};

export const getTriggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPostMutationOptions =
  <TError = ErrorType<void | HTTPValidationError>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof triggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPost>
      >,
      TError,
      { instructorId: string },
      TContext
    >;
  }): UseMutationOptions<
    Awaited<
      ReturnType<typeof triggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPost>
    >,
    TError,
    { instructorId: string },
    TContext
  > => {
    const mutationKey = ['triggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPost'];
    const { mutation: mutationOptions } = options
      ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
        ? options
        : { ...options, mutation: { ...options.mutation, mutationKey } }
      : { mutation: { mutationKey } };

    const mutationFn: MutationFunction<
      Awaited<
        ReturnType<typeof triggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPost>
      >,
      { instructorId: string }
    > = (props) => {
      const { instructorId } = props ?? {};

      return triggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPost(instructorId);
    };

    return { mutationFn, ...mutationOptions };
  };

export type TriggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPostMutationResult =
  NonNullable<
    Awaited<
      ReturnType<typeof triggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPost>
    >
  >;

export type TriggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPostMutationError =
  ErrorType<void | HTTPValidationError>;

/**
 * @summary Trigger Background Check Recheck
 */
export const useTriggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPost = <
  TError = ErrorType<void | HTTPValidationError>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<
        ReturnType<typeof triggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPost>
      >,
      TError,
      { instructorId: string },
      TContext
    >;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<
    ReturnType<typeof triggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPost>
  >,
  TError,
  { instructorId: string },
  TContext
> => {
  const mutationOptions =
    getTriggerBackgroundCheckRecheckApiV1InstructorsInstructorIdBgcRecheckPostMutationOptions(
      options
    );

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get Background Check Status
 */
export const getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet = (
  instructorId: string,
  signal?: AbortSignal
) => {
  return customFetch<BackgroundCheckStatusResponse>({
    url: `/api/v1/instructors/${instructorId}/bgc/status`,
    method: 'GET',
    signal,
  });
};

export const getGetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGetQueryKey = (
  instructorId?: string
) => {
  return [`/api/v1/instructors/${instructorId}/bgc/status`] as const;
};

export const getGetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGetQueryOptions = <
  TData = Awaited<
    ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
  >,
  TError = ErrorType<void | HTTPValidationError>,
>(
  instructorId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
        >,
        TError,
        TData
      >
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGetQueryKey(instructorId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>>
  > = ({ signal }) =>
    getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet(instructorId, signal);

  return { queryKey, queryFn, enabled: !!instructorId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGetQueryResult =
  NonNullable<
    Awaited<ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>>
  >;
export type GetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGetQueryError =
  ErrorType<void | HTTPValidationError>;

export function useGetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet<
  TData = Awaited<
    ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
  >,
  TError = ErrorType<void | HTTPValidationError>,
>(
  instructorId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
          >
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet<
  TData = Awaited<
    ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
  >,
  TError = ErrorType<void | HTTPValidationError>,
>(
  instructorId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
        >,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<
            ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
          >,
          TError,
          Awaited<
            ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
          >
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet<
  TData = Awaited<
    ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
  >,
  TError = ErrorType<void | HTTPValidationError>,
>(
  instructorId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get Background Check Status
 */

export function useGetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet<
  TData = Awaited<
    ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
  >,
  TError = ErrorType<void | HTTPValidationError>,
>(
  instructorId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<
          ReturnType<typeof getBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGet>
        >,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions =
    getGetBackgroundCheckStatusApiV1InstructorsInstructorIdBgcStatusGetQueryOptions(
      instructorId,
      options
    );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
