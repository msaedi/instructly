/**
 * Generated by orval v7.16.1 ðŸº
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AppSchemasPaymentSchemasDeleteResponse,
  CheckoutResponse,
  CreateCheckoutRequest,
  CreditBalanceResponse,
  DashboardLinkResponse,
  EarningsResponse,
  GetTransactionHistoryApiPaymentsTransactionsGetParams,
  HTTPValidationError,
  IdentityRefreshResponse,
  IdentitySessionResponse,
  InstantPayoutResponse,
  OnboardingResponse,
  OnboardingStatusResponse,
  PaymentMethodResponse,
  PayoutScheduleResponse,
  SavePaymentMethodRequest,
  SetPayoutScheduleApiPaymentsConnectPayoutSchedulePostParams,
  StartOnboardingApiPaymentsConnectOnboardPostParams,
  TransactionHistoryItem,
  WebhookResponse
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';




/**
 * Create a checkout/payment for a booking.

Args:
    payload: Checkout details including booking and payment method

Returns:
    CheckoutResponse with payment details

Raises:
    HTTPException: If checkout creation fails
 * @summary Create Checkout
 */
export const createCheckoutApiPaymentsCheckoutPost = (
    createCheckoutRequest: CreateCheckoutRequest,
 signal?: AbortSignal
) => {


      return customFetch<CheckoutResponse>(
      {url: `/api/payments/checkout`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createCheckoutRequest, signal
    },
      );
    }



export const getCreateCheckoutApiPaymentsCheckoutPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCheckoutApiPaymentsCheckoutPost>>, TError,{data: CreateCheckoutRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createCheckoutApiPaymentsCheckoutPost>>, TError,{data: CreateCheckoutRequest}, TContext> => {

const mutationKey = ['createCheckoutApiPaymentsCheckoutPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCheckoutApiPaymentsCheckoutPost>>, {data: CreateCheckoutRequest}> = (props) => {
          const {data} = props ?? {};

          return  createCheckoutApiPaymentsCheckoutPost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type CreateCheckoutApiPaymentsCheckoutPostMutationResult = NonNullable<Awaited<ReturnType<typeof createCheckoutApiPaymentsCheckoutPost>>>
    export type CreateCheckoutApiPaymentsCheckoutPostMutationBody = CreateCheckoutRequest
    export type CreateCheckoutApiPaymentsCheckoutPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Create Checkout
 */
export const useCreateCheckoutApiPaymentsCheckoutPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCheckoutApiPaymentsCheckoutPost>>, TError,{data: CreateCheckoutRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createCheckoutApiPaymentsCheckoutPost>>,
        TError,
        {data: CreateCheckoutRequest},
        TContext
      > => {

      const mutationOptions = getCreateCheckoutApiPaymentsCheckoutPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get a link to the Stripe Express dashboard for an instructor.

Returns:
    DashboardLinkResponse with dashboard URL

Raises:
    HTTPException: If dashboard link creation fails
 * @summary Get Dashboard Link
 */
export const getDashboardLinkApiPaymentsConnectDashboardGet = (

 signal?: AbortSignal
) => {


      return customFetch<DashboardLinkResponse>(
      {url: `/api/payments/connect/dashboard`, method: 'GET', signal
    },
      );
    }




export const getGetDashboardLinkApiPaymentsConnectDashboardGetQueryKey = () => {
    return [
    `/api/payments/connect/dashboard`
    ] as const;
    }


export const getGetDashboardLinkApiPaymentsConnectDashboardGetQueryOptions = <TData = Awaited<ReturnType<typeof getDashboardLinkApiPaymentsConnectDashboardGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardLinkApiPaymentsConnectDashboardGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDashboardLinkApiPaymentsConnectDashboardGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDashboardLinkApiPaymentsConnectDashboardGet>>> = ({ signal }) => getDashboardLinkApiPaymentsConnectDashboardGet(signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDashboardLinkApiPaymentsConnectDashboardGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDashboardLinkApiPaymentsConnectDashboardGetQueryResult = NonNullable<Awaited<ReturnType<typeof getDashboardLinkApiPaymentsConnectDashboardGet>>>
export type GetDashboardLinkApiPaymentsConnectDashboardGetQueryError = ErrorType<unknown>


export function useGetDashboardLinkApiPaymentsConnectDashboardGet<TData = Awaited<ReturnType<typeof getDashboardLinkApiPaymentsConnectDashboardGet>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardLinkApiPaymentsConnectDashboardGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDashboardLinkApiPaymentsConnectDashboardGet>>,
          TError,
          Awaited<ReturnType<typeof getDashboardLinkApiPaymentsConnectDashboardGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDashboardLinkApiPaymentsConnectDashboardGet<TData = Awaited<ReturnType<typeof getDashboardLinkApiPaymentsConnectDashboardGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardLinkApiPaymentsConnectDashboardGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDashboardLinkApiPaymentsConnectDashboardGet>>,
          TError,
          Awaited<ReturnType<typeof getDashboardLinkApiPaymentsConnectDashboardGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDashboardLinkApiPaymentsConnectDashboardGet<TData = Awaited<ReturnType<typeof getDashboardLinkApiPaymentsConnectDashboardGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardLinkApiPaymentsConnectDashboardGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Dashboard Link
 */

export function useGetDashboardLinkApiPaymentsConnectDashboardGet<TData = Awaited<ReturnType<typeof getDashboardLinkApiPaymentsConnectDashboardGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDashboardLinkApiPaymentsConnectDashboardGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDashboardLinkApiPaymentsConnectDashboardGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Trigger an instant payout for an instructor's connected account.

Uses Stripe's instant payout capability (account eligibility required). This does NOT aggregate platform funds; it
triggers Stripe to pay out the instructor's available balance instantly. We record a metric for adoption.
 * @summary Request Instant Payout
 */
export const requestInstantPayoutApiPaymentsConnectInstantPayoutPost = (

 signal?: AbortSignal
) => {


      return customFetch<InstantPayoutResponse>(
      {url: `/api/payments/connect/instant-payout`, method: 'POST', signal
    },
      );
    }



export const getRequestInstantPayoutApiPaymentsConnectInstantPayoutPostMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof requestInstantPayoutApiPaymentsConnectInstantPayoutPost>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof requestInstantPayoutApiPaymentsConnectInstantPayoutPost>>, TError,void, TContext> => {

const mutationKey = ['requestInstantPayoutApiPaymentsConnectInstantPayoutPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof requestInstantPayoutApiPaymentsConnectInstantPayoutPost>>, void> = () => {


          return  requestInstantPayoutApiPaymentsConnectInstantPayoutPost()
        }




  return  { mutationFn, ...mutationOptions }}

    export type RequestInstantPayoutApiPaymentsConnectInstantPayoutPostMutationResult = NonNullable<Awaited<ReturnType<typeof requestInstantPayoutApiPaymentsConnectInstantPayoutPost>>>

    export type RequestInstantPayoutApiPaymentsConnectInstantPayoutPostMutationError = ErrorType<unknown>

    /**
 * @summary Request Instant Payout
 */
export const useRequestInstantPayoutApiPaymentsConnectInstantPayoutPost = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof requestInstantPayoutApiPaymentsConnectInstantPayoutPost>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof requestInstantPayoutApiPaymentsConnectInstantPayoutPost>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getRequestInstantPayoutApiPaymentsConnectInstantPayoutPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Start Stripe Connect onboarding for an instructor.

Creates a Stripe Express account and generates an onboarding link.
If the instructor already has an account, returns existing details.

Returns:
    OnboardingResponse with account ID and onboarding URL

Raises:
    HTTPException: If onboarding setup fails
 * @summary Start Onboarding
 */
export const startOnboardingApiPaymentsConnectOnboardPost = (
    params?: StartOnboardingApiPaymentsConnectOnboardPostParams,
 signal?: AbortSignal
) => {


      return customFetch<OnboardingResponse>(
      {url: `/api/payments/connect/onboard`, method: 'POST',
        params, signal
    },
      );
    }



export const getStartOnboardingApiPaymentsConnectOnboardPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startOnboardingApiPaymentsConnectOnboardPost>>, TError,{params?: StartOnboardingApiPaymentsConnectOnboardPostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof startOnboardingApiPaymentsConnectOnboardPost>>, TError,{params?: StartOnboardingApiPaymentsConnectOnboardPostParams}, TContext> => {

const mutationKey = ['startOnboardingApiPaymentsConnectOnboardPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof startOnboardingApiPaymentsConnectOnboardPost>>, {params?: StartOnboardingApiPaymentsConnectOnboardPostParams}> = (props) => {
          const {params} = props ?? {};

          return  startOnboardingApiPaymentsConnectOnboardPost(params,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type StartOnboardingApiPaymentsConnectOnboardPostMutationResult = NonNullable<Awaited<ReturnType<typeof startOnboardingApiPaymentsConnectOnboardPost>>>

    export type StartOnboardingApiPaymentsConnectOnboardPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Start Onboarding
 */
export const useStartOnboardingApiPaymentsConnectOnboardPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof startOnboardingApiPaymentsConnectOnboardPost>>, TError,{params?: StartOnboardingApiPaymentsConnectOnboardPostParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof startOnboardingApiPaymentsConnectOnboardPost>>,
        TError,
        {params?: StartOnboardingApiPaymentsConnectOnboardPostParams},
        TContext
      > => {

      const mutationOptions = getStartOnboardingApiPaymentsConnectOnboardPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Set payout schedule for the current instructor's connected account.

Default: weekly on Tuesday. Valid anchors: monday..sunday.
 * @summary Set Payout Schedule
 */
export const setPayoutScheduleApiPaymentsConnectPayoutSchedulePost = (
    params?: SetPayoutScheduleApiPaymentsConnectPayoutSchedulePostParams,
 signal?: AbortSignal
) => {


      return customFetch<PayoutScheduleResponse>(
      {url: `/api/payments/connect/payout-schedule`, method: 'POST',
        params, signal
    },
      );
    }



export const getSetPayoutScheduleApiPaymentsConnectPayoutSchedulePostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setPayoutScheduleApiPaymentsConnectPayoutSchedulePost>>, TError,{params?: SetPayoutScheduleApiPaymentsConnectPayoutSchedulePostParams}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof setPayoutScheduleApiPaymentsConnectPayoutSchedulePost>>, TError,{params?: SetPayoutScheduleApiPaymentsConnectPayoutSchedulePostParams}, TContext> => {

const mutationKey = ['setPayoutScheduleApiPaymentsConnectPayoutSchedulePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof setPayoutScheduleApiPaymentsConnectPayoutSchedulePost>>, {params?: SetPayoutScheduleApiPaymentsConnectPayoutSchedulePostParams}> = (props) => {
          const {params} = props ?? {};

          return  setPayoutScheduleApiPaymentsConnectPayoutSchedulePost(params,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type SetPayoutScheduleApiPaymentsConnectPayoutSchedulePostMutationResult = NonNullable<Awaited<ReturnType<typeof setPayoutScheduleApiPaymentsConnectPayoutSchedulePost>>>

    export type SetPayoutScheduleApiPaymentsConnectPayoutSchedulePostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Set Payout Schedule
 */
export const useSetPayoutScheduleApiPaymentsConnectPayoutSchedulePost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof setPayoutScheduleApiPaymentsConnectPayoutSchedulePost>>, TError,{params?: SetPayoutScheduleApiPaymentsConnectPayoutSchedulePostParams}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof setPayoutScheduleApiPaymentsConnectPayoutSchedulePost>>,
        TError,
        {params?: SetPayoutScheduleApiPaymentsConnectPayoutSchedulePostParams},
        TContext
      > => {

      const mutationOptions = getSetPayoutScheduleApiPaymentsConnectPayoutSchedulePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get the onboarding status for an instructor's Stripe account.

Returns:
    OnboardingStatusResponse with account status details

Raises:
    HTTPException: If status check fails
 * @summary Get Onboarding Status
 */
export const getOnboardingStatusApiPaymentsConnectStatusGet = (

 signal?: AbortSignal
) => {


      return customFetch<OnboardingStatusResponse>(
      {url: `/api/payments/connect/status`, method: 'GET', signal
    },
      );
    }




export const getGetOnboardingStatusApiPaymentsConnectStatusGetQueryKey = () => {
    return [
    `/api/payments/connect/status`
    ] as const;
    }


export const getGetOnboardingStatusApiPaymentsConnectStatusGetQueryOptions = <TData = Awaited<ReturnType<typeof getOnboardingStatusApiPaymentsConnectStatusGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOnboardingStatusApiPaymentsConnectStatusGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOnboardingStatusApiPaymentsConnectStatusGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOnboardingStatusApiPaymentsConnectStatusGet>>> = ({ signal }) => getOnboardingStatusApiPaymentsConnectStatusGet(signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOnboardingStatusApiPaymentsConnectStatusGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetOnboardingStatusApiPaymentsConnectStatusGetQueryResult = NonNullable<Awaited<ReturnType<typeof getOnboardingStatusApiPaymentsConnectStatusGet>>>
export type GetOnboardingStatusApiPaymentsConnectStatusGetQueryError = ErrorType<unknown>


export function useGetOnboardingStatusApiPaymentsConnectStatusGet<TData = Awaited<ReturnType<typeof getOnboardingStatusApiPaymentsConnectStatusGet>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOnboardingStatusApiPaymentsConnectStatusGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOnboardingStatusApiPaymentsConnectStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getOnboardingStatusApiPaymentsConnectStatusGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOnboardingStatusApiPaymentsConnectStatusGet<TData = Awaited<ReturnType<typeof getOnboardingStatusApiPaymentsConnectStatusGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOnboardingStatusApiPaymentsConnectStatusGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOnboardingStatusApiPaymentsConnectStatusGet>>,
          TError,
          Awaited<ReturnType<typeof getOnboardingStatusApiPaymentsConnectStatusGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetOnboardingStatusApiPaymentsConnectStatusGet<TData = Awaited<ReturnType<typeof getOnboardingStatusApiPaymentsConnectStatusGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOnboardingStatusApiPaymentsConnectStatusGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Onboarding Status
 */

export function useGetOnboardingStatusApiPaymentsConnectStatusGet<TData = Awaited<ReturnType<typeof getOnboardingStatusApiPaymentsConnectStatusGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOnboardingStatusApiPaymentsConnectStatusGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetOnboardingStatusApiPaymentsConnectStatusGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get user's credit balance

Returns available credits and expiration
 * @summary Get Credit Balance
 */
export const getCreditBalanceApiPaymentsCreditsGet = (

 signal?: AbortSignal
) => {


      return customFetch<CreditBalanceResponse>(
      {url: `/api/payments/credits`, method: 'GET', signal
    },
      );
    }




export const getGetCreditBalanceApiPaymentsCreditsGetQueryKey = () => {
    return [
    `/api/payments/credits`
    ] as const;
    }


export const getGetCreditBalanceApiPaymentsCreditsGetQueryOptions = <TData = Awaited<ReturnType<typeof getCreditBalanceApiPaymentsCreditsGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCreditBalanceApiPaymentsCreditsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCreditBalanceApiPaymentsCreditsGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCreditBalanceApiPaymentsCreditsGet>>> = ({ signal }) => getCreditBalanceApiPaymentsCreditsGet(signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCreditBalanceApiPaymentsCreditsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCreditBalanceApiPaymentsCreditsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getCreditBalanceApiPaymentsCreditsGet>>>
export type GetCreditBalanceApiPaymentsCreditsGetQueryError = ErrorType<unknown>


export function useGetCreditBalanceApiPaymentsCreditsGet<TData = Awaited<ReturnType<typeof getCreditBalanceApiPaymentsCreditsGet>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCreditBalanceApiPaymentsCreditsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCreditBalanceApiPaymentsCreditsGet>>,
          TError,
          Awaited<ReturnType<typeof getCreditBalanceApiPaymentsCreditsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCreditBalanceApiPaymentsCreditsGet<TData = Awaited<ReturnType<typeof getCreditBalanceApiPaymentsCreditsGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCreditBalanceApiPaymentsCreditsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCreditBalanceApiPaymentsCreditsGet>>,
          TError,
          Awaited<ReturnType<typeof getCreditBalanceApiPaymentsCreditsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCreditBalanceApiPaymentsCreditsGet<TData = Awaited<ReturnType<typeof getCreditBalanceApiPaymentsCreditsGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCreditBalanceApiPaymentsCreditsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Credit Balance
 */

export function useGetCreditBalanceApiPaymentsCreditsGet<TData = Awaited<ReturnType<typeof getCreditBalanceApiPaymentsCreditsGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCreditBalanceApiPaymentsCreditsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCreditBalanceApiPaymentsCreditsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get earnings statistics for an instructor.

Returns:
    Instructor earnings data

Raises:
    HTTPException: If earnings calculation fails
 * @summary Get Instructor Earnings
 */
export const getInstructorEarningsApiPaymentsEarningsGet = (

 signal?: AbortSignal
) => {


      return customFetch<EarningsResponse>(
      {url: `/api/payments/earnings`, method: 'GET', signal
    },
      );
    }




export const getGetInstructorEarningsApiPaymentsEarningsGetQueryKey = () => {
    return [
    `/api/payments/earnings`
    ] as const;
    }


export const getGetInstructorEarningsApiPaymentsEarningsGetQueryOptions = <TData = Awaited<ReturnType<typeof getInstructorEarningsApiPaymentsEarningsGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInstructorEarningsApiPaymentsEarningsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetInstructorEarningsApiPaymentsEarningsGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getInstructorEarningsApiPaymentsEarningsGet>>> = ({ signal }) => getInstructorEarningsApiPaymentsEarningsGet(signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getInstructorEarningsApiPaymentsEarningsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetInstructorEarningsApiPaymentsEarningsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getInstructorEarningsApiPaymentsEarningsGet>>>
export type GetInstructorEarningsApiPaymentsEarningsGetQueryError = ErrorType<unknown>


export function useGetInstructorEarningsApiPaymentsEarningsGet<TData = Awaited<ReturnType<typeof getInstructorEarningsApiPaymentsEarningsGet>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInstructorEarningsApiPaymentsEarningsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstructorEarningsApiPaymentsEarningsGet>>,
          TError,
          Awaited<ReturnType<typeof getInstructorEarningsApiPaymentsEarningsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInstructorEarningsApiPaymentsEarningsGet<TData = Awaited<ReturnType<typeof getInstructorEarningsApiPaymentsEarningsGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInstructorEarningsApiPaymentsEarningsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getInstructorEarningsApiPaymentsEarningsGet>>,
          TError,
          Awaited<ReturnType<typeof getInstructorEarningsApiPaymentsEarningsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetInstructorEarningsApiPaymentsEarningsGet<TData = Awaited<ReturnType<typeof getInstructorEarningsApiPaymentsEarningsGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInstructorEarningsApiPaymentsEarningsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Instructor Earnings
 */

export function useGetInstructorEarningsApiPaymentsEarningsGet<TData = Awaited<ReturnType<typeof getInstructorEarningsApiPaymentsEarningsGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getInstructorEarningsApiPaymentsEarningsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetInstructorEarningsApiPaymentsEarningsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Fetch latest Stripe Identity status and persist verification on success.

This avoids blocking general status calls and lets the UI trigger a one-off refresh
right after the modal/hosted flow returns.
 * @summary Refresh Identity Status
 */
export const refreshIdentityStatusApiPaymentsIdentityRefreshPost = (

 signal?: AbortSignal
) => {


      return customFetch<IdentityRefreshResponse>(
      {url: `/api/payments/identity/refresh`, method: 'POST', signal
    },
      );
    }



export const getRefreshIdentityStatusApiPaymentsIdentityRefreshPostMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshIdentityStatusApiPaymentsIdentityRefreshPost>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof refreshIdentityStatusApiPaymentsIdentityRefreshPost>>, TError,void, TContext> => {

const mutationKey = ['refreshIdentityStatusApiPaymentsIdentityRefreshPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshIdentityStatusApiPaymentsIdentityRefreshPost>>, void> = () => {


          return  refreshIdentityStatusApiPaymentsIdentityRefreshPost()
        }




  return  { mutationFn, ...mutationOptions }}

    export type RefreshIdentityStatusApiPaymentsIdentityRefreshPostMutationResult = NonNullable<Awaited<ReturnType<typeof refreshIdentityStatusApiPaymentsIdentityRefreshPost>>>

    export type RefreshIdentityStatusApiPaymentsIdentityRefreshPostMutationError = ErrorType<unknown>

    /**
 * @summary Refresh Identity Status
 */
export const useRefreshIdentityStatusApiPaymentsIdentityRefreshPost = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshIdentityStatusApiPaymentsIdentityRefreshPost>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof refreshIdentityStatusApiPaymentsIdentityRefreshPost>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getRefreshIdentityStatusApiPaymentsIdentityRefreshPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Create a Stripe Identity verification session for the current user.
 * @summary Create Identity Session
 */
export const createIdentitySessionApiPaymentsIdentitySessionPost = (

 signal?: AbortSignal
) => {


      return customFetch<IdentitySessionResponse>(
      {url: `/api/payments/identity/session`, method: 'POST', signal
    },
      );
    }



export const getCreateIdentitySessionApiPaymentsIdentitySessionPostMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createIdentitySessionApiPaymentsIdentitySessionPost>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createIdentitySessionApiPaymentsIdentitySessionPost>>, TError,void, TContext> => {

const mutationKey = ['createIdentitySessionApiPaymentsIdentitySessionPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createIdentitySessionApiPaymentsIdentitySessionPost>>, void> = () => {


          return  createIdentitySessionApiPaymentsIdentitySessionPost()
        }




  return  { mutationFn, ...mutationOptions }}

    export type CreateIdentitySessionApiPaymentsIdentitySessionPostMutationResult = NonNullable<Awaited<ReturnType<typeof createIdentitySessionApiPaymentsIdentitySessionPost>>>

    export type CreateIdentitySessionApiPaymentsIdentitySessionPostMutationError = ErrorType<unknown>

    /**
 * @summary Create Identity Session
 */
export const useCreateIdentitySessionApiPaymentsIdentitySessionPost = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createIdentitySessionApiPaymentsIdentitySessionPost>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createIdentitySessionApiPaymentsIdentitySessionPost>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getCreateIdentitySessionApiPaymentsIdentitySessionPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * List all payment methods for a student.

Returns:
    List of PaymentMethodResponse objects

Raises:
    HTTPException: If payment method listing fails
 * @summary List Payment Methods
 */
export const listPaymentMethodsApiPaymentsMethodsGet = (

 signal?: AbortSignal
) => {


      return customFetch<PaymentMethodResponse[]>(
      {url: `/api/payments/methods`, method: 'GET', signal
    },
      );
    }




export const getListPaymentMethodsApiPaymentsMethodsGetQueryKey = () => {
    return [
    `/api/payments/methods`
    ] as const;
    }


export const getListPaymentMethodsApiPaymentsMethodsGetQueryOptions = <TData = Awaited<ReturnType<typeof listPaymentMethodsApiPaymentsMethodsGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPaymentMethodsApiPaymentsMethodsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPaymentMethodsApiPaymentsMethodsGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPaymentMethodsApiPaymentsMethodsGet>>> = ({ signal }) => listPaymentMethodsApiPaymentsMethodsGet(signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPaymentMethodsApiPaymentsMethodsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListPaymentMethodsApiPaymentsMethodsGetQueryResult = NonNullable<Awaited<ReturnType<typeof listPaymentMethodsApiPaymentsMethodsGet>>>
export type ListPaymentMethodsApiPaymentsMethodsGetQueryError = ErrorType<unknown>


export function useListPaymentMethodsApiPaymentsMethodsGet<TData = Awaited<ReturnType<typeof listPaymentMethodsApiPaymentsMethodsGet>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPaymentMethodsApiPaymentsMethodsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPaymentMethodsApiPaymentsMethodsGet>>,
          TError,
          Awaited<ReturnType<typeof listPaymentMethodsApiPaymentsMethodsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPaymentMethodsApiPaymentsMethodsGet<TData = Awaited<ReturnType<typeof listPaymentMethodsApiPaymentsMethodsGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPaymentMethodsApiPaymentsMethodsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPaymentMethodsApiPaymentsMethodsGet>>,
          TError,
          Awaited<ReturnType<typeof listPaymentMethodsApiPaymentsMethodsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPaymentMethodsApiPaymentsMethodsGet<TData = Awaited<ReturnType<typeof listPaymentMethodsApiPaymentsMethodsGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPaymentMethodsApiPaymentsMethodsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List Payment Methods
 */

export function useListPaymentMethodsApiPaymentsMethodsGet<TData = Awaited<ReturnType<typeof listPaymentMethodsApiPaymentsMethodsGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPaymentMethodsApiPaymentsMethodsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListPaymentMethodsApiPaymentsMethodsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Save a payment method for a student.

Args:
    payload: Payment method details

Returns:
    PaymentMethodResponse with saved payment method details

Raises:
    HTTPException: If payment method saving fails
 * @summary Save Payment Method
 */
export const savePaymentMethodApiPaymentsMethodsPost = (
    savePaymentMethodRequest: SavePaymentMethodRequest,
 signal?: AbortSignal
) => {


      return customFetch<PaymentMethodResponse>(
      {url: `/api/payments/methods`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: savePaymentMethodRequest, signal
    },
      );
    }



export const getSavePaymentMethodApiPaymentsMethodsPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof savePaymentMethodApiPaymentsMethodsPost>>, TError,{data: SavePaymentMethodRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof savePaymentMethodApiPaymentsMethodsPost>>, TError,{data: SavePaymentMethodRequest}, TContext> => {

const mutationKey = ['savePaymentMethodApiPaymentsMethodsPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof savePaymentMethodApiPaymentsMethodsPost>>, {data: SavePaymentMethodRequest}> = (props) => {
          const {data} = props ?? {};

          return  savePaymentMethodApiPaymentsMethodsPost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type SavePaymentMethodApiPaymentsMethodsPostMutationResult = NonNullable<Awaited<ReturnType<typeof savePaymentMethodApiPaymentsMethodsPost>>>
    export type SavePaymentMethodApiPaymentsMethodsPostMutationBody = SavePaymentMethodRequest
    export type SavePaymentMethodApiPaymentsMethodsPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Save Payment Method
 */
export const useSavePaymentMethodApiPaymentsMethodsPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof savePaymentMethodApiPaymentsMethodsPost>>, TError,{data: SavePaymentMethodRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof savePaymentMethodApiPaymentsMethodsPost>>,
        TError,
        {data: SavePaymentMethodRequest},
        TContext
      > => {

      const mutationOptions = getSavePaymentMethodApiPaymentsMethodsPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete a payment method for a student.

Args:
    method_id: Payment method ID to delete

Returns:
    Success confirmation

Raises:
    HTTPException: If payment method deletion fails
 * @summary Delete Payment Method
 */
export const deletePaymentMethodApiPaymentsMethodsMethodIdDelete = (
    methodId: string,
 ) => {


      return customFetch<AppSchemasPaymentSchemasDeleteResponse>(
      {url: `/api/payments/methods/${methodId}`, method: 'DELETE'
    },
      );
    }



export const getDeletePaymentMethodApiPaymentsMethodsMethodIdDeleteMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePaymentMethodApiPaymentsMethodsMethodIdDelete>>, TError,{methodId: string}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deletePaymentMethodApiPaymentsMethodsMethodIdDelete>>, TError,{methodId: string}, TContext> => {

const mutationKey = ['deletePaymentMethodApiPaymentsMethodsMethodIdDelete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePaymentMethodApiPaymentsMethodsMethodIdDelete>>, {methodId: string}> = (props) => {
          const {methodId} = props ?? {};

          return  deletePaymentMethodApiPaymentsMethodsMethodIdDelete(methodId,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type DeletePaymentMethodApiPaymentsMethodsMethodIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deletePaymentMethodApiPaymentsMethodsMethodIdDelete>>>

    export type DeletePaymentMethodApiPaymentsMethodsMethodIdDeleteMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Delete Payment Method
 */
export const useDeletePaymentMethodApiPaymentsMethodsMethodIdDelete = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePaymentMethodApiPaymentsMethodsMethodIdDelete>>, TError,{methodId: string}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePaymentMethodApiPaymentsMethodsMethodIdDelete>>,
        TError,
        {methodId: string},
        TContext
      > => {

      const mutationOptions = getDeletePaymentMethodApiPaymentsMethodsMethodIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get user's transaction history

Returns list of completed payments with booking details
 * @summary Get Transaction History
 */
export const getTransactionHistoryApiPaymentsTransactionsGet = (
    params?: GetTransactionHistoryApiPaymentsTransactionsGetParams,
 signal?: AbortSignal
) => {


      return customFetch<TransactionHistoryItem[]>(
      {url: `/api/payments/transactions`, method: 'GET',
        params, signal
    },
      );
    }




export const getGetTransactionHistoryApiPaymentsTransactionsGetQueryKey = (params?: GetTransactionHistoryApiPaymentsTransactionsGetParams,) => {
    return [
    `/api/payments/transactions`, ...(params ? [params]: [])
    ] as const;
    }


export const getGetTransactionHistoryApiPaymentsTransactionsGetQueryOptions = <TData = Awaited<ReturnType<typeof getTransactionHistoryApiPaymentsTransactionsGet>>, TError = ErrorType<HTTPValidationError>>(params?: GetTransactionHistoryApiPaymentsTransactionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionHistoryApiPaymentsTransactionsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransactionHistoryApiPaymentsTransactionsGetQueryKey(params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransactionHistoryApiPaymentsTransactionsGet>>> = ({ signal }) => getTransactionHistoryApiPaymentsTransactionsGet(params, signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTransactionHistoryApiPaymentsTransactionsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTransactionHistoryApiPaymentsTransactionsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getTransactionHistoryApiPaymentsTransactionsGet>>>
export type GetTransactionHistoryApiPaymentsTransactionsGetQueryError = ErrorType<HTTPValidationError>


export function useGetTransactionHistoryApiPaymentsTransactionsGet<TData = Awaited<ReturnType<typeof getTransactionHistoryApiPaymentsTransactionsGet>>, TError = ErrorType<HTTPValidationError>>(
 params: undefined |  GetTransactionHistoryApiPaymentsTransactionsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionHistoryApiPaymentsTransactionsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransactionHistoryApiPaymentsTransactionsGet>>,
          TError,
          Awaited<ReturnType<typeof getTransactionHistoryApiPaymentsTransactionsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionHistoryApiPaymentsTransactionsGet<TData = Awaited<ReturnType<typeof getTransactionHistoryApiPaymentsTransactionsGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetTransactionHistoryApiPaymentsTransactionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionHistoryApiPaymentsTransactionsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTransactionHistoryApiPaymentsTransactionsGet>>,
          TError,
          Awaited<ReturnType<typeof getTransactionHistoryApiPaymentsTransactionsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTransactionHistoryApiPaymentsTransactionsGet<TData = Awaited<ReturnType<typeof getTransactionHistoryApiPaymentsTransactionsGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetTransactionHistoryApiPaymentsTransactionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionHistoryApiPaymentsTransactionsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Transaction History
 */

export function useGetTransactionHistoryApiPaymentsTransactionsGet<TData = Awaited<ReturnType<typeof getTransactionHistoryApiPaymentsTransactionsGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetTransactionHistoryApiPaymentsTransactionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTransactionHistoryApiPaymentsTransactionsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTransactionHistoryApiPaymentsTransactionsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Handle Stripe webhook events from both platform and connected accounts.

Works with both local development (single secret) and deployed environments (multiple secrets).
Tries each configured webhook secret until one successfully verifies the signature.

Returns:
    Success confirmation (always returns 200 to prevent Stripe retries)

Note:
    This endpoint has no authentication as it uses webhook signature verification
 * @summary Handle Stripe Webhook
 */
export const handleStripeWebhookApiPaymentsWebhooksStripePost = (

 signal?: AbortSignal
) => {


      return customFetch<WebhookResponse>(
      {url: `/api/payments/webhooks/stripe`, method: 'POST', signal
    },
      );
    }



export const getHandleStripeWebhookApiPaymentsWebhooksStripePostMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof handleStripeWebhookApiPaymentsWebhooksStripePost>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof handleStripeWebhookApiPaymentsWebhooksStripePost>>, TError,void, TContext> => {

const mutationKey = ['handleStripeWebhookApiPaymentsWebhooksStripePost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof handleStripeWebhookApiPaymentsWebhooksStripePost>>, void> = () => {


          return  handleStripeWebhookApiPaymentsWebhooksStripePost()
        }




  return  { mutationFn, ...mutationOptions }}

    export type HandleStripeWebhookApiPaymentsWebhooksStripePostMutationResult = NonNullable<Awaited<ReturnType<typeof handleStripeWebhookApiPaymentsWebhooksStripePost>>>

    export type HandleStripeWebhookApiPaymentsWebhooksStripePostMutationError = ErrorType<unknown>

    /**
 * @summary Handle Stripe Webhook
 */
export const useHandleStripeWebhookApiPaymentsWebhooksStripePost = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof handleStripeWebhookApiPaymentsWebhooksStripePost>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof handleStripeWebhookApiPaymentsWebhooksStripePost>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getHandleStripeWebhookApiPaymentsWebhooksStripePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
