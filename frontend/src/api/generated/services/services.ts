/**
 * Generated by orval v7.16.1 ðŸº
 * Do not edit manually.
 * iNSTAiNSTRU API
 * iNSTAiNSTRU - NYC's Premier Instructor Marketplace
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AllServicesWithInstructorsResponse,
  CatalogServiceMinimalResponse,
  CatalogServiceResponse,
  CategoryResponse,
  GetCatalogServicesServicesCatalogGetParams,
  GetTopServicesPerCategoryServicesCatalogTopPerCategoryGetParams,
  HTTPValidationError,
  InstructorServiceCreate,
  InstructorServiceResponse,
  SearchServicesServicesSearchGetParams,
  ServiceSearchResponse,
  TopServicesPerCategoryResponse
} from '../instructly.schemas';

import { customFetch } from '../../orval-mutator';
import type { ErrorType } from '../../orval-mutator';




/**
 * Get available services from the catalog.

Optionally filter by category slug (e.g., 'music-arts', 'academic').
 * @summary Get Catalog Services
 */
export const getCatalogServicesServicesCatalogGet = (
    params?: GetCatalogServicesServicesCatalogGetParams,
 signal?: AbortSignal
) => {


      return customFetch<CatalogServiceResponse[]>(
      {url: `/services/catalog`, method: 'GET',
        params, signal
    },
      );
    }




export const getGetCatalogServicesServicesCatalogGetQueryKey = (params?: GetCatalogServicesServicesCatalogGetParams,) => {
    return [
    `/services/catalog`, ...(params ? [params]: [])
    ] as const;
    }


export const getGetCatalogServicesServicesCatalogGetQueryOptions = <TData = Awaited<ReturnType<typeof getCatalogServicesServicesCatalogGet>>, TError = ErrorType<HTTPValidationError>>(params?: GetCatalogServicesServicesCatalogGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCatalogServicesServicesCatalogGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCatalogServicesServicesCatalogGetQueryKey(params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getCatalogServicesServicesCatalogGet>>> = ({ signal }) => getCatalogServicesServicesCatalogGet(params, signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getCatalogServicesServicesCatalogGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetCatalogServicesServicesCatalogGetQueryResult = NonNullable<Awaited<ReturnType<typeof getCatalogServicesServicesCatalogGet>>>
export type GetCatalogServicesServicesCatalogGetQueryError = ErrorType<HTTPValidationError>


export function useGetCatalogServicesServicesCatalogGet<TData = Awaited<ReturnType<typeof getCatalogServicesServicesCatalogGet>>, TError = ErrorType<HTTPValidationError>>(
 params: undefined |  GetCatalogServicesServicesCatalogGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCatalogServicesServicesCatalogGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCatalogServicesServicesCatalogGet>>,
          TError,
          Awaited<ReturnType<typeof getCatalogServicesServicesCatalogGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCatalogServicesServicesCatalogGet<TData = Awaited<ReturnType<typeof getCatalogServicesServicesCatalogGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetCatalogServicesServicesCatalogGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCatalogServicesServicesCatalogGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getCatalogServicesServicesCatalogGet>>,
          TError,
          Awaited<ReturnType<typeof getCatalogServicesServicesCatalogGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetCatalogServicesServicesCatalogGet<TData = Awaited<ReturnType<typeof getCatalogServicesServicesCatalogGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetCatalogServicesServicesCatalogGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCatalogServicesServicesCatalogGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Catalog Services
 */

export function useGetCatalogServicesServicesCatalogGet<TData = Awaited<ReturnType<typeof getCatalogServicesServicesCatalogGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetCatalogServicesServicesCatalogGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getCatalogServicesServicesCatalogGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetCatalogServicesServicesCatalogGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all catalog services organized by category with active instructor counts.

This endpoint is optimized for the All Services page, providing all services
with instructor availability information in a single request. Results are
cached for 5 minutes to balance performance with data freshness.

Returns:
    Dictionary with categories and their services, including active instructor counts
 * @summary Get All Services With Instructors
 */
export const getAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet = (

 signal?: AbortSignal
) => {


      return customFetch<AllServicesWithInstructorsResponse>(
      {url: `/services/catalog/all-with-instructors`, method: 'GET', signal
    },
      );
    }




export const getGetAllServicesWithInstructorsServicesCatalogAllWithInstructorsGetQueryKey = () => {
    return [
    `/services/catalog/all-with-instructors`
    ] as const;
    }


export const getGetAllServicesWithInstructorsServicesCatalogAllWithInstructorsGetQueryOptions = <TData = Awaited<ReturnType<typeof getAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAllServicesWithInstructorsServicesCatalogAllWithInstructorsGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet>>> = ({ signal }) => getAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet(signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetAllServicesWithInstructorsServicesCatalogAllWithInstructorsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet>>>
export type GetAllServicesWithInstructorsServicesCatalogAllWithInstructorsGetQueryError = ErrorType<unknown>


export function useGetAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet<TData = Awaited<ReturnType<typeof getAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet>>,
          TError,
          Awaited<ReturnType<typeof getAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet<TData = Awaited<ReturnType<typeof getAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet>>,
          TError,
          Awaited<ReturnType<typeof getAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet<TData = Awaited<ReturnType<typeof getAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get All Services With Instructors
 */

export function useGetAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet<TData = Awaited<ReturnType<typeof getAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getAllServicesWithInstructorsServicesCatalogAllWithInstructorsGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetAllServicesWithInstructorsServicesCatalogAllWithInstructorsGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Return catalog services that have at least one active instructor who teaches kids.

Minimal payload: id, name, slug. Cached for 5 minutes.
 * @summary Get Kids Available Services
 */
export const getKidsAvailableServicesServicesCatalogKidsAvailableGet = (

 signal?: AbortSignal
) => {


      return customFetch<CatalogServiceMinimalResponse[]>(
      {url: `/services/catalog/kids-available`, method: 'GET', signal
    },
      );
    }




export const getGetKidsAvailableServicesServicesCatalogKidsAvailableGetQueryKey = () => {
    return [
    `/services/catalog/kids-available`
    ] as const;
    }


export const getGetKidsAvailableServicesServicesCatalogKidsAvailableGetQueryOptions = <TData = Awaited<ReturnType<typeof getKidsAvailableServicesServicesCatalogKidsAvailableGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKidsAvailableServicesServicesCatalogKidsAvailableGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetKidsAvailableServicesServicesCatalogKidsAvailableGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getKidsAvailableServicesServicesCatalogKidsAvailableGet>>> = ({ signal }) => getKidsAvailableServicesServicesCatalogKidsAvailableGet(signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getKidsAvailableServicesServicesCatalogKidsAvailableGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetKidsAvailableServicesServicesCatalogKidsAvailableGetQueryResult = NonNullable<Awaited<ReturnType<typeof getKidsAvailableServicesServicesCatalogKidsAvailableGet>>>
export type GetKidsAvailableServicesServicesCatalogKidsAvailableGetQueryError = ErrorType<unknown>


export function useGetKidsAvailableServicesServicesCatalogKidsAvailableGet<TData = Awaited<ReturnType<typeof getKidsAvailableServicesServicesCatalogKidsAvailableGet>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKidsAvailableServicesServicesCatalogKidsAvailableGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getKidsAvailableServicesServicesCatalogKidsAvailableGet>>,
          TError,
          Awaited<ReturnType<typeof getKidsAvailableServicesServicesCatalogKidsAvailableGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetKidsAvailableServicesServicesCatalogKidsAvailableGet<TData = Awaited<ReturnType<typeof getKidsAvailableServicesServicesCatalogKidsAvailableGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKidsAvailableServicesServicesCatalogKidsAvailableGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getKidsAvailableServicesServicesCatalogKidsAvailableGet>>,
          TError,
          Awaited<ReturnType<typeof getKidsAvailableServicesServicesCatalogKidsAvailableGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetKidsAvailableServicesServicesCatalogKidsAvailableGet<TData = Awaited<ReturnType<typeof getKidsAvailableServicesServicesCatalogKidsAvailableGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKidsAvailableServicesServicesCatalogKidsAvailableGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Kids Available Services
 */

export function useGetKidsAvailableServicesServicesCatalogKidsAvailableGet<TData = Awaited<ReturnType<typeof getKidsAvailableServicesServicesCatalogKidsAvailableGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getKidsAvailableServicesServicesCatalogKidsAvailableGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetKidsAvailableServicesServicesCatalogKidsAvailableGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get top N services per category for homepage capsules.

Optimized endpoint that returns only the most popular services per category,
perfect for homepage display. Cached for 1 hour since popularity changes daily
but we want fast response times.

Args:
    limit: Number of top services per category (default: 7)

Returns:
    Dictionary with categories and their top services
 * @summary Get Top Services Per Category
 */
export const getTopServicesPerCategoryServicesCatalogTopPerCategoryGet = (
    params?: GetTopServicesPerCategoryServicesCatalogTopPerCategoryGetParams,
 signal?: AbortSignal
) => {


      return customFetch<TopServicesPerCategoryResponse>(
      {url: `/services/catalog/top-per-category`, method: 'GET',
        params, signal
    },
      );
    }




export const getGetTopServicesPerCategoryServicesCatalogTopPerCategoryGetQueryKey = (params?: GetTopServicesPerCategoryServicesCatalogTopPerCategoryGetParams,) => {
    return [
    `/services/catalog/top-per-category`, ...(params ? [params]: [])
    ] as const;
    }


export const getGetTopServicesPerCategoryServicesCatalogTopPerCategoryGetQueryOptions = <TData = Awaited<ReturnType<typeof getTopServicesPerCategoryServicesCatalogTopPerCategoryGet>>, TError = ErrorType<HTTPValidationError>>(params?: GetTopServicesPerCategoryServicesCatalogTopPerCategoryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTopServicesPerCategoryServicesCatalogTopPerCategoryGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTopServicesPerCategoryServicesCatalogTopPerCategoryGetQueryKey(params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTopServicesPerCategoryServicesCatalogTopPerCategoryGet>>> = ({ signal }) => getTopServicesPerCategoryServicesCatalogTopPerCategoryGet(params, signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTopServicesPerCategoryServicesCatalogTopPerCategoryGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetTopServicesPerCategoryServicesCatalogTopPerCategoryGetQueryResult = NonNullable<Awaited<ReturnType<typeof getTopServicesPerCategoryServicesCatalogTopPerCategoryGet>>>
export type GetTopServicesPerCategoryServicesCatalogTopPerCategoryGetQueryError = ErrorType<HTTPValidationError>


export function useGetTopServicesPerCategoryServicesCatalogTopPerCategoryGet<TData = Awaited<ReturnType<typeof getTopServicesPerCategoryServicesCatalogTopPerCategoryGet>>, TError = ErrorType<HTTPValidationError>>(
 params: undefined |  GetTopServicesPerCategoryServicesCatalogTopPerCategoryGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTopServicesPerCategoryServicesCatalogTopPerCategoryGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTopServicesPerCategoryServicesCatalogTopPerCategoryGet>>,
          TError,
          Awaited<ReturnType<typeof getTopServicesPerCategoryServicesCatalogTopPerCategoryGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTopServicesPerCategoryServicesCatalogTopPerCategoryGet<TData = Awaited<ReturnType<typeof getTopServicesPerCategoryServicesCatalogTopPerCategoryGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetTopServicesPerCategoryServicesCatalogTopPerCategoryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTopServicesPerCategoryServicesCatalogTopPerCategoryGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTopServicesPerCategoryServicesCatalogTopPerCategoryGet>>,
          TError,
          Awaited<ReturnType<typeof getTopServicesPerCategoryServicesCatalogTopPerCategoryGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetTopServicesPerCategoryServicesCatalogTopPerCategoryGet<TData = Awaited<ReturnType<typeof getTopServicesPerCategoryServicesCatalogTopPerCategoryGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetTopServicesPerCategoryServicesCatalogTopPerCategoryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTopServicesPerCategoryServicesCatalogTopPerCategoryGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Top Services Per Category
 */

export function useGetTopServicesPerCategoryServicesCatalogTopPerCategoryGet<TData = Awaited<ReturnType<typeof getTopServicesPerCategoryServicesCatalogTopPerCategoryGet>>, TError = ErrorType<HTTPValidationError>>(
 params?: GetTopServicesPerCategoryServicesCatalogTopPerCategoryGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getTopServicesPerCategoryServicesCatalogTopPerCategoryGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetTopServicesPerCategoryServicesCatalogTopPerCategoryGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get all service categories.
 * @summary Get Service Categories
 */
export const getServiceCategoriesServicesCategoriesGet = (

 signal?: AbortSignal
) => {


      return customFetch<CategoryResponse[]>(
      {url: `/services/categories`, method: 'GET', signal
    },
      );
    }




export const getGetServiceCategoriesServicesCategoriesGetQueryKey = () => {
    return [
    `/services/categories`
    ] as const;
    }


export const getGetServiceCategoriesServicesCategoriesGetQueryOptions = <TData = Awaited<ReturnType<typeof getServiceCategoriesServicesCategoriesGet>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCategoriesServicesCategoriesGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServiceCategoriesServicesCategoriesGetQueryKey();



    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServiceCategoriesServicesCategoriesGet>>> = ({ signal }) => getServiceCategoriesServicesCategoriesGet(signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getServiceCategoriesServicesCategoriesGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetServiceCategoriesServicesCategoriesGetQueryResult = NonNullable<Awaited<ReturnType<typeof getServiceCategoriesServicesCategoriesGet>>>
export type GetServiceCategoriesServicesCategoriesGetQueryError = ErrorType<unknown>


export function useGetServiceCategoriesServicesCategoriesGet<TData = Awaited<ReturnType<typeof getServiceCategoriesServicesCategoriesGet>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCategoriesServicesCategoriesGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceCategoriesServicesCategoriesGet>>,
          TError,
          Awaited<ReturnType<typeof getServiceCategoriesServicesCategoriesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetServiceCategoriesServicesCategoriesGet<TData = Awaited<ReturnType<typeof getServiceCategoriesServicesCategoriesGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCategoriesServicesCategoriesGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getServiceCategoriesServicesCategoriesGet>>,
          TError,
          Awaited<ReturnType<typeof getServiceCategoriesServicesCategoriesGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetServiceCategoriesServicesCategoriesGet<TData = Awaited<ReturnType<typeof getServiceCategoriesServicesCategoriesGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCategoriesServicesCategoriesGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Service Categories
 */

export function useGetServiceCategoriesServicesCategoriesGet<TData = Awaited<ReturnType<typeof getServiceCategoriesServicesCategoriesGet>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getServiceCategoriesServicesCategoriesGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetServiceCategoriesServicesCategoriesGetQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Add a service from the catalog to instructor's profile.

Requires INSTRUCTOR role.
 * @summary Add Service To Profile
 */
export const addServiceToProfileServicesInstructorAddPost = (
    instructorServiceCreate: InstructorServiceCreate,
 signal?: AbortSignal
) => {


      return customFetch<InstructorServiceResponse>(
      {url: `/services/instructor/add`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: instructorServiceCreate, signal
    },
      );
    }



export const getAddServiceToProfileServicesInstructorAddPostMutationOptions = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addServiceToProfileServicesInstructorAddPost>>, TError,{data: InstructorServiceCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof addServiceToProfileServicesInstructorAddPost>>, TError,{data: InstructorServiceCreate}, TContext> => {

const mutationKey = ['addServiceToProfileServicesInstructorAddPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};




      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addServiceToProfileServicesInstructorAddPost>>, {data: InstructorServiceCreate}> = (props) => {
          const {data} = props ?? {};

          return  addServiceToProfileServicesInstructorAddPost(data,)
        }




  return  { mutationFn, ...mutationOptions }}

    export type AddServiceToProfileServicesInstructorAddPostMutationResult = NonNullable<Awaited<ReturnType<typeof addServiceToProfileServicesInstructorAddPost>>>
    export type AddServiceToProfileServicesInstructorAddPostMutationBody = InstructorServiceCreate
    export type AddServiceToProfileServicesInstructorAddPostMutationError = ErrorType<HTTPValidationError>

    /**
 * @summary Add Service To Profile
 */
export const useAddServiceToProfileServicesInstructorAddPost = <TError = ErrorType<HTTPValidationError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addServiceToProfileServicesInstructorAddPost>>, TError,{data: InstructorServiceCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addServiceToProfileServicesInstructorAddPost>>,
        TError,
        {data: InstructorServiceCreate},
        TContext
      > => {

      const mutationOptions = getAddServiceToProfileServicesInstructorAddPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Search for instructors by service.

This is an alias for the instructor search endpoint that focuses on service matching.
Searches across service names, categories, and search terms.
 * @summary Search Services
 */
export const searchServicesServicesSearchGet = (
    params: SearchServicesServicesSearchGetParams,
 signal?: AbortSignal
) => {


      return customFetch<ServiceSearchResponse>(
      {url: `/services/search`, method: 'GET',
        params, signal
    },
      );
    }




export const getSearchServicesServicesSearchGetQueryKey = (params?: SearchServicesServicesSearchGetParams,) => {
    return [
    `/services/search`, ...(params ? [params]: [])
    ] as const;
    }


export const getSearchServicesServicesSearchGetQueryOptions = <TData = Awaited<ReturnType<typeof searchServicesServicesSearchGet>>, TError = ErrorType<HTTPValidationError>>(params: SearchServicesServicesSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchServicesServicesSearchGet>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchServicesServicesSearchGetQueryKey(params);



    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchServicesServicesSearchGet>>> = ({ signal }) => searchServicesServicesSearchGet(params, signal);





   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchServicesServicesSearchGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type SearchServicesServicesSearchGetQueryResult = NonNullable<Awaited<ReturnType<typeof searchServicesServicesSearchGet>>>
export type SearchServicesServicesSearchGetQueryError = ErrorType<HTTPValidationError>


export function useSearchServicesServicesSearchGet<TData = Awaited<ReturnType<typeof searchServicesServicesSearchGet>>, TError = ErrorType<HTTPValidationError>>(
 params: SearchServicesServicesSearchGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchServicesServicesSearchGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchServicesServicesSearchGet>>,
          TError,
          Awaited<ReturnType<typeof searchServicesServicesSearchGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchServicesServicesSearchGet<TData = Awaited<ReturnType<typeof searchServicesServicesSearchGet>>, TError = ErrorType<HTTPValidationError>>(
 params: SearchServicesServicesSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchServicesServicesSearchGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof searchServicesServicesSearchGet>>,
          TError,
          Awaited<ReturnType<typeof searchServicesServicesSearchGet>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useSearchServicesServicesSearchGet<TData = Awaited<ReturnType<typeof searchServicesServicesSearchGet>>, TError = ErrorType<HTTPValidationError>>(
 params: SearchServicesServicesSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchServicesServicesSearchGet>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Search Services
 */

export function useSearchServicesServicesSearchGet<TData = Awaited<ReturnType<typeof searchServicesServicesSearchGet>>, TError = ErrorType<HTTPValidationError>>(
 params: SearchServicesServicesSearchGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof searchServicesServicesSearchGet>>, TError, TData>>, }
 , queryClient?: QueryClient
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getSearchServicesServicesSearchGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
