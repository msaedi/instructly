# backend/app/services/system_message_service.py
"""
System Message Service for booking lifecycle events.

Generates system messages in conversations when booking events occur:
- Booking created
- Booking cancelled
- Booking rescheduled
- Booking completed
"""

import asyncio
from datetime import date, time
import logging
from typing import Any, Callable, Coroutine, Optional

from sqlalchemy.orm import Session

from ..models.conversation import Conversation
from ..models.message import (
    MESSAGE_TYPE_SYSTEM_BOOKING_CANCELLED,
    MESSAGE_TYPE_SYSTEM_BOOKING_COMPLETED,
    MESSAGE_TYPE_SYSTEM_BOOKING_CREATED,
    MESSAGE_TYPE_SYSTEM_BOOKING_RESCHEDULED,
)
from ..repositories.conversation_repository import ConversationRepository
from ..repositories.factory import RepositoryFactory
from ..repositories.message_repository import MessageRepository
from .base import BaseService
from .messaging import publish_new_message

logger = logging.getLogger(__name__)


class SystemMessageService(BaseService):
    """
    Service for creating system messages in conversations.

    System messages are auto-generated by booking lifecycle events
    and have no sender_id (they're from "the system").
    """

    def __init__(
        self,
        db: Session,
        conversation_repository: Optional[ConversationRepository] = None,
        message_repository: Optional[MessageRepository] = None,
    ):
        """
        Initialize system message service.

        Args:
            db: Database session
            conversation_repository: Optional repository for conversations
            message_repository: Optional repository for messages
        """
        super().__init__(db)
        self.conversation_repository = (
            conversation_repository or RepositoryFactory.create_conversation_repository(db)
        )
        self.message_repository = message_repository or RepositoryFactory.create_message_repository(
            db
        )
        self.logger = logging.getLogger(__name__)

    @BaseService.measure_operation("create_booking_created_message")
    def create_booking_created_message(
        self,
        student_id: str,
        instructor_id: str,
        booking_id: str,
        service_name: str,
        booking_date: date,
        start_time: time,
    ) -> None:
        """
        Create system message when a booking is created.

        Creates conversation if it doesn't exist (handles first booking).

        Args:
            student_id: ID of the student
            instructor_id: ID of the instructor
            booking_id: ID of the booking
            service_name: Name of the service booked
            booking_date: Date of the booking
            start_time: Start time of the booking
        """
        conversation = self._get_or_create_conversation(student_id, instructor_id)
        student_first, _instructor_first = self._get_participant_names(student_id, instructor_id)

        # Format the message
        date_str = booking_date.strftime("%b %d")  # e.g., "Dec 10"
        time_str = self._format_time(start_time)  # e.g., "5pm"
        # Personalized: include student first name and service name
        booker = student_first or "student"
        content = f"âœ… {service_name} booked by {booker}: {date_str} at {time_str}"

        self._create_system_message(
            conversation_id=conversation.id,
            booking_id=booking_id,
            content=content,
            message_type=MESSAGE_TYPE_SYSTEM_BOOKING_CREATED,
        )

        self.logger.info(
            f"Created booking_created system message for booking {booking_id}",
            extra={
                "booking_id": booking_id,
                "conversation_id": conversation.id,
            },
        )

    @BaseService.measure_operation("create_booking_cancelled_message")
    def create_booking_cancelled_message(
        self,
        student_id: str,
        instructor_id: str,
        booking_id: str,
        booking_date: date,
        start_time: time,
        cancelled_by: Optional[str] = None,  # 'student', 'instructor', or None
    ) -> None:
        """
        Create system message when a booking is cancelled.

        Args:
            student_id: ID of the student
            instructor_id: ID of the instructor
            booking_id: ID of the booking
            booking_date: Date of the booking
            start_time: Start time of the booking
            cancelled_by: Who cancelled ('student', 'instructor', or None)
        """
        conversation = self._get_or_create_conversation(student_id, instructor_id)

        # Skip cancellation message if this appears to be part of a recent reschedule
        if self._recent_reschedule_exists(conversation.id):
            self.logger.info(
                "Skipping cancellation system message due to recent reschedule",
                extra={"booking_id": booking_id, "conversation_id": conversation.id},
            )
            return

        student_first, instructor_first = self._get_participant_names(student_id, instructor_id)

        date_str = booking_date.strftime("%b %d")
        time_str = self._format_time(start_time)

        # Optionally include who cancelled
        if cancelled_by == "student":
            actor = student_first or "student"
            content = f"âŒ Lesson cancelled by {actor}: {date_str} at {time_str}"
        elif cancelled_by == "instructor":
            actor = instructor_first or "instructor"
            content = f"âŒ Lesson cancelled by {actor}: {date_str} at {time_str}"
        else:
            content = f"âŒ Lesson cancelled: {date_str} at {time_str}"

        self._create_system_message(
            conversation_id=conversation.id,
            booking_id=booking_id,
            content=content,
            message_type=MESSAGE_TYPE_SYSTEM_BOOKING_CANCELLED,
        )

        self.logger.info(
            f"Created booking_cancelled system message for booking {booking_id}",
            extra={
                "booking_id": booking_id,
                "conversation_id": conversation.id,
                "cancelled_by": cancelled_by,
            },
        )

    @BaseService.measure_operation("create_booking_rescheduled_message")
    def create_booking_rescheduled_message(
        self,
        student_id: str,
        instructor_id: str,
        booking_id: str,
        old_date: date,
        old_time: time,
        new_date: date,
        new_time: time,
    ) -> None:
        """
        Create system message when a booking is rescheduled.

        Args:
            student_id: ID of the student
            instructor_id: ID of the instructor
            booking_id: ID of the booking
            old_date: Original date
            old_time: Original time
            new_date: New date
            new_time: New time
        """
        conversation = self._get_or_create_conversation(student_id, instructor_id)

        old_date_str = old_date.strftime("%b %d")
        new_date_str = new_date.strftime("%b %d")
        new_time_str = self._format_time(new_time)

        # If same day, just show time change
        if old_date == new_date:
            old_time_str = self._format_time(old_time)
            content = f"ğŸ”„ Lesson rescheduled: {new_date_str}, {old_time_str} â†’ {new_time_str}"
        else:
            content = f"ğŸ”„ Lesson rescheduled: {old_date_str} â†’ {new_date_str} at {new_time_str}"

        self._create_system_message(
            conversation_id=conversation.id,
            booking_id=booking_id,
            content=content,
            message_type=MESSAGE_TYPE_SYSTEM_BOOKING_RESCHEDULED,
        )

        self.logger.info(
            f"Created booking_rescheduled system message for booking {booking_id}",
            extra={
                "booking_id": booking_id,
                "conversation_id": conversation.id,
            },
        )

    @BaseService.measure_operation("create_booking_completed_message")
    def create_booking_completed_message(
        self,
        student_id: str,
        instructor_id: str,
        booking_id: str,
        booking_date: date,
        service_name: Optional[str] = None,
    ) -> None:
        """
        Create system message when a booking is completed.

        Args:
            student_id: ID of the student
            instructor_id: ID of the instructor
            booking_id: ID of the booking
            booking_date: Date of the booking
            service_name: Optional name of the service
        """
        conversation = self._get_or_create_conversation(student_id, instructor_id)

        date_str = booking_date.strftime("%b %d")

        if service_name:
            content = f"âœ… Lesson completed: {service_name}, {date_str}"
        else:
            content = f"âœ… Lesson completed: {date_str}"

        self._create_system_message(
            conversation_id=conversation.id,
            booking_id=booking_id,
            content=content,
            message_type=MESSAGE_TYPE_SYSTEM_BOOKING_COMPLETED,
        )

        self.logger.info(
            f"Created booking_completed system message for booking {booking_id}",
            extra={
                "booking_id": booking_id,
                "conversation_id": conversation.id,
            },
        )

    def _get_or_create_conversation(
        self,
        student_id: str,
        instructor_id: str,
    ) -> Conversation:
        """Get existing conversation or create new one."""
        conversation, _ = self.conversation_repository.get_or_create(
            student_id=student_id,
            instructor_id=instructor_id,
        )
        return conversation

    def _get_participant_names(
        self, student_id: str, instructor_id: str
    ) -> tuple[Optional[str], Optional[str]]:
        """Fetch first names for participants (best-effort)."""
        names = self.conversation_repository.get_participant_first_names(
            [student_id, instructor_id]
        )
        return names.get(student_id), names.get(instructor_id)

    def _recent_reschedule_exists(self, conversation_id: str) -> bool:
        """
        Check if a reschedule system message was created recently for this conversation.

        Why this exists:
        When a user reschedules a booking, the system internally cancels the old booking
        and creates a new one. Without this check, users would see BOTH:
        - "Lesson rescheduled: Dec 12 â†’ Dec 10"
        - "Lesson cancelled by Emma: Dec 12"

        By detecting a recent reschedule message (within RESCHEDULE_DETECTION_WINDOW_MINUTES),
        we suppress the redundant cancellation message.

        Returns:
            True if a reschedule message exists within the detection window
        """
        return self.message_repository.has_recent_reschedule_message(conversation_id)

    def _run_async_task(
        self, coro_func: Callable[[], Coroutine[Any, Any, None]], error_context: str
    ) -> None:
        """
        Execute an async coroutine, handling both running and non-running event loops.

        This helper handles the common pattern of:
        - If we're already in an async context, create a task
        - If not, run with asyncio.run()
        - In both cases, log errors without raising (best effort)

        Args:
            coro_func: A callable that returns a coroutine (not the coroutine itself)
            error_context: Description for error logging (e.g., "publishing system message")
        """

        async def _with_error_handling() -> None:
            try:
                await coro_func()
            except Exception as e:  # pragma: no cover - best effort logging
                self.logger.warning(f"Failed {error_context}: {e}")

        try:
            loop = asyncio.get_running_loop()
            loop.create_task(_with_error_handling())
        except RuntimeError:
            # No running event loop - run synchronously
            try:
                asyncio.run(coro_func())
            except Exception as e:  # pragma: no cover - best effort logging
                self.logger.warning(f"Failed {error_context}: {e}")

    def _create_system_message(
        self,
        conversation_id: str,
        booking_id: str,
        content: str,
        message_type: str,
    ) -> None:
        """Create a system message (no sender_id)."""
        # Use transaction context manager to ensure proper commit
        with self.transaction():
            message = self.message_repository.create_conversation_message(
                conversation_id=conversation_id,
                sender_id=None,  # System messages have no sender
                content=content,
                message_type=message_type,
                booking_id=booking_id,
            )

            # Update conversation's last_message_at
            self.conversation_repository.update_last_message_at(conversation_id)

        # Publish SSE event AFTER transaction commits for real-time delivery
        # (best effort, do not block booking flow)
        async def _publish() -> None:
            await publish_new_message(
                db=self.db,
                message_id=str(message.id),
                content=message.content,
                sender_id=None,
                sender_name=None,
                conversation_id=conversation_id,
                created_at=message.created_at,
                booking_id=booking_id,
                delivered_at=message.delivered_at,
                message_type=message.message_type,
            )

        self._run_async_task(
            _publish,
            f"publishing system message to conversation {conversation_id}",
        )

    def _format_time(self, t: time) -> str:
        """Format time as '5pm' style."""
        hour = t.hour
        minute = t.minute
        period = "am" if hour < 12 else "pm"

        if hour == 0:
            hour = 12
        elif hour > 12:
            hour -= 12

        if minute == 0:
            return f"{hour}{period}"
        return f"{hour}:{minute:02d}{period}"
