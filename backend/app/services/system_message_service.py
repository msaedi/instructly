# backend/app/services/system_message_service.py
"""
System Message Service for booking lifecycle events.

Generates system messages in conversations when booking events occur:
- Booking created
- Booking cancelled
- Booking rescheduled
- Booking completed
"""

import asyncio
from datetime import date, time
import logging
from typing import Optional

from sqlalchemy.orm import Session

from ..models.conversation import Conversation
from ..models.message import (
    MESSAGE_TYPE_SYSTEM_BOOKING_CANCELLED,
    MESSAGE_TYPE_SYSTEM_BOOKING_COMPLETED,
    MESSAGE_TYPE_SYSTEM_BOOKING_CREATED,
    MESSAGE_TYPE_SYSTEM_BOOKING_RESCHEDULED,
)
from ..repositories.conversation_repository import ConversationRepository
from ..repositories.factory import RepositoryFactory
from ..repositories.message_repository import MessageRepository
from .base import BaseService
from .messaging import publish_new_message

logger = logging.getLogger(__name__)


class SystemMessageService(BaseService):
    """
    Service for creating system messages in conversations.

    System messages are auto-generated by booking lifecycle events
    and have no sender_id (they're from "the system").
    """

    def __init__(
        self,
        db: Session,
        conversation_repository: Optional[ConversationRepository] = None,
        message_repository: Optional[MessageRepository] = None,
    ):
        """
        Initialize system message service.

        Args:
            db: Database session
            conversation_repository: Optional repository for conversations
            message_repository: Optional repository for messages
        """
        super().__init__(db)
        self.conversation_repository = (
            conversation_repository or RepositoryFactory.create_conversation_repository(db)
        )
        self.message_repository = message_repository or RepositoryFactory.create_message_repository(
            db
        )
        self.logger = logging.getLogger(__name__)

    @BaseService.measure_operation("create_booking_created_message")
    def create_booking_created_message(
        self,
        student_id: str,
        instructor_id: str,
        booking_id: str,
        service_name: str,
        booking_date: date,
        start_time: time,
    ) -> None:
        """
        Create system message when a booking is created.

        Creates conversation if it doesn't exist (handles first booking).

        Args:
            student_id: ID of the student
            instructor_id: ID of the instructor
            booking_id: ID of the booking
            service_name: Name of the service booked
            booking_date: Date of the booking
            start_time: Start time of the booking
        """
        conversation = self._get_or_create_conversation(student_id, instructor_id)

        # Format the message
        date_str = booking_date.strftime("%b %d")  # e.g., "Dec 10"
        time_str = self._format_time(start_time)  # e.g., "5pm"
        content = f"ğŸ”” Lesson booked: {service_name}, {date_str} at {time_str}"

        self._create_system_message(
            conversation_id=conversation.id,
            booking_id=booking_id,
            content=content,
            message_type=MESSAGE_TYPE_SYSTEM_BOOKING_CREATED,
        )

        self.logger.info(
            f"Created booking_created system message for booking {booking_id}",
            extra={
                "booking_id": booking_id,
                "conversation_id": conversation.id,
            },
        )

    @BaseService.measure_operation("create_booking_cancelled_message")
    def create_booking_cancelled_message(
        self,
        student_id: str,
        instructor_id: str,
        booking_id: str,
        booking_date: date,
        start_time: time,
        cancelled_by: Optional[str] = None,  # 'student', 'instructor', or None
    ) -> None:
        """
        Create system message when a booking is cancelled.

        Args:
            student_id: ID of the student
            instructor_id: ID of the instructor
            booking_id: ID of the booking
            booking_date: Date of the booking
            start_time: Start time of the booking
            cancelled_by: Who cancelled ('student', 'instructor', or None)
        """
        conversation = self._get_or_create_conversation(student_id, instructor_id)

        date_str = booking_date.strftime("%b %d")
        time_str = self._format_time(start_time)

        # Optionally include who cancelled
        if cancelled_by == "student":
            content = f"âŒ Lesson cancelled by student: {date_str} at {time_str}"
        elif cancelled_by == "instructor":
            content = f"âŒ Lesson cancelled by instructor: {date_str} at {time_str}"
        else:
            content = f"âŒ Lesson cancelled: {date_str} at {time_str}"

        self._create_system_message(
            conversation_id=conversation.id,
            booking_id=booking_id,
            content=content,
            message_type=MESSAGE_TYPE_SYSTEM_BOOKING_CANCELLED,
        )

        self.logger.info(
            f"Created booking_cancelled system message for booking {booking_id}",
            extra={
                "booking_id": booking_id,
                "conversation_id": conversation.id,
                "cancelled_by": cancelled_by,
            },
        )

    @BaseService.measure_operation("create_booking_rescheduled_message")
    def create_booking_rescheduled_message(
        self,
        student_id: str,
        instructor_id: str,
        booking_id: str,
        old_date: date,
        old_time: time,
        new_date: date,
        new_time: time,
    ) -> None:
        """
        Create system message when a booking is rescheduled.

        Args:
            student_id: ID of the student
            instructor_id: ID of the instructor
            booking_id: ID of the booking
            old_date: Original date
            old_time: Original time
            new_date: New date
            new_time: New time
        """
        conversation = self._get_or_create_conversation(student_id, instructor_id)

        old_date_str = old_date.strftime("%b %d")
        new_date_str = new_date.strftime("%b %d")
        new_time_str = self._format_time(new_time)

        # If same day, just show time change
        if old_date == new_date:
            old_time_str = self._format_time(old_time)
            content = f"ğŸ”„ Lesson rescheduled: {new_date_str}, {old_time_str} â†’ {new_time_str}"
        else:
            content = f"ğŸ”„ Lesson rescheduled: {old_date_str} â†’ {new_date_str} at {new_time_str}"

        self._create_system_message(
            conversation_id=conversation.id,
            booking_id=booking_id,
            content=content,
            message_type=MESSAGE_TYPE_SYSTEM_BOOKING_RESCHEDULED,
        )

        self.logger.info(
            f"Created booking_rescheduled system message for booking {booking_id}",
            extra={
                "booking_id": booking_id,
                "conversation_id": conversation.id,
            },
        )

    @BaseService.measure_operation("create_booking_completed_message")
    def create_booking_completed_message(
        self,
        student_id: str,
        instructor_id: str,
        booking_id: str,
        booking_date: date,
        service_name: Optional[str] = None,
    ) -> None:
        """
        Create system message when a booking is completed.

        Args:
            student_id: ID of the student
            instructor_id: ID of the instructor
            booking_id: ID of the booking
            booking_date: Date of the booking
            service_name: Optional name of the service
        """
        conversation = self._get_or_create_conversation(student_id, instructor_id)

        date_str = booking_date.strftime("%b %d")

        if service_name:
            content = f"âœ… Lesson completed: {service_name}, {date_str}"
        else:
            content = f"âœ… Lesson completed: {date_str}"

        self._create_system_message(
            conversation_id=conversation.id,
            booking_id=booking_id,
            content=content,
            message_type=MESSAGE_TYPE_SYSTEM_BOOKING_COMPLETED,
        )

        self.logger.info(
            f"Created booking_completed system message for booking {booking_id}",
            extra={
                "booking_id": booking_id,
                "conversation_id": conversation.id,
            },
        )

    def _get_or_create_conversation(
        self,
        student_id: str,
        instructor_id: str,
    ) -> Conversation:
        """Get existing conversation or create new one."""
        conversation, _ = self.conversation_repository.get_or_create(
            student_id=student_id,
            instructor_id=instructor_id,
        )
        return conversation

    def _create_system_message(
        self,
        conversation_id: str,
        booking_id: str,
        content: str,
        message_type: str,
    ) -> None:
        """Create a system message (no sender_id)."""
        message = self.message_repository.create_conversation_message(
            conversation_id=conversation_id,
            sender_id=None,  # System messages have no sender
            content=content,
            message_type=message_type,
            booking_id=booking_id,
        )

        # Update conversation's last_message_at
        self.conversation_repository.update_last_message_at(conversation_id)

        # Publish SSE event for real-time delivery (best effort, do not block booking flow)
        async def _publish_system_message() -> None:
            await publish_new_message(
                db=self.db,
                message_id=str(message.id),
                content=message.content,
                sender_id=None,
                conversation_id=conversation_id,
                created_at=message.created_at,
                booking_id=booking_id,
                delivered_at=message.delivered_at,
                message_type=message.message_type,
            )

        try:
            loop = asyncio.get_running_loop()
        except RuntimeError:
            try:
                asyncio.run(_publish_system_message())
            except Exception as e:  # pragma: no cover - best effort logging
                self.logger.warning(
                    "Failed to publish SSE for system message",
                    extra={
                        "error": str(e),
                        "conversation_id": conversation_id,
                        "booking_id": booking_id,
                    },
                )
        else:
            loop.create_task(_publish_system_message())

    def _format_time(self, t: time) -> str:
        """Format time as '5pm' style."""
        hour = t.hour
        minute = t.minute
        period = "am" if hour < 12 else "pm"

        if hour == 0:
            hour = 12
        elif hour > 12:
            hour -= 12

        if minute == 0:
            return f"{hour}{period}"
        return f"{hour}:{minute:02d}{period}"
