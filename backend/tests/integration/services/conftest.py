# backend/tests/integration/services/conftest.py
"""Shared fixtures for integration service tests."""

from __future__ import annotations

from datetime import date, datetime, timedelta, timezone
from pathlib import Path
import sys
from typing import Callable
from unittest.mock import AsyncMock, patch
import uuid

import pytest
from sqlalchemy.orm import Session
import ulid

from app.models.availability_day import AvailabilityDay


def _create_unique_instructor(db: Session, *, email: str) -> dict[str, str]:
    """Create a unique instructor with an active service for isolated tests."""
    project_root = Path(__file__).resolve().parents[3]
    workspace_root = project_root.parent
    for candidate in (workspace_root, project_root):
        candidate_str = str(candidate)
        if candidate_str not in sys.path:
            sys.path.append(candidate_str)

    from app.auth import get_password_hash
    from app.core.enums import RoleName
    from app.models.instructor import InstructorProfile
    from app.models.service_catalog import InstructorService, ServiceCatalog, ServiceCategory
    from app.models.user import User
    from app.services.permission_service import PermissionService

    hashed_password = get_password_hash("TempPass123!")

    user = User(
        id=str(ulid.ULID()),
        email=email,
        hashed_password=hashed_password,
        first_name="Bitmap",
        last_name="Tester",
        phone="+12125550000",
        zip_code="10002",
        is_active=True,
    )
    db.add(user)
    db.flush()

    profile = InstructorProfile(
        id=str(ulid.ULID()),
        user_id=user.id,
        bio=f"Test instructor profile for {email}",
        years_experience=5,
        min_advance_booking_hours=2,
        buffer_time_minutes=15,
        bgc_status="passed",
        is_live=True,
        bgc_completed_at=datetime.now(timezone.utc),
    )
    db.add(profile)
    db.flush()

    permission_service = PermissionService(db)
    permission_service.assign_role(user.id, RoleName.INSTRUCTOR)

    category = (
        db.query(ServiceCategory)
        .filter(ServiceCategory.slug == "testing-services")
        .one_or_none()
    )
    if not category:
        category = ServiceCategory(
            id=str(ulid.ULID()),
            name="Testing Services",
            slug="testing-services",
            description="Autogenerated category for bitmap integration tests",
        )
        db.add(category)
        db.flush()

    catalog = ServiceCatalog(
        id=str(ulid.ULID()),
        name="Bitmap Test Lesson",
        slug=f"bitmap-test-{uuid.uuid4().hex[:8]}",
        category_id=category.id,
        is_active=True,
    )
    db.add(catalog)
    db.flush()

    instructor_service = InstructorService(
        id=str(ulid.ULID()),
        instructor_profile_id=profile.id,
        service_catalog_id=catalog.id,
        hourly_rate=60.0,
        duration_options=[30, 60],
        is_active=True,
    )
    db.add(instructor_service)
    db.flush()

    return {
        "instructor_id": user.id,
        "user_id": user.id,
        "profile_id": profile.id,
        "service_catalog_id": catalog.id,
        "instructor_service_id": instructor_service.id,
    }


@pytest.fixture
def unique_instructor(db: Session) -> tuple[str, str]:
    """
    Create a brand-new instructor user for the requesting test.

    Returns:
        Tuple containing (instructor_id, user_id).
    """
    email = f"bitmap-tester+{uuid.uuid4().hex[:8]}@example.com"
    bundle = _create_unique_instructor(db, email=email)
    return bundle["instructor_id"], bundle["user_id"]


@pytest.fixture
def clear_week_bits(db: Session) -> Callable[[str, date, int], None]:
    """
    Remove bitmap rows for the specified instructor across a week range.
    """

    def _clear(instructor_id: str, monday: date, weeks: int = 1) -> None:
        total_days = weeks * 7
        for offset in range(total_days):
            target_day = monday + timedelta(days=offset)
            (
                db.query(AvailabilityDay)
                .filter(
                    AvailabilityDay.instructor_id == instructor_id,
                    AvailabilityDay.day_date == target_day,
                )
                .delete(synchronize_session=False)
            )
        db.flush()

    return _clear


@pytest.fixture
def patch_warming() -> AsyncMock:
    """
    Patch CacheWarmingStrategy.warm_with_verification for the duration of a test.

    Returns the AsyncMock so that call counts can be asserted.
    """
    target = "app.services.cache_strategies.CacheWarmingStrategy.warm_with_verification"
    with patch(target, new_callable=AsyncMock) as warm_mock:
        yield warm_mock
