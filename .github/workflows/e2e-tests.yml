name: Frontend Tests

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'backend/**'
      - 'tools/mypy_strict_gate.sh'
      - 'backend/pyproject.toml'
      - 'backend/requirements*.txt'
      - 'backend/alembic/**'
      - 'backend/typings/**'
      - '.github/workflows/**'
      - '.pre-commit-config.yaml'
      - 'frontend/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'backend/**'
      - 'tools/mypy_strict_gate.sh'
      - 'backend/pyproject.toml'
      - 'backend/requirements*.txt'
      - 'backend/alembic/**'
      - 'backend/typings/**'
      - '.github/workflows/**'
      - '.pre-commit-config.yaml'
      - 'frontend/**'
  workflow_dispatch:
    inputs:
      invite_e2e:
        description: 'Run cross-origin invite e2e job'
        required: false
        type: boolean
        default: false
      auth_smoke:
        description: 'Run SameSite /api/v1/auth/me smoke test'
        required: false
        type: boolean
        default: false
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  unit-tests:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Setup Node.js (admin)
      if: ${{ matrix.project == 'admin' }}
      uses: actions/setup-node@v4
      with:
        node-version: '22.x'

    - name: Setup Node.js
      if: ${{ matrix.project != 'admin' }}
      uses: actions/setup-node@v4
      with:
        node-version: '22.x'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install frontend dependencies
      working-directory: ./frontend
      run: npm ci

    - name: Verify public env usage
      working-directory: ./frontend
      run: npm run verify:public-env

    - name: Run RBAC unit tests
      working-directory: ./frontend
      run: npm test

  e2e-tests:
    needs: [unit-tests]  # Don't spin up services if unit tests fail
    runs-on: ubuntu-latest
    timeout-minutes: 20  # Prevent orphaned runs
    strategy:
      fail-fast: false
      matrix:
        project: [instructor, admin, anon]
    concurrency:
      group: e2e-${{ github.workflow }}-${{ github.ref }}-${{ matrix.project }}
      cancel-in-progress: true

    # Job-level env applies to build and start (important for Next.js)
    env:
      # System
      TZ: UTC  # Lock timezone to avoid date flakes
      PYTHONUNBUFFERED: '1'  # Real-time logs from Python
      CI: 'true'  # Explicit CI flag
      NEXT_TELEMETRY_DISABLED: '1'  # Disable Next.js telemetry
      PW_TEST_HTML_REPORT_OPEN: 'never'  # Prevent report open attempts
      NODE_OPTIONS: '--max-old-space-size=2048'  # Give Next.js more memory in CI

      # Frontend (Next.js) - Required at build time
      NEXT_PUBLIC_API_BASE: http://localhost:8000
      NEXT_PUBLIC_APP_ENV: local
      NEXT_PUBLIC_USE_PROXY: 'false'
      NEXT_PUBLIC_APP_URL: http://localhost:3100
      PORT: 3100  # Ensure Next.js dev server binds to the right port
      PLAYWRIGHT_BASE_URL: http://localhost:3100
      SESSION_COOKIE_NAME: ${{ vars.SESSION_COOKIE_NAME || 'sid' }}
      SESSION_COOKIE_SAMESITE: ${{ vars.SESSION_COOKIE_SAMESITE || 'Lax' }}
      SESSION_COOKIE_SECURE: ${{ vars.SESSION_COOKIE_SECURE || 'false' }}
      CI_DEBUG_STORAGE: '1'

      # Backend - Ensure tests bypass beta gates
      SITE_MODE: local
      is_testing: 'true'
      TOTP_VALID_WINDOW: '1'
      CORS_ALLOW_ORIGINS: http://localhost:3100
      CORS_ALLOW_HEADERS: content-type,authorization,x-requested-with,x-csrf-token
      DATABASE_URL: postgresql://postgres:postgres@localhost:5432/instainstru_test
      TEST_DATABASE_URL: postgresql://postgres:postgres@localhost:5432/instainstru_test
      STG_DATABASE_URL: postgresql://postgres:postgres@localhost:5432/instainstru_test
      PROD_DATABASE_URL: postgresql://postgres:postgres@localhost:5432/instainstru_test
      REDIS_URL: redis://localhost:6379/0
      JWT_SECRET: test-secret-key-for-ci-only
      SECRET_KEY: test-secret-key-for-ci-only

      # Test user credentials (keep in sync with seed data)
      E2E_USER_EMAIL: john.smith@example.com
      E2E_USER_PASSWORD: Test1234
      E2E_INSTRUCTOR_EMAIL: sarah.chen@example.com
      E2E_INSTRUCTOR_PASSWORD: ${{ secrets.E2E_INSTRUCTOR_PASSWORD }}
      E2E_ADMIN_EMAIL: admin@instainstru.com
      E2E_ADMIN_PASSWORD: ${{ secrets.E2E_ADMIN_PASSWORD }}
      ADMIN_PASSWORD: ${{ secrets.E2E_ADMIN_PASSWORD }}
      E2E_CROSS_ORIGIN: "0"
      E2E_ENABLE_INVITES: "0"
      E2E_PROJECT: ${{ matrix.project }}
      EMAIL_PROVIDER: console

    services:
      postgres:
        image: ghcr.io/msaedi/instructly-ci-postgres:14-postgis-pgvector
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: instainstru_test
        options: >-
          --health-cmd "pg_isready -U postgres"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping || exit 1"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
    - uses: actions/checkout@v4

    - name: Ensure required tools are installed
      run: |
        sudo apt-get update && sudo apt-get install -y jq
        echo "✅ Required tools installed"

    - name: Log versions for diagnostics
      run: |
        echo "=== Version Information ==="
        echo "Node: $(node -v)"
        echo "npm: $(npm -v)"
        echo "Python: $(python --version)"
        echo "Playwright: $(npx playwright --version 2>/dev/null || echo 'Not installed yet')"
        echo "OS: $(lsb_release -a 2>/dev/null | grep Description | cut -f2)"
        echo "==========================="

    - name: Verify required environment variables
      run: |
        set -euo pipefail
        : "${NEXT_PUBLIC_API_BASE:?NEXT_PUBLIC_API_BASE is required}"
        : "${SITE_MODE:?SITE_MODE is required}"
        : "${DATABASE_URL:?DATABASE_URL is required}"
        : "${PORT:?PORT is required}"
        echo "✅ All required environment variables are set"

    - name: Mask sensitive values
      run: |
        echo "::add-mask::${{ env.JWT_SECRET }}"
        echo "::add-mask::${{ env.SECRET_KEY }}"
        echo "::add-mask::${{ env.DATABASE_URL }}"
        echo "::add-mask::${{ secrets.E2E_INSTRUCTOR_PASSWORD }}"
        echo "::add-mask::${{ secrets.E2E_ADMIN_PASSWORD }}"
        echo "::add-mask::postgresql://postgres:postgres@localhost:5432/instainstru_test"
        echo "::add-mask::test-secret-key-for-ci-only"
        echo "::add-mask::Bearer "
        echo "::add-mask::sk_live_"
        echo "::add-mask::sk_test_"
        echo "::add-mask::service_role"

    - name: Print cookie env
      run: |
        echo "PLAYWRIGHT_BASE_URL=$PLAYWRIGHT_BASE_URL"
        echo "SESSION_COOKIE_NAME=$SESSION_COOKIE_NAME"
        echo "SESSION_COOKIE_SAMESITE=$SESSION_COOKIE_SAMESITE"
        echo "SESSION_COOKIE_SECURE=$SESSION_COOKIE_SECURE"

    - name: Clean up existing processes
      run: |
        set -euo pipefail
        echo "Checking for port collisions..."
        if lsof -i :8000,:3100 2>/dev/null; then
          echo "⚠️ Ports in use, attempting graceful cleanup..."
          # Try TERM first (graceful)
          lsof -ti :8000 -sTCP:LISTEN | xargs -r kill || true
          lsof -ti :3100 -sTCP:LISTEN | xargs -r kill || true
          sleep 1
          # Then KILL if needed (forceful)
          lsof -ti :8000 -sTCP:LISTEN | xargs -r kill -9 || true
          lsof -ti :3100 -sTCP:LISTEN | xargs -r kill -9 || true
          pkill -f uvicorn || true
          pkill -f "npm run dev" || true
          pkill -f next || true
          sleep 2
          # Verify ports are actually free
          if lsof -i :8000 2>/dev/null || lsof -i :3100 2>/dev/null; then
            echo "❌ Failed to free ports"
            lsof -i :8000,:3100 || true
            exit 1
          fi
        fi
        echo "✅ Ports 8000 and 3100 are free"

    - name: Ensure test database exists
      run: |
        psql "postgresql://postgres:postgres@localhost:5432/postgres" -tAc "SELECT 1 FROM pg_database WHERE datname = 'instainstru_test'" | grep -q 1 \
          || psql "postgresql://postgres:postgres@localhost:5432/postgres" -c "CREATE DATABASE instainstru_test"

    # Backend setup
    - name: Setup Python (admin)
      if: ${{ matrix.project == 'admin' }}
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Setup Python (non-admin)
      if: ${{ matrix.project != 'admin' }}
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'
        cache-dependency-path: backend/requirements.txt

    - name: Check disk usage (before backend deps)
      run: df -h

    - name: Install backend dependencies
      working-directory: ./backend
      env:
        PIP_INDEX_URL: https://download.pytorch.org/whl/cpu
        PIP_EXTRA_INDEX_URL: https://pypi.org/simple
      run: |
        pip install --upgrade pip
        pip install --no-cache-dir -r requirements.txt
        echo "=== Key Python packages ==="
        pip freeze | grep -E 'fastapi|uvicorn|psycopg2|sqlalchemy|pydantic|redis' || true
        echo "==========================="

    - name: Check disk usage (after backend deps)
      run: df -h

    - name: Setup and seed test database
      working-directory: ./backend
      env:
        TEST_DATABASE_URL: ${{ env.DATABASE_URL }}
        STG_DATABASE_URL: ${{ env.DATABASE_URL }}
        PROD_DATABASE_URL: ${{ env.DATABASE_URL }}
      run: |
        set -euo pipefail
        # Run migrations and seed data using prep_db script
        python scripts/prep_db.py int --migrate --seed-all --force --yes
        echo "Database setup complete"

        # Verify database schema is accessible
        python - <<'PY'
        import os, sys
        try:
            # Try psycopg2 which is what the backend uses
            import psycopg2
            with psycopg2.connect(os.environ["DATABASE_URL"]) as conn:
                with conn.cursor() as cur:
                    cur.execute("SELECT 1")
                    result = cur.fetchone()
                    assert result[0] == 1
                    # Quick schema check
                    cur.execute("SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='public'")
                    table_count = cur.fetchone()[0]
                    print(f"✅ Database OK: {table_count} tables in public schema")
                    if table_count < 5:
                        print(f"❌ Error: Only {table_count} tables found, database may not be initialized")
                        sys.exit(1)
                    elif table_count < 10:
                        print(f"⚠️ Warning: Only {table_count} tables found (may be normal for minimal schema)")
        except ImportError:
            print("❌ psycopg2 not installed")
            sys.exit(1)
        except Exception as e:
            print(f"❌ Database check failed: {e}")
            sys.exit(1)
        PY

    - name: Start backend API
      working-directory: ./backend
      env:
        TEST_DATABASE_URL: ${{ env.TEST_DATABASE_URL }}
        STG_DATABASE_URL:  ${{ env.STG_DATABASE_URL }}
        PROD_DATABASE_URL: ${{ env.PROD_DATABASE_URL }}
      run: |
        set -euo pipefail
        # Start backend with logging to file and unbuffered output
        nohup python -m uvicorn app.main:app --host 0.0.0.0 --port 8000 --log-level info --access-log > backend.log 2>&1 &
        echo "$!" > backend.pid
        echo "Backend starting (PID: $(cat backend.pid)), waiting for health check..."

        # Wait for backend to be healthy with retries
        for i in {1..20}; do
          if curl -fS --retry 3 --retry-delay 2 --max-time 10 http://localhost:8000/health; then
            echo "✅ Backend is healthy (attempt $i/20)"
            # Verify expected headers
            if ! curl -fsSI http://localhost:8000/health -o /tmp/health-headers.txt; then
              curl -fsS -D - -o /dev/null http://localhost:8000/health > /tmp/health-headers.txt
            fi
            cat /tmp/health-headers.txt
            if ! grep -qi '^x-site-mode: local' /tmp/health-headers.txt; then
              echo "❌ Missing or incorrect X-Site-Mode header (expected: local)"
              cat /tmp/health-headers.txt
              exit 1
            fi
            if ! grep -qi '^x-testing: 1' /tmp/health-headers.txt; then
              echo "❌ Missing or incorrect X-Testing header (expected: 1)"
              cat /tmp/health-headers.txt
              exit 1
            fi
            echo "✅ Backend headers verified (X-Site-Mode: local, X-Testing: 1)"

            # Also verify JSON health response
            if curl -fsS http://localhost:8000/health | jq -e '.status=="healthy"' > /dev/null; then
              echo "✅ Backend health JSON validated"
            else
              echo "⚠️ Backend health JSON format unexpected"
            fi

            # Verify CORS preflight
            echo "Testing CORS preflight..."
            if curl -fsS -i -X OPTIONS http://localhost:8000/health \
              -H 'Origin: http://localhost:3100' \
              -H 'Access-Control-Request-Method: GET' \
              -H 'Access-Control-Request-Headers: content-type,x-csrf-token' \
              | grep -qi '^access-control-allow-origin: http://localhost:3100'; then
              echo "✅ CORS preflight headers validated"
            else
              echo "❌ CORS preflight check failed"
              curl -i -X OPTIONS http://localhost:8000/health \
                -H 'Origin: http://localhost:3100' \
                -H 'Access-Control-Request-Method: GET' \
                -H 'Access-Control-Request-Headers: content-type,x-csrf-token'
              exit 1
            fi

            # Verify CSRF protection (cross-origin POST should fail)
            echo "Testing CSRF protection..."
            CSRF_STATUS=$(curl -sS -o /dev/null -w "%{http_code}" -X POST http://localhost:8000/api/v1/auth/me \
              -H 'Origin: http://localhost:3100' \
              -H 'Content-Type: application/json' \
              -d '{}')
            if [ "$CSRF_STATUS" = "401" ] || [ "$CSRF_STATUS" = "403" ] || [ "$CSRF_STATUS" = "422" ]; then
              echo "✅ CSRF protection working (status: $CSRF_STATUS)"
            else
              echo "⚠️ CSRF check returned unexpected status: $CSRF_STATUS (expected 401/403/422)"
            fi

            # Auth sanity check with seeded user
            echo "Testing authentication flow..."
            AUTH_RESPONSE=$(curl -sS -X POST http://localhost:8000/api/v1/auth/login \
              -H 'Content-Type: application/x-www-form-urlencoded' \
              --data-urlencode "username=${E2E_USER_EMAIL}" \
              --data-urlencode "password=${E2E_USER_PASSWORD}")

            # Safely extract token without exposing it
            TOKEN=$(echo "$AUTH_RESPONSE" | jq -r '.access_token // empty' 2>/dev/null)

            if [ -n "$TOKEN" ] && [ "$TOKEN" != "null" ] && [ "$TOKEN" != "" ]; then
              echo "✅ Login successful, testing /api/v1/auth/me..."
              if curl -fsS http://localhost:8000/api/v1/auth/me \
                -H "Authorization: Bearer $TOKEN" \
                -o /dev/null; then
                echo "✅ Auth flow verified (login + protected endpoint)"
              else
                echo "❌ Auth verification failed: /api/v1/auth/me not accessible"
                exit 1
              fi
            else
              # Extract error message without exposing sensitive data
              ERROR_MSG=$(echo "$AUTH_RESPONSE" | jq -r '.detail // "Unknown error"' 2>/dev/null || echo "Malformed response")
              echo "❌ Login failed: $ERROR_MSG"
              echo "User: ${E2E_USER_EMAIL}"
              exit 1
            fi

            break
          fi
          echo "⏳ Waiting for backend... (attempt $i/20)"
          sleep 3
        done

        # Fail if backend didn't start
        if ! curl -fS --retry 3 --retry-delay 2 http://localhost:8000/health; then
          echo "❌ Backend failed to start after 60 seconds"
          echo "=== Last 100 lines of backend log ==="
          tail -100 backend.log
          exit 1
        fi

    # Frontend setup
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '22.x'
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: Install frontend dependencies
      working-directory: ./frontend
      run: npm ci

    - name: Cache Playwright & Next caches
      if: ${{ matrix.project != 'admin' }}
      uses: actions/cache@v3
      with:
        path: |
          ~/.cache/ms-playwright
          frontend/.next/cache
        key: e2e-${{ runner.os }}-${{ matrix.project }}-${{ hashFiles('frontend/package-lock.json') }}
        restore-keys: |
          e2e-${{ runner.os }}-${{ matrix.project }}-

    - name: Install Playwright browsers
      working-directory: ./frontend
      run: |
        echo "Installing Playwright browsers..."
        npx playwright install --with-deps chromium

    - name: Start frontend dev server
      working-directory: ./frontend
      run: |
        set -euo pipefail
        # Guard against accidental proxy mode
        if [ "$NEXT_PUBLIC_USE_PROXY" != "false" ]; then
          echo "❌ NEXT_PUBLIC_USE_PROXY must be 'false' in CI (currently: $NEXT_PUBLIC_USE_PROXY)"
          exit 1
        fi
        # Start frontend with explicit port binding
        nohup npm run dev:test -- --port 3100 > frontend.log 2>&1 &
        echo "$!" > frontend.pid
        echo "Frontend starting on port $PORT (PID: $(cat frontend.pid)), waiting for health check..."

        # Wait for frontend to be ready with retries
        for i in {1..20}; do
          if curl -fS --retry 3 --retry-delay 2 --max-time 10 http://localhost:3100/ -o /dev/null; then
            echo "✅ Frontend home page is ready (attempt $i/20)"
            # Also check an SSR page to ensure data fetching works
            if curl -fS --retry 3 --retry-delay 2 --max-time 10 http://localhost:3100/login -o /dev/null; then
              echo "✅ SSR page /login is responding correctly (status 200)"
              break
            else
              echo "⚠️ /login page not ready yet"
            fi
          fi
          echo "⏳ Waiting for frontend... (attempt $i/20)"
          sleep 3
        done

        # Fail if frontend didn't start
        if ! curl -fS --retry 3 --retry-delay 2 http://localhost:3100/ -o /dev/null; then
          echo "❌ Frontend failed to start after 60 seconds"
          echo "=== Last 100 lines of frontend log ==="
          tail -100 frontend.log
          exit 1
        fi

        # Final validation of SSR
        if ! curl -fS http://localhost:3100/login -o /dev/null; then
          echo "⚠️ Warning: SSR page /login not fully functional"
        fi

    - name: Auth smoke check (optional)
      if: ${{ matrix.project != 'anon' }}
      working-directory: ./backend
      run: python scripts/dev/auth_direct_check.py

    - name: Verify frontend bundle
      working-directory: ./frontend
      run: |
        set -euo pipefail
        echo "Checking frontend bundle configuration..."
        # Give Next.js time to compile
        sleep 3

        # Verify environment variables via CI endpoint
        echo "Verifying environment configuration via CI endpoint..."
        if curl -fsS http://localhost:3100/api/ci/env -H "x-ci-check: 1" | \
           jq -e --arg apiBase "$NEXT_PUBLIC_API_BASE" \
                 --arg appEnv "$NEXT_PUBLIC_APP_ENV" \
                 --arg useProxy "$NEXT_PUBLIC_USE_PROXY" \
                 --arg appUrl "$NEXT_PUBLIC_APP_URL" \
                 '.apiBase == $apiBase and .appEnv == $appEnv and .useProxy == $useProxy and .appUrl == $appUrl' > /dev/null; then
          echo "✅ Frontend environment variables verified:"
          curl -fsS http://localhost:3100/api/ci/env -H "x-ci-check: 1" | jq
        else
          echo "❌ Frontend environment mismatch!"
          echo "Expected:"
          echo "  API_BASE=$NEXT_PUBLIC_API_BASE"
          echo "  APP_ENV=$NEXT_PUBLIC_APP_ENV"
          echo "  USE_PROXY=$NEXT_PUBLIC_USE_PROXY"
          echo "  APP_URL=$NEXT_PUBLIC_APP_URL"
          echo "Actual:"
          curl -fsS http://localhost:3100/api/ci/env -H "x-ci-check: 1" | jq
          exit 1
        fi

        # Guard against accidental proxy flips and hardcoded backend URLs
        if [ "$NEXT_PUBLIC_USE_PROXY" = "true" ]; then
          echo "Ensuring bundle does NOT include direct backend URLs when proxying..."
          if grep -R -qE 'https?://(localhost|127\.0\.0\.1):(8000|8001)' .next/static 2>/dev/null; then
            echo "❌ Found direct backend URLs in bundle while USE_PROXY=true"
            grep -R -nE 'https?://(localhost|127\.0\.0\.1):(8000|8001)' .next/static 2>/dev/null | head -5
            exit 1
          fi
          echo "✅ No direct backend URLs in bundle (proxy mode)"
        else
          echo "Direct mode (USE_PROXY=false): allow exactly $NEXT_PUBLIC_API_BASE; flag other 8000/8001 targets..."
          ALLOWED_BASE="$NEXT_PUBLIC_API_BASE"
          OFFENDERS=$(grep -R -nE 'https?://(localhost|127\.0\.0\.1):(8000|8001)' .next/static 2>/dev/null \
                      | grep -v -F "$ALLOWED_BASE" | head -5 || true)
          if [ -n "$OFFENDERS" ]; then
            echo "❌ Found unexpected direct backend URL(s) not equal to ALLOWED_BASE=$ALLOWED_BASE"
            echo "$OFFENDERS"
            exit 1
          fi
          echo "✅ Bundle URLs look good for direct mode"
        fi
        echo "✅ Bundle verification complete"

    - name: Run Playwright (${{ matrix.project }})
      working-directory: ./frontend
      run: |
        set -euo pipefail
        # Run tests excluding any quarantined tests (allow failure to capture exit code)
        set +e
        npx playwright test --project='${{ matrix.project }}' --reporter=line --grep-invert @quarantine
        EXIT_CODE=$?
        set -e
        echo "Test exit code: $EXIT_CODE"

        # Show logs on test failure for debugging
        if [ "$EXIT_CODE" -ne 0 ]; then
          echo ""
          echo "=== Last 50 lines of frontend.log ==="
          tail -50 frontend.log || true
          echo ""
          echo "=== Last 50 lines of backend.log ==="
          tail -50 ../backend/backend.log || true
          echo ""
        fi

        # Count quarantined tests (informational)
        QUARANTINE_COUNT=$(grep -r '@quarantine' e2e/tests/ 2>/dev/null | wc -l || echo 0)
        if [ "${QUARANTINE_COUNT:-0}" -gt "5" ]; then
          echo ""
          echo "::warning::⚠️ $QUARANTINE_COUNT tests are quarantined (max recommended: 5)"
          echo "⚠️ Warning: $QUARANTINE_COUNT tests are quarantined (max recommended: 5)"
          echo "Please review and fix quarantined tests"
        elif [ "${QUARANTINE_COUNT:-0}" -gt "0" ]; then
          echo ""
          echo "::notice::ℹ️ $QUARANTINE_COUNT test(s) currently quarantined"
          echo "ℹ️ Note: $QUARANTINE_COUNT test(s) currently quarantined"
        fi

        # Summary for GitHub Actions
        echo ""
        echo "### Test Summary (${{ matrix.project }})" >> $GITHUB_STEP_SUMMARY || true
        echo "- Project: ${{ matrix.project }}" >> $GITHUB_STEP_SUMMARY || true
        echo "- Exit code: $EXIT_CODE" >> $GITHUB_STEP_SUMMARY || true
        echo "- Quarantined tests: $QUARANTINE_COUNT" >> $GITHUB_STEP_SUMMARY || true

        exit $EXIT_CODE

    - name: Upload Playwright report
      uses: actions/upload-artifact@v4
      if: failure()
      with:
        name: playwright-report-${{ matrix.project }}
        path: frontend/playwright-report/
        retention-days: 7

    - name: Upload server logs
      uses: actions/upload-artifact@v4
      if: failure()
      with:
        name: server-logs-${{ matrix.project }}
        path: |
          backend/backend.log
          frontend/frontend.log
        retention-days: 7

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results-${{ matrix.project }}
        path: frontend/test-results/
        retention-days: 7

    - name: Upload server logs (success)
      uses: actions/upload-artifact@v4
      if: success()
      with:
        name: server-logs-success-${{ matrix.project }}
        path: |
          backend/backend.log
          frontend/frontend.log
        retention-days: 3

    - name: Cleanup heavy caches (admin only)
      if: ${{ matrix.project == 'admin' }}
      run: |
        rm -rf ~/.cache/ms-playwright || true
        rm -rf frontend/.next/cache || true

    - name: Cleanup processes
      if: always()
      run: |
        set +e  # Don't fail on cleanup errors
        echo "Cleaning up processes and ports..."
        # Kill by PID files (graceful first)
        if [ -f backend/backend.pid ]; then
          kill $(cat backend/backend.pid) 2>/dev/null || true
        fi
        if [ -f frontend/frontend.pid ]; then
          kill $(cat frontend/frontend.pid) 2>/dev/null || true
        fi
        sleep 1
        # Kill by process name (graceful)
        pkill -f uvicorn || true
        pkill -f "npm run dev" || true
        pkill -f next || true
        sleep 1
        # Force-kill remaining processes
        pkill -9 -f uvicorn || true
        pkill -9 -f "npm run dev" || true
        pkill -9 -f next || true
        # Force-free ports as last resort
        lsof -ti :8000 -sTCP:LISTEN | xargs -r kill -9 || true
        lsof -ti :3100 -sTCP:LISTEN | xargs -r kill -9 || true
        # Final verification
        ! lsof -i:3100 && ! lsof -i:8000 && echo "✅ Cleanup complete" || echo "⚠️ Some processes may still be running"

  invite-e2e:
    if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.invite_e2e == 'true' }}
    needs:
      - e2e-tests
    runs-on: ubuntu-latest
    timeout-minutes: 45
    services:
      postgres:
        image: ghcr.io/msaedi/instructly-ci-postgres:14-postgis-pgvector
        ports: ['5432:5432']
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: instainstru_test
        options: >-
          --health-cmd="pg_isready -U postgres"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=10
      redis:
        image: redis:7-alpine
        ports: ['6379:6379']
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 10
    env:
      DATABASE_URL: postgresql://postgres:postgres@localhost:5432/instainstru_test
      TEST_DATABASE_URL: postgresql://postgres:postgres@localhost:5432/instainstru_test
      STG_DATABASE_URL: postgresql://postgres:postgres@localhost:5432/instainstru_test
      PROD_DATABASE_URL: postgresql://postgres:postgres@localhost:5432/instainstru_test
      SITE_MODE: local
      SECRET_KEY: dev-e2e-secret
      ALLOWED_ORIGINS: http://localhost:3000,http://beta-local.instainstru.com:3000
      PLAYWRIGHT_BASE_URL: http://localhost:3000
      REDIS_URL: redis://localhost:6379/0
    steps:
      - uses: actions/checkout@v4

      - name: Append beta-local host alias
        run: echo "127.0.0.1 beta-local.instainstru.com" | sudo tee -a /etc/hosts

      - name: Prepare artifacts directory
        run: |
          mkdir -p .artifacts
          touch .artifacts/backend.log .artifacts/frontend.log

      - name: Use Node 22.x
        uses: actions/setup-node@v4
        with:
          node-version: '22.x'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: backend/requirements.txt

      - name: Check disk usage (before backend deps)
        run: df -h

      - name: Install backend dependencies
        working-directory: backend
        env:
          PIP_INDEX_URL: https://download.pytorch.org/whl/cpu
          PIP_EXTRA_INDEX_URL: https://pypi.org/simple
        run: |
          python -m pip install --upgrade pip
          pip install --no-cache-dir -r requirements.txt

      - name: Check disk usage (after backend deps)
        run: df -h

      - name: Prepare database
        working-directory: backend
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          TEST_DATABASE_URL: ${{ env.TEST_DATABASE_URL }}
          STG_DATABASE_URL: ${{ env.STG_DATABASE_URL }}
          PROD_DATABASE_URL: ${{ env.PROD_DATABASE_URL }}
        run: |
          export stg_database_url="$STG_DATABASE_URL"
          export prod_database_url="$PROD_DATABASE_URL"
          until pg_isready -h localhost -p 5432 -U postgres; do sleep 1; done
          psql "postgresql://postgres:postgres@localhost:5432/postgres" -tc "SELECT 1 FROM pg_database WHERE datname = 'instainstru_test'" | grep -q 1 || \
            psql "postgresql://postgres:postgres@localhost:5432/postgres" -c 'CREATE DATABASE instainstru_test;'
          python scripts/prep_db.py int --migrate --seed-all --force --yes

      - name: Install frontend dependencies
        working-directory: frontend
        run: npm ci

      - name: Cache Playwright & Next caches
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/ms-playwright
            frontend/.next/cache
          key: invite-${{ runner.os }}-${{ hashFiles('frontend/package-lock.json') }}
          restore-keys: |
            invite-${{ runner.os }}-

      - name: Install Playwright browsers
        working-directory: frontend
        run: npx --yes playwright install --with-deps

      - name: Build frontend
        working-directory: frontend
        env:
          NEXT_PUBLIC_APP_ENV: preview
          NEXT_PUBLIC_API_BASE: http://localhost:8000
          NEXT_PUBLIC_APP_URL: http://localhost:3000
        run: npm run build

      - name: Start backend
        working-directory: backend
        env:
          SECRET_KEY: ${{ env.SECRET_KEY }}
          SITE_MODE: ${{ env.SITE_MODE }}
          ALLOWED_ORIGINS: ${{ env.ALLOWED_ORIGINS }}
          DATABASE_URL: ${{ env.DATABASE_URL }}
          TEST_DATABASE_URL: ${{ env.TEST_DATABASE_URL }}
          STG_DATABASE_URL: ${{ env.STG_DATABASE_URL }}
          PROD_DATABASE_URL: ${{ env.PROD_DATABASE_URL }}
          redis_url: ${{ env.REDIS_URL }}
        run: |
          rm -f ../.artifacts/backend.log
          touch ../.artifacts/backend.log
          export stg_database_url="$STG_DATABASE_URL"
          export prod_database_url="$PROD_DATABASE_URL"
          nohup uvicorn app.main:app --host 0.0.0.0 --port 8000 >> ../.artifacts/backend.log 2>&1 &
          echo $! > ../.artifacts/backend.pid

      - name: Start frontend (preview)
        working-directory: frontend
        env:
          NEXT_PUBLIC_APP_ENV: preview
          NEXT_PUBLIC_API_BASE: http://localhost:8000
          NEXT_PUBLIC_APP_URL: http://localhost:3000
          NODE_ENV: production
        run: |
          rm -f ../.artifacts/frontend.log
          touch ../.artifacts/frontend.log
          nohup npm run start -- -p 3000 >> ../.artifacts/frontend.log 2>&1 &
          echo $! > ../.artifacts/frontend.pid

      - name: Wait for services
        run: |
          npx --yes wait-on http://127.0.0.1:8000/health http://localhost:3000
          curl -sSf http://beta-local.instainstru.com:3000 >/dev/null

      - name: Run invite redemption e2e
        working-directory: frontend
        env:
          CI_LOCAL_E2E: '1'
          PLAYWRIGHT_BASE_URL: ${{ env.PLAYWRIGHT_BASE_URL }}
        run: npx --yes playwright test e2e/invites.invite-redemption.spec.ts --reporter=line --trace on-first-retry

      - name: Stop services
        if: always()
        run: |
          if [ -f .artifacts/frontend.pid ]; then kill $(cat .artifacts/frontend.pid) || true; fi
          if [ -f .artifacts/backend.pid ]; then kill $(cat .artifacts/backend.pid) || true; fi

      - name: Dump logs on failure
        if: failure()
        run: |
          echo '--- backend.log ---'
          cat .artifacts/backend.log || true
          echo '--- frontend.log ---'
          cat .artifacts/frontend.log || true

      - name: Upload service logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: invite-e2e-logs
          path: |
            .artifacts/backend.log
            .artifacts/frontend.log

      - name: Upload Playwright artifacts
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: invite-e2e-playwright
          path: |
            frontend/playwright-report
            frontend/test-results
          if-no-files-found: ignore

  auth-samesite-smoke:
    if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.auth_smoke == 'true' }}
    needs:
      - e2e-tests
    runs-on: ubuntu-latest
    timeout-minutes: 45
    services:
      postgres:
        image: ghcr.io/msaedi/instructly-ci-postgres:14-postgis-pgvector
        ports: ['5432:5432']
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: instainstru_test
        options: >-
          --health-cmd="pg_isready -U postgres"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=10
      redis:
        image: redis:7-alpine
        ports: ['6379:6379']
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 10
    env:
      DATABASE_URL: postgresql://postgres:postgres@localhost:5432/instainstru_test
      TEST_DATABASE_URL: postgresql://postgres:postgres@localhost:5432/instainstru_test
      STG_DATABASE_URL: postgresql://postgres:postgres@localhost:5432/instainstru_test
      PROD_DATABASE_URL: postgresql://postgres:postgres@localhost:5432/instainstru_test
      SITE_MODE: local
      SECRET_KEY: dev-e2e-secret
      ALLOWED_ORIGINS: http://localhost:3000,http://beta-local.instainstru.com:3000
      PLAYWRIGHT_BASE_URL: http://localhost:3000
      REDIS_URL: redis://localhost:6379/0
    steps:
      - uses: actions/checkout@v4

      - name: Append beta-local host aliases
        run: |
          echo "127.0.0.1 beta-local.instainstru.com" | sudo tee -a /etc/hosts
          echo "127.0.0.1 api.beta-local.instainstru.com" | sudo tee -a /etc/hosts

      - name: Prepare artifacts directory
        run: |
          mkdir -p .artifacts
          touch .artifacts/backend.log .artifacts/frontend.log

      - name: Use Node 22.x
        uses: actions/setup-node@v4
        with:
          node-version: '22.x'
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Set up Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: backend/requirements.txt

      - name: Check disk usage (before backend deps)
        run: df -h

      - name: Install backend dependencies
        working-directory: backend
        env:
          PIP_INDEX_URL: https://download.pytorch.org/whl/cpu
          PIP_EXTRA_INDEX_URL: https://pypi.org/simple
        run: |
          python -m pip install --upgrade pip
          pip install --no-cache-dir -r requirements.txt

      - name: Check disk usage (after backend deps)
        run: df -h

      - name: Prepare database
        working-directory: backend
        env:
          DATABASE_URL: ${{ env.DATABASE_URL }}
          TEST_DATABASE_URL: ${{ env.TEST_DATABASE_URL }}
          STG_DATABASE_URL: ${{ env.STG_DATABASE_URL }}
          PROD_DATABASE_URL: ${{ env.PROD_DATABASE_URL }}
        run: |
          export stg_database_url="$STG_DATABASE_URL"
          export prod_database_url="$PROD_DATABASE_URL"
          until pg_isready -h localhost -p 5432 -U postgres; do sleep 1; done
          psql "postgresql://postgres:postgres@localhost:5432/postgres" -tc "SELECT 1 FROM pg_database WHERE datname = 'instainstru_test'" | grep -q 1 || \
            psql "postgresql://postgres:postgres@localhost:5432/postgres" -c 'CREATE DATABASE instainstru_test;'
          python scripts/prep_db.py int --migrate --seed-all --force --yes

      - name: Install frontend dependencies
        working-directory: frontend
        run: npm ci

      - name: Cache Playwright & Next caches
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/ms-playwright
            frontend/.next/cache
          key: auth-${{ runner.os }}-${{ hashFiles('frontend/package-lock.json') }}
          restore-keys: |
            auth-${{ runner.os }}-

      - name: Install Playwright browsers
        working-directory: frontend
        run: npx --yes playwright install --with-deps

      - name: Build frontend
        working-directory: frontend
        env:
          NEXT_PUBLIC_APP_ENV: preview
          NEXT_PUBLIC_API_BASE: http://localhost:8000
          NEXT_PUBLIC_APP_URL: http://localhost:3000
        run: npm run build

      - name: Start backend
        working-directory: backend
        env:
          SECRET_KEY: ${{ env.SECRET_KEY }}
          SITE_MODE: ${{ env.SITE_MODE }}
          ALLOWED_ORIGINS: ${{ env.ALLOWED_ORIGINS }}
          DATABASE_URL: ${{ env.DATABASE_URL }}
          TEST_DATABASE_URL: ${{ env.TEST_DATABASE_URL }}
          STG_DATABASE_URL: ${{ env.STG_DATABASE_URL }}
          PROD_DATABASE_URL: ${{ env.PROD_DATABASE_URL }}
          REDIS_URL: ${{ env.REDIS_URL }}
        run: |
          rm -f ../.artifacts/backend.log
          touch ../.artifacts/backend.log
          export stg_database_url="$STG_DATABASE_URL"
          export prod_database_url="$PROD_DATABASE_URL"
          nohup uvicorn app.main:app --host 0.0.0.0 --port 8000 >> ../.artifacts/backend.log 2>&1 &
          echo $! > ../.artifacts/backend.pid

      - name: Start frontend (preview)
        working-directory: frontend
        env:
          NEXT_PUBLIC_APP_ENV: preview
          NEXT_PUBLIC_API_BASE: http://localhost:8000
          NEXT_PUBLIC_APP_URL: http://localhost:3000
          NODE_ENV: production
        run: |
          rm -f ../.artifacts/frontend.log
          touch ../.artifacts/frontend.log
          nohup npm run start -- -p 3000 >> ../.artifacts/frontend.log 2>&1 &
          echo $! > ../.artifacts/frontend.pid

      - name: Wait for services
        run: |
          npx --yes wait-on http://127.0.0.1:8000/health http://localhost:3000
          curl -sSf http://beta-local.instainstru.com:3000 >/dev/null

      - name: Run SameSite auth smoke
        working-directory: frontend
        env:
          CI_LOCAL_E2E: '1'
          PLAYWRIGHT_BASE_URL: ${{ env.PLAYWRIGHT_BASE_URL }}
        run: CI_LOCAL_E2E=1 npx --yes playwright test e2e/auth.samesite-me.spec.ts --reporter=line --trace on-first-retry

      - name: Stop services
        if: always()
        run: |
          if (test -f .artifacts/frontend.pid); then kill $(cat .artifacts/frontend.pid) || true; fi
          if (test -f .artifacts/backend.pid); then kill $(cat .artifacts/backend.pid) || true; fi

      - name: Dump logs on failure
        if: failure()
        run: |
          echo '--- backend.log ---'
          cat .artifacts/backend.log || true
          echo '--- frontend.log ---'
          cat .artifacts/frontend.log || true

      - name: Upload service logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: auth-samesite-smoke-logs
          path: |
            .artifacts/backend.log
            .artifacts/frontend.log

      - name: Upload Playwright artifacts
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: auth-samesite-playwright
          path: |
            frontend/playwright-report
            frontend/test-results
          if-no-files-found: ignore
