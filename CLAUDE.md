# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## üèÜ Key Architectural Achievements & Defenses

### Repository Pattern: 29% ‚Üí 100% ‚úÖ
- **Achievement**: Fixed 107 violations, created 4 new repositories, TRUE 100% compliance
- **Defense**: Pre-commit hook blocks any new `db.query()` in services
- **Result**: Architecture integrity permanently protected

### Timezone Consistency: 28 Fixes ‚úÖ
- **Achievement**: Fixed all timezone bugs, platform is globally ready
- **Defense**: Pre-commit hook blocks `date.today()` in user-facing code
- **Result**: No timezone bugs can be reintroduced

### Database Safety: 3-Tier Protection ‚úÖ
- **Achievement**: INT/STG/PROD separation with confirmation gates
- **Defense**: Automatic INT database default, production requires confirmation
- **Result**: Impossible to accidentally modify production

These defensive measures ensure our hard-won architectural improvements are permanent.

## Project Overview

InstaInstru is a marketplace platform for instantly booking private instructors in NYC. It's a full-stack application with:
- **Backend**: FastAPI (Python) with PostgreSQL, SQLAlchemy, and Redis caching
- **Frontend**: Next.js 15 with TypeScript and Tailwind CSS v4
- **Architecture**: Clean architecture with separated services, repositories, and route handlers

## üî¥ CRITICAL: ULID Architecture - ALL IDs are Strings!

**BREAKING CHANGE ALERT**: All IDs in the system are now ULIDs (26-character strings), NOT integers!

### What are ULIDs?
- **Universally Unique Lexicographically Sortable Identifiers**
- Example: `01K2GY3VEVJWKZDVH5HMNXEVRD` (always exactly 26 characters)
- Time-sortable (creation timestamp embedded)
- Case-insensitive in URLs
- Generated by application, not database

### Key Points - THIS WILL BREAK IF IGNORED:
- **ALL IDs are strings**: `id: string` not `id: number`
- **26 characters long**: Always exactly 26 characters
- **No sequential integers**: We don't use auto-increment
- **No numeric operations**: Can't use parseInt(), ++, or numeric comparisons

### Working with ULIDs:

**Python (Backend):**
```python
import ulid

# Generate new ULID
new_id = str(ulid.ULID())  # Returns: '01K2GY3VEVJWKZDVH5HMNXEVRD'

# Model definition
class User(Base):
    id: Mapped[str] = mapped_column(String(26), primary_key=True, default=lambda: str(ulid.ULID()))
```

**TypeScript (Frontend):**
```typescript
// ALL IDs are strings - NEVER use number!
interface User {
  id: string;           // NOT number! Always ULID string
  instructor_id: string;  // NOT number!
  booking_id: string;     // NOT number!
}

// API calls
GET /api/instructors/01K2GY3VEVJWKZDVH5HMNXEVRD  // NOT /api/instructors/123
```

**Test Data:**
```typescript
// Use proper ULID format in tests
const TEST_USER_ID = '01K2MAY484FQGFEQVN3VKGYZ58';      // ‚úÖ Correct
const TEST_BOOKING_ID = '01K2MAY484FQGFEQVN3VKGYZ59';   // ‚úÖ Correct
// const TEST_ID = 123;  // ‚ùå NEVER DO THIS!
```

### Common Pitfalls That WILL Break:
- **Don't use parseInt() on IDs** - They're ULID strings!
- **Don't compare IDs numerically** - Use string comparison
- **Don't generate sequential test IDs** - Use proper ULIDs
- **Don't assume IDs are short** - Always 26 characters
- **Don't use number type in TypeScript** - Always string

## üîß CI Database Image

**CRITICAL**: Our CI uses a custom PostgreSQL image with PostGIS + pgvector extensions.

### Image Details
- **Location**: `ghcr.io/msaedi/instructly-ci-postgres:14-postgis-pgvector`
- **Source**: `.github/docker/postgres-ci/Dockerfile`
- **Build**: Automated via `.github/workflows/build-ci-database.yml`
- **Base**: `postgis/postgis:14-3.3` + pgvector installed

### Why Custom Image?
- No official image includes both PostGIS AND pgvector
- CI tests require both extensions for spatial features and NL search
- Migrations will FAIL without both extensions

### ‚ö†Ô∏è DO NOT:
- Use random community images (security risk)
- Remove pgvector or PostGIS from migrations
- Change CI to use standard postgres image

## üó∫ Spatial Intelligence with PostGIS (v95)

### Location Architecture
- **Global Scalability**: Generic region boundaries support any city
- **PostGIS Enabled**: Spatial queries with GiST indexes
- **Provider-Agnostic Geocoding**: Swap between Google/Mapbox/Mock
- **Address Management**: Full CRUD with Google Places autocomplete
- **Region Detection**: Automatic neighborhood/region assignment

### Key Spatial Features
```python
# Region boundary detection with PostGIS
ST_Contains(region_boundaries.geometry, ST_MakePoint(lng, lat))

# Spatial repositories with performance metrics
RegionBoundaryRepository.find_region_for_point(lat, lng)
UserAddressRepository.create_with_geocoding(address_data)
```

### Database Tables
- **user_addresses**: User addresses with geocoding and metadata
- **region_boundaries**: Generic regions (NYC neighborhoods ready)
- **instructor_service_areas**: Service area preferences with regions

## üéØ Natural Language Search Excellence (v94)

### Search Capabilities
- **Typo Tolerance**: Handles common misspellings using pg_trgm
- **Morphology**: Word form normalization (teach/teacher/teaching)
- **Hybrid Scoring**: Combines semantic vectors with text similarity
- **Zero-Result Handling**: Shows related options via vector neighbors
- **Performance**: Sub-50ms with GIN indexes

### PostgreSQL pg_trgm Extension
```sql
-- Fuzzy text search with trigram similarity
WHERE name % 'query' OR similarity(name, 'query') >= 0.3
ORDER BY similarity(name, 'query') DESC
```

### Search Observability
- Persists top-N candidates with scores
- Admin dashboards for category trends
- Query-level debugging and analysis

## üö® CRITICAL: Client-Side Caching with React Query

InstaInstru uses React Query (TanStack Query v5) for ALL data fetching. This is MANDATORY - no exceptions.

### Why This Matters
- 60-80% reduction in API calls
- Instant page navigation
- Better user experience
- Reduced server costs

### The Golden Rules
1. **NEVER use fetch() or useEffect for API calls** - Always use React Query
2. **INCREMENTAL approach only** - Add caching to existing code, don't rewrite entire files
3. **Preserve ALL UI/UX** - Caching changes data fetching, not appearance
4. **Test caching works** - Use DevTools to verify

### Quick Implementation Pattern
```jsx
// ‚úÖ CORRECT - Use React Query
import { useQuery } from '@tanstack/react-query';
import { queryKeys } from '@/lib/react-query/queryClient';
import { queryFn } from '@/lib/react-query/api';

const { data, isLoading } = useQuery({
  queryKey: queryKeys.instructors.search({ service: 'yoga' }),
  queryFn: () => queryFn('/api/instructors/search?service=yoga'),
  staleTime: 1000 * 60 * 5, // 5 minutes
});

// ‚ùå WRONG - Direct fetch
useEffect(() => {
  fetch('/api/instructors/search?service=yoga')
    .then(res => res.json())
    .then(setData);
}, []);
```

### Cache Time Quick Reference
- **User data**: `Infinity` (session-long)
- **Categories/Services**: `1 hour` (static content)
- **Instructor profiles**: `15 minutes`
- **Search results**: `5 minutes`
- **Availability**: `5 minutes` with background refresh
- **Real-time data**: `1 minute`

### Testing Your Implementation
1. Load page ‚Üí Check Network tab for API calls
2. Navigate away and back
3. ‚úÖ Success: No API calls (using cache)
4. ‚ùå Failure: API calls made (cache not working)

## Current Project State & Priorities

### Critical Context
- **Mission**: Building for MEGAWATTS of energy allocation - quality over speed
- **Platform Status**: ~89-91% complete (booking flow works, address management complete!)
- **Test Coverage**: 1452+ tests passing (100%), comprehensive coverage with spatial tests
- **Major Blockers**: Payment integration (Stripe) and Reviews/Ratings system

### Immediate Priorities
1. **Payment Mock Fix**: Quick fix to restore testing capability (2-3 hours)
2. **Payment Integration (Stripe)**: CRITICAL - No revenue without this (2-3 days)
3. **Reviews/Ratings System**: Design decision needed, then implement (3-4 days)
4. **Security Audit**: Critical for launch (1-2 days)
5. **Load Testing**: Verify scalability (3-4 hours)

### CORRECTION: What Actually Works ‚úÖ
- **Instructor Profile Page**: 100% COMPLETE (was incorrectly reported as blocking)
- **Booking Flow**: COMPLETE except payment processing
- **Availability Selection**: Working with duration constraints
- **Favorites System**: Working with heart icons
- **Booking Confirmation**: Shows correct information
- **Student Dashboard**: Functional (shows lessons, can cancel)
- **Address Management**: Complete with Google Places autocomplete
- **Spatial Location Services**: PostGIS-enabled with region boundaries

### Recently Completed ‚úÖ
1. **Complete Address Management System**: Full CRUD with Google Places autocomplete (v95)
2. **PostGIS Spatial Queries**: Region boundaries and spatial intelligence (v95)
3. **Natural Language Search Excellence**: World-class search with typo tolerance (v94)
4. **ULID Migration**: All IDs are 26-character strings (v93)
5. **Favorites System**: Students can favorite instructors (v93)
6. **Timezone Detection**: Auto-detect from ZIP code (v93)
7. **Database Safety System**: Three-tier protection (INT/STG/PROD)
8. **RBAC System**: 30 permissions replacing role-based access

## Key Architectural Decisions

- **NO SLOT IDs**: Time-based booking only (instructor_id, date, start_time, end_time)
- **Layer Independence**: Bookings don't reference availability slots (Work Stream #9)
- **Single-Table Design**: Just availability_slots table (no InstructorAvailability)
- **Repository Pattern**: 100% implemented across all services
- **RBAC System**: Full Role-Based Access Control with permissions, NOT simple role checking
- **Redis Architecture**: Single Redis instance for caching, Celery broker, and sessions
- **Database Safety**: Three-tier protection system preventing production accidents
- **Privacy Framework**: GDPR compliance with automated retention and user controls
- **Clean Break Philosophy**: No backward compatibility during dev - edit existing migrations

### Technical Debt Details
Frontend believes slots are database entities with IDs (WRONG). The operation pattern in useAvailabilityOperations.ts is 600+ lines that should be ~50 lines. Mental model mismatch causes 5x slower development.

### Critical Files & Patterns
#### Frontend Technical Debt (3,000+ lines to remove):
- frontend/src/hooks/useAvailabilityOperations.ts (600‚Üí50 lines)
- frontend/src/utils/operationGenerator.ts (DELETE ENTIRELY)
- frontend/src/types/availability.ts (remove slot ID references)
- frontend/src/utils/slotHelpers.ts (complex‚Üísimple time helpers)

#### Backend Excellence (maintain these patterns):
- All services extend BaseService
- Use @measure_operation decorator on public methods
- Repository pattern: service.repository.method() not direct DB
- Transaction pattern: with self.transaction(): not db.commit()
- No singletons - all services use dependency injection

### Service Quality Scores (maintain or improve):
- ConflictChecker: 9/10 (99% test coverage)
- SlotManager: 9/10 (97% coverage)
- BookingService: 8/10 (97% coverage)
- AvailabilityService: 8/10 (63% coverage - needs work)

## üõ°Ô∏è Database Safety System

### Three-Tier Database Architecture
We use a **safe-by-default** three-tier database system:

1. **INT (Integration Test DB)** üü¢
   - **Default database** - no flags needed
   - Database name: `instainstru_test`
   - Used for: pytest, scripts without explicit database selection
   - Can be freely dropped/reset

2. **STG (Staging/Local Dev DB)** üü°
   - Requires `USE_STG_DATABASE=true`
   - Database name: `instainstru_stg`
   - Used for: local development, preserves data between test runs
   - Automatically used by: `./run_backend.py`, `./run_celery_worker.py`, etc.

3. **PROD (Production DB)** üî¥
   - Requires `USE_PROD_DATABASE=true` + interactive confirmation
   - Database: Supabase PostgreSQL
   - Protection: Must type "yes" to confirm access
   - Non-interactive mode: Raises error (production servers need `INSTAINSTRU_PRODUCTION_MODE=true`)

### How Database Safety Works

**The Critical Innovation**: `settings.database_url` is now a **property** that defaults to INT database!

```python
# This used to be dangerous (went straight to production):
db_url = settings.database_url  # ‚ùå OLD: Production!

# Now it's safe by default:
db_url = settings.database_url  # ‚úÖ NEW: INT database!
```

### Database Commands

**Primary tool**: `prep_db.py` - Does everything (migrations, seeding, embeddings)
```bash
python scripts/prep_db.py        # Default: INT database
python scripts/prep_db.py int    # Explicit INT
python scripts/prep_db.py stg    # Staging database
python scripts/prep_db.py prod   # Production (requires confirmation)
```

**Local development setup**:
```bash
# First time only - create databases
python scripts/prep_db.py int
python scripts/prep_db.py stg

# Start services (automatically use STG)
./run_backend.py
./run_celery_worker.py

# Run tests (automatically use INT)
pytest -v
```

### Environment Variables
- `USE_STG_DATABASE=true` - Use staging database
- `USE_PROD_DATABASE=true` - Use production (requires confirmation)
- `INSTAINSTRU_PRODUCTION_MODE=true` - Allow production servers to access without confirmation
- `CI=true` - CI/CD environments can use their own DATABASE_URL
- No flag = INT database (safest default)

## üõ°Ô∏è Defensive Measures: Preventing Architectural Regression

The project has **strong defensive measures** to prevent regression. These automated guards ensure architectural achievements are never lost.

### Installation
```bash
cd /path/to/instructly
pre-commit install
```

### Active Hooks

#### 1. **Repository Pattern Compliance** (`check-repository-pattern`)
**Purpose**: Ensures services only use repositories for database access.

**Violation patterns detected**:
```python
# ‚ùå These will be blocked:
self.db.query(User).filter(...)
self.db.add(booking)
self.db.commit()

# ‚úÖ Use repositories instead:
self.repository.get_user_by_id(user_id)
self.repository.create_booking(booking_data)
```

**Markers for exceptions**:
```python
# For legitimate database access:
# repo-pattern-ignore: Transaction management requires direct DB
with self.db.begin_nested():
    ...
```

#### 2. **Timezone Consistency** (`check-timezone-usage`)
**Purpose**: Prevents timezone bugs by blocking `date.today()` in user-facing code.

```python
# ‚ùå This will be blocked:
today = date.today()

# ‚úÖ Use timezone-aware alternative:
from app.core.timezone_utils import get_user_today_by_id
user_today = get_user_today_by_id(user_id, self.db)
```

#### 3. **API Contract Compliance** (`api-contracts`)
**Purpose**: Ensures all API endpoints return proper Pydantic response models.

### Bypassing Hooks (Emergency Only)
```bash
git commit --no-verify -m "Emergency fix: reason"
```
‚ö†Ô∏è Only use for critical production fixes. Create follow-up task to fix violations.

### CI/CD Integration
Multi-layer defense ensures no regression:
1. **Local Development**: Pre-commit hooks block violations
2. **Pull Request Level**: GitHub Actions runs all checks
3. **Merge Protection**: PRs cannot merge if violations detected

## Features & Systems

### Automatic Timezone Detection
Users' timezones are automatically set based on ZIP code during registration:
- **NYC zips (100-119)** ‚Üí America/New_York
- **LA zips (900-969)** ‚Üí America/Los_Angeles
- **Chicago zips (606-608)** ‚Üí America/Chicago
- **Invalid/missing** ‚Üí defaults to America/New_York

### Favorites System
Students can favorite/unfavorite instructors:
- **Heart icons** visible to all users
- **Optimistic UI updates** - Instant feedback
- **5-minute cache TTL** - Balance freshness/performance
- **API**: POST/DELETE `/api/favorites/{instructor_id}`

### Schema-Owned Construction Pattern
**Architectural Innovation**: Schemas own their privacy transformation logic.

```python
class InstructorInfo:
    @classmethod
    def from_user(cls, user):
        """Handles privacy transformation - returns FirstName L. format"""
        return cls(
            first_name=user.first_name,
            last_initial=user.last_name[0] if user.last_name else "",
            # Never expose full last name to students
        )
```

### Asset Management with Cloudflare R2
All images served via Cloudflare R2:
- **Custom domain**: assets.instainstru.com
- **80% bandwidth reduction** via Image Transformations
- **Cost**: ~$10/month total

## Infrastructure

### Production Services (Render)
- **API**: instructly-backend (Web Service)
- **Redis**: instructly-redis (Private Service, $7/month)
- **Celery Worker**: instructly-celery (Background Worker)
- **Celery Beat**: instructly-celery-beat (Background Worker)
- **Flower**: instructly-flower (Web Service for monitoring)
- **Database**: Supabase PostgreSQL (external)
- **Total Cost**: $53/month

### Key Infrastructure Updates
- Redis handles all caching, Celery broker, and session needs
- Celery runs analytics processing with async privacy-first design
- Monitoring endpoints require ACCESS_MONITORING permission

## Documentation Structure

Key project documentation in `docs/`:
- **Project Overview**: `docs/project-overview/01_core_project_info.md`
- **Architecture State**: `docs/architecture/02_architecture_state.md`
- **Work Streams Status**: `docs/project-status/03_work-streams-status.md`
- **System Capabilities**: `docs/project-status/04_system-capabilities.md`
- **Frontend Cleanup Guide**: `docs/project-status/Frontend Technical Debt Cleanup Checklist - Work Stream #13.md`

A-Team designs in `docs/a-team-deliverables/`:
- **Implementation Guide**: `student-booking-implementation-guide.md`
- **UI Components**: `missing-ui-components.md`

All designs are ASCII mockups with exact specifications. These ARE the official designs.

## Development Approach: Database Migrations

### During Development Phase (No Production Data)
**Important**: Modify existing Alembic migration files instead of creating new ones.

**Workflow for Schema Changes**:
1. **Modify existing migration files** in `backend/alembic/versions/`
2. **Test using INT database**: `python scripts/prep_db.py int`
3. **Reset and rebuild**: Since no production data exists
4. **Use prep_db.py** for all database operations

**DO NOT** create new migration files with `alembic revision` during development.

## Essential Commands

### Test Credentials
- **Test User Email**: john.smith@example.com (or any seeded user)
- **Test Password**: Test1234

### Backend Development
```bash
# Setup and run backend
cd backend
source venv/bin/activate  # On Windows: venv\Scripts\activate
uvicorn app.main:app --reload

# Run tests
pytest                           # All tests
pytest -m unit                   # Unit tests only
pytest -m integration            # Integration tests only
pytest -k "test_name"           # Single test

# Database operations (DEVELOPMENT MODE)
python scripts/prep_db.py int   # Reset INT database
python scripts/prep_db.py stg   # Reset STG database

# Code quality
black .                         # Format Python code
isort .                         # Sort imports
```

### Frontend Development
```bash
# Setup and run frontend
cd frontend
npm run dev                     # Development server
npm run build                   # Production build
npm run lint                    # Run ESLint
```

### Redis & Celery Management
```bash
docker-compose up -d            # Start Redis
docker-compose down             # Stop services

# Local Celery commands
celery -A app.tasks.celery_app worker --loglevel=info
celery -A app.tasks.celery_app beat --loglevel=info
celery -A app.tasks.celery_app flower  # Monitoring UI
```

## High-Level Architecture

### Backend Architecture (FastAPI)
1. **Routes Layer**: FastAPI endpoints handling HTTP requests
2. **Services Layer**: Business logic with dependency injection
3. **Repositories Layer**: Data access abstraction with SQLAlchemy
4. **Models Layer**: Database schema definitions
5. **Schemas Layer**: Pydantic models for validation

### Frontend Architecture (Next.js 15)
- **App Directory**: Page routing and layouts
- **Components**: Reusable UI components
- **Hooks**: Custom React hooks for shared logic
- **Lib**: API client and utilities
- **Types**: TypeScript interfaces matching backend schemas

### Key Patterns
1. **Dependency Injection**: Services injected via FastAPI's system
2. **Caching**: Single Redis instance for all needs
3. **Authentication**: JWT-based with RBAC permissions
4. **Error Handling**: Consistent responses with custom exceptions
5. **API Standards**: ALL endpoints use Pydantic response models
6. **Testing**: UUID-based unique data prevents conflicts

## Configuration

### Environment Variables
- Backend: Copy `.env.example` to `.env`
- Frontend: Copy `.env.local.example` to `.env.local`
- Never commit `.env` files

### API Integration
- Frontend API client at `frontend/lib/api.ts`
- Backend API docs available at `/docs` when running
- CORS configured for local development

## Frontend Logging Standards

**CRITICAL: Use Proper Logging, NOT console.log**

```typescript
// ‚ùå WRONG - Never use console.log
console.log('Debug message');

// ‚úÖ CORRECT - Use the logger
import { logger } from '@/lib/logger';
logger.debug('Debug message', { context: data });
logger.info('Info message');
logger.warn('Warning message');
logger.error('Error message', error);
```

**Setting log level**:
```javascript
// In browser console
localStorage.setItem('log-level', 'debug'); // or 'info', 'warn', 'error'
```

## Common Development Tasks

### Adding New Features
1. Create database model in `backend/app/models/`
2. Create Pydantic schemas in `backend/app/schemas/`
3. Add repository methods in `backend/app/repositories/`
4. Implement service logic in `backend/app/services/`
5. Create API routes in `backend/app/routes/`
6. Add tests in `backend/tests/`
7. Update frontend types and API client
8. Implement UI components

### Performance Optimization
- Use monitoring middleware data at `/metrics/performance`
- Profile slow queries with SQLAlchemy logging
- Leverage caching for read-heavy operations
- Database indexes already configured

### Debugging
- Backend logs are comprehensive with proper formatting
- Use pytest's `-vv` flag for detailed test output
- Check `/health` endpoint for system status

## Team Structure
- **X-Team**: Technical implementation (you are part of this)
- **A-Team**: UX/Design decisions (separate team, we await their input)

When working on any feature, ALWAYS check the documentation first for context and current state.

Remember: We're building for MEGAWATTS! Quality over speed. Launch when AMAZING.
